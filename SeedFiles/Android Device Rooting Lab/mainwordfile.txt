SEEDLabsŒAndroidDeviceRootingLab 1 AndroidDeviceRootingLab Copyright©2018WenliangDu SyracuseUniversity ThedevelopmentofthisdocumentwaspartiallyfundedbytheNationalScienceFoundationunderAward No.1303306and1718086.ThisworkislicensedunderaCreativeCommonsAttribution-NonCommercial- ShareAlike4.0InternationalLicense.Ahuman-readablesummaryof andnotasubstitutefor thelicenseis thefollowing Youarefreetocopyandredistributethematerialinanymediumorformat.Youmustgive appropriatecredit.Ifyouremix transform orbuilduponthematerial youmustdistributeyourcontributions underthesamelicenseastheoriginal.Youmaynotusethematerialforcommercialpurposes 1Overview Androiddevicesdonotallowtheirownerstohavetherootprivilegeonthedevice.Thisisfornormal customers butforuserswhowanttomakedeepcustomizationsontheirdevices thisistoorestrictive.There arewaystoovercometheserestrictions mostofwhichrequiretherootprivilegeonthedevice.Theprocess ofgainingtherootdeviceonAndroiddevicesiscalled rooting .BeingabletorootAndroiddevicesisavery usefulskillforsecurityexperts Theobjectiveofthislabistwo-fold.First throughthislab studentswillgetfamiliarwiththeprocess ofdevicerootingandunderstandwhycertainstepsareneeded.ManypeoplecanrootAndroiddevices notmanypeoplefullyunderstandwhythingshavetobedoneinaparticularway.Second theentirerooting mechanisminvolvesmanypiecesofknowledgeabouttheAndroidsystemandoperatingsystemingeneral soitservesasagreatvehicleforstudentstogainsuchin-depthsystemknowledge.Inthislab wewillask studentstodevelopacompleterootingpackagefromscratch anddemonstratehowtousethepackageto roottheAndroidVMprovidedbyus 2BackgroundKnowledge 2.1BackgroundKnowledgeaboutRooting ThepurposeofrootinganAndroiddeviceistogaintherootprivilegeinsidetheAndroidOS.Therearemany reasonswhypeoplewanttodothat.Forexample Androiddevicesoftencomewithmanypre-installed systemappsthatareuselessmostofthetime buttheytakestoragespace RAM systemresources draindevicebattery.Theseuselessappsaregenerallyknownasbloatware theyareinstalledinprotected places andonlytherootuser orotherprivilegeduser canremovethem.Althoughthedeviceisownedby auser theuserisnotallowedtoruncodeusingtherootprivilege.Userscanonlygettherootprivilegeifthe deviceisrooted.Ingeneral rootingallowsuserstocustomizetheirphones removingrestrictions adding newfeatures andmakingchangestothesystem.ThereareseveralapproachestorootanAndroiddevice andwewilldiscusstheminmoredetailsinthislab.Figure1providesasummaryoftheseapproaches ModifyingAndroidfrominside TherootingapproachisdoingitfrominsideAndroid.Foranun- rooteddevice everythingthattheuserrunsisrunningwithanormaluserID notroot .Therefore rooting frominsideAndroidmeansthattheuserhastogaintherootprivilegeasanormaluser.Obviously isimpossibleforaperfectlyimplementedoperatingsystem.However thechancesarethatAndroidmay notbeperfectlyimplemented sotheremightexistvulnerabilitiesinthesystem.Ifthesevulnerabilitiesare insidethekernelordaemonsrunningwiththerootprivilege userscanexploitthesevulnerabilitiestogain therootprivilege.ThisisoneofthetechniquestorootAndroiddevices SEEDLabsŒAndroidDeviceRootingLab 2 Inthepast thereweremanyrootingexploits suchas RageAgainstTheCage whichtookadvantage RLIMIT NPROC max thevaluespecifyinghowmanyprocessesagivenUIDcanrun.Thisexploit uses '' adbshell '' torunashellonthedeviceviathe adb daemon.TheUIDoftheshellwillbe2000 Theexploitthenforksnewprocessesuntilthenumberofprocesseshavereachedthelimitandtheforkcall willfail.Atthispoint theexploitkillsthe adbd daemon andthenreconnecttoitusing '' adbshell '' Thiscausesthesystemtorestartthe adb daemon.When adb isstarted italwayshastherootprivilege butitwilldroptheprivilegetoUID2000using setuid 2000 .Unfortunately theUID2000hasalready usedupitsprocessquota sothecallwillfail.Unfortunately adb daemonfailstohandlethefailure correctly insteadofexiting itkeepsrunning whileretainingtherootprivilege.Asresults '' adb shell '' commandwillgiveusersarootshell.ThisvulnerabilityhasalreadybeenedafterAndroid2.2 Figure1 RootingAndroidDevices ModifyingAndroidfromoutside SinceAndroid'saccesscontrolpreventsanormaluserfrommodifying thepartofthesystemthatisonlybytheroot doingitinsideAndroidisgoingtosubjecttothe accesscontrol.However ifwecandoitfromoutside wearenotsubjecttoAndroid'saccesscontrolany more.Thisleadstothesecondapproach whichistodirectlymodifyAndroid'ssystemfromoutside AssumethatanotheroperatingsystemisinstalledonyourAndroiddevice.Thismeansthatthedevice SEEDLabsŒAndroidDeviceRootingLab 3 hasadual-bootallowingyoutobootintoanyofthesetwooperatingsystemswhenthedevice powerson.Ifwebootintothissecondoperatingsystem andbecometherootforthisOS wecanmount thepartitionusedbytheAndroidsystem.Oncethispartitionismounted wecanaccessallthestored insidethepartition.BecauseAndroidisnotrunning itsaccesscontrolhasnouse.Therefore wecanmake arbitrarychangestoitsForexample wecanplacesomeprogramsinthesystem andmodifyAndroid's initializationscripts andaskAndroidtorunourprogramsasarootduringitsinitializationprocess ThegoodnewsisthatmostAndroiddevicesdohavethesecondoperatingsysteminstalled anditis called recoveryOS .Asthenameindicates itismeantforrecoverypurposes butitismostlyusedforupdat- ingoperatingsystem.Thebadnewsisthatthisoperatingsystemalsohasaccesscontrols preventingusers fromrunningarbitraryprogramsorcommands.RecoveryOSistypicallyplacedondevicesbyvendors whousetheOStoupdateAndroid butnotwantinguserstomakearbitraryupdates.Toenforcethat re- coveryOSesdonotgiveusersashellprompt preventingusersfromrunningarbitrarycommands.Instead theytakeapackageprovidedfromoutside eitherfromusersordownloadedfromtheInternet thepackage containsthecommandsandneededforupdatingtheAndroidOS.Thismechanismiswidelyusedfor OSupdate anditiscalledOver-The-Air OTA update.ThepackageiscalledOTApackage whichhasa standardstructurethatwewilltalkaboutlater MostrecoveryOSesonlyacceptthepackagesmadebythevendorstoensurethatanyupdatetothe AndroidOSisapprovedbythevendors.Thisisenforcedusingdigitalsignatures i.e. thepackageneedsto besignedbyvendors oritwillnotbeacceptedbytherecoveryOS.Thisprotectionbecomesaroadblockfor rooting becausethepackagethatweuseforrootingpurposeswillnotcomefromthevendorofthedevice Weneedtowaystobypassthisaccesscontrol ReinstallrecoveryOS InsteadofbypassingtheaccesscontrolsoftherecoveryOS theeasiestwayis toreplacetheentirestockrecoveryOSwithanotherrecoveryOSthatdoesnothavesuchaccesscontrols ThisnewrecoveryOS calledcustomrecoveryOS willnotincludethesignaturevpart sowecan provideanyOTApackagestotherecoveryOS.ThiswillallowustomakearbitrarychangestotheAndroid partition Hereisanotherbadnews.Thereisanotheraccesscontrolthatpreventsusfromreplacingthestock recoveryOS andthistimeitisthebootloader.Bootloaderisalowlevelcodethatloadsanoperatingsystem orsomeothersystemsoftwareforthecomputerafterthecomputerispoweredon.Whenabootloaderis ﬁlockedﬂ itwillsimplyloadoneoftheOSesthatisalreadyinstalledonthedevice leavingnochancesfor userstomodifyanyofthepre-installedOSes.Ifabootloadercanbeunlocked itwilladdanotheroption whichallowsuserstoinstallcustomoperatingsystemsonthedevice aswellasreplacingtheexistingones TheprocessisoftenreferredtoascustomOS Manufacturersusuallymaketheirbootloaderslockedoutoftheboxbecausetheywanttobeincontrol ofwhatsoftwareisrunningthedevice.However mostmanufacturersdoprovidewaysforuserstounlock thebootloaderontheirdevices providedthatbydoingsouserswilllosealloftheirdata aswellasthe warranties 2.2BackgroundKnowledgeaboutOTA OTAisastandardtechniquefordevicestoupdateAndroidoperatingsystems.Sincerootingalsoneedsto updateAndroidOS OTAbecomesapopularchoice.Inthissection wewilldescribethestructureofthe OTApackage.StudentsneedtobuildtheirownOTApackagefromthescratchinthislab OTApackageisjustazipanditsstructureisdepictedinFigure2.Ofparticularinteresttothis labisthe META-INF folder whichincludessignatureandofthepackagealongwithtwovery importantnamed update-binary updater-script SEEDLabsŒAndroidDeviceRootingLab 4 Figure2 OTAStructure Ł META-INF/com/google/android/update-binary Thisbinaryisexecutedbytherecov- eryOStoapplyOTAupdates itloadsandexecute updater-script Ł META-INF/com/google/android/updater-script Thisisaninstallationscriptwhichis interpretedby update-binary .Itiswrittenusingascriptlanguagecalled Edify whichdescribes therequiredactiontobeperformedtoapplyupdates AftersignaturevontheOTApackage therecoveryOSextractsthe update-binary exe- cutablefromtheOTApackagetothe /tmp directoryandrunsitbypassingthreeargumentsasfollows update-binaryversionoutputpackage versionistheversionofrecoveryAPI outputisthecommandpipethatupdate-binaryusestocommunicate withrecovery packageisthepathoftheOTApackage AnExamplewouldbe update-binary3stdout/sdcard/ota.zip Onasuccessfulexecutionof updater-script therecoveryOScopiestheexecutionlogstothe /cache/recovery/ directoryandrebootsintotheAndroidOS.Executionlogscanbeaccessiblefrom theAndroidOSafterrebooting.ThisishowandroidsystemisupdatedbyusingOTApackage SEEDLabsŒAndroidDeviceRootingLab 5 3LabEnvironment Inthislab weassumethatthebootloaderonthedevicecanbeunlocked andthestockrecoveryOScan bereplaced.ReplacingtherecoveryOSintheVMenvironmentisquitedifanditisnotwithinthe scopeofthislab.TheAndroidVMthatyoudownloadfromourwebsitealreadyhasacustomrecoveryOS installed.Actually wesimplyuseUbuntu16.04astheﬁrecoveryOSﬂ.Technically thisisnotarecovery OS itisjustanotherOSinstalledonthedevice.Weusethisgeneral-purposeOStoemulatewhatusers candousingacustomrecoveryOS.OnceusersbootintothisOS theycanrunanyarbitrarycommands root andbeabletomakearbitrarychangestotheAndroidpartition StudentswhohaveaphysicalAndroiddeviceandwanttoknowhowtorootarealdevice theycan followourguidelinesinSection7.However otherthanthesteptoreplacetherecoveryOS everythingelse isthesameaswhatwedointhislab AnotherimportantthingtoknowisthatourAndroidVMisalreadyrooted.Thatwasdonewhenwe builttheVMfromtheAndroidsourcecode.OurVMbuildisactuallya userdebug build andseveraldoors werebuiltintotheVMtoallowrootaccess.Wechoosethisbuildbecauseseveralofourotherlabsrequire therootaccess.RealAndroiddevicesuse user build whichdonothavethesedoorsforrootaccess.Details aboutthesedoorscanbefoundinourVMmanual.Inthislab studentsarenotallowedtousethosedoors togaintherootaccess theyhavetousetheOTAmechanismtoachievethat 4LabTask1 BuildasimpleOTApackage Inthislab studentswillbuildasimpleOTApackagefromscratch anduseittorootAndroidOS.Wedivide thiscomplicatedtaskintoseveraltasks eachfocusingonagoal.Herearethegoalsthatwewould liketoachieve Ł HowtoinjectaprogramintotheAndroidOSfromtherecoveryOS ? Ł Howtogetourinjectedprogramtorunautomatically andwiththerootprivilege ? Ł Howtowriteaprogramthatcangiveustherootshell ? InthisTask1 wefocusonhowtoinjectaprogramintotheAndroidOSfromtherecoveryOS andthen getAndroidtorunourinjectedprogramusingtherootprivilege.Atthispoint wearenotfocusingonthe actualthingthatwecandointhisprogram aslongasitissomethingthatrequirestherootprivilege.Forthe sakeofsimplicity letussimplycreateadummyinthe /system folderofAndroid whichrequiresthe rootprivilege /system folderisnotwritablebynormalusers .Thefollowingcommandputsaword ﬁhelloﬂin /system/dummy weputthiscommandinashellscriptcalled dummy.sh echohello > /system/dummy Step1 Writetheupdatescript The update-binary intheOTApackageistheexecutablele thatwillbeexecutedbytherecoveryOS.ThisiswherewegettheOSupdatestarted.Thiscanbe abinaryexecutable orjustasimplescriptForthelattercase therecoveryOSshouldalreadyhavethe binaryexecutable e.g bash toexecutethescriptInthistask wewillsimplyuseashellscript asour recoverOS Ubuntu doeshave bash installed Ourpurposefor update-binary istwo-fold 1 injectour dummy.sh programintotheAndroid OS 2 changetheAndroidOSsoour dummy.sh canbeautomaticallyexecuted withtherootprivilegewhenAndroidbootsup.Forthetask studentsneedtooutwheretoplace SEEDLabsŒAndroidDeviceRootingLab 6 dummy.sh andhowtosetupitspermissions.Itshouldbenotedthatthehastobeplacedintothe Androidpartition whichisalreadymountedtothe /android directoryintherecoveryOS Forthesecondpurpose weneedtoget dummy.sh torunautomaticallywhenAndroidbootsup andwe needtomakesurethatitrunswiththerootprivilege.Therearemanywaystoachievethis.Inthistask useoneapproachrelatedtoLinux andinthenexttask wewilluseadifferentapproachrelatedtoAndroid framework AndroidisbuiltontopoftheLinuxoperatingsystem.Whenitbootsup itsunderlyingLinuxbootsup whichconductssysteminitialization includingstartingessentialdaemonprocesses.Thebootingpro- cedure usingtherootprivilege runsacalled /system/etc/init.sh 1 forpartoftheinitialization Therefore ifwecaninsertacommandinto init.sh wecanrunour dummy.sh withtheroot privilege Ifwecandoitmanually wecansimplyeditthe init.sh andaddanewcommandinit butweare writinganOTApackage sotheactionstomodifytheneedtobecodedinour update-binary Therearemanywaystocodethat andwewillusethe sed command whichisstreameditorfor andtransformingtext.Ourideaistowherethestatement '' return0 '' isinside init.sh andinsert acommandbeforethat essentiallyplacingthecommandbeforetheprogramin init.sh sed-i '' /return0/i/system/xbin/dummy.sh '' /android/system/etc/init.sh Explanation - '' -i '' editfilesinplace - '' /return0/ '' matchthelinethathasthecontentreturn0 - '' '' insertbeforethematchingline - '' /system/xbin/dummy.sh '' thecontenttobeinserted.Weneedtocopy thedummy.shfiletothecorrespondingfolderfirst - '' /android/system/etc/init.sh '' thetargetfilemodifiedby '' sed '' Step2 BuildtheOTAPackage ConstructinganOTApackageisquitestraightforward.Allweneedto doistoputourintheircorrespondingfoldersaccordingtoFigure2.Weneedtomaintainthesame structureaswhatisshowninthebutyoudonotneedtocreateallthethatarenotneededfor ourtask suchassignatureandoptionalYoucanputthe dummy.sh inanyplaceofyourOTA package aslongasthelocationmatcheswithyourcommandinthe update-binary .Aftercreatingthe structure wecanusethe zip commandtocreateazip zip-rmy_ota.zip./ YoushouldincludethestructureofyourOTApackageinyourreport.Youcanrunthe '' unzip -l '' commandtodothat Step3 RuntheOTAPackage AfterbuildingtheOTApackage wecanprovideittotherecoveryOS whichwillrunitautomatically.However thatishowitworkswitharealrecoveryOS.Inourlabenvi- ronment weareusing Ubuntu asourrecoveryOS butitdoesnothavetheneededrecoveryfunctionality Therefore wehavetoemulatetherecoveryfunctionality.Thismeans wehavetomanuallyunpacktheOTA package usingthe unzip command gotothefolder META-INF/com/google/android folderto update-binary andrunit.Ifyouhavewritteneverythingcorrectly yourAndroidisnow updated.Now bootupyourAndroidOS andseewhetherthedummyiscreatedinside /system .In yourreport youshouldincludescreenshotstoprovideevidences 1 ThisisforAndroid-x86build fortheARMbuild thenameisdifferent SEEDLabsŒAndroidDeviceRootingLab 7 5Task2 Injectcodevia app process Intheprevioustask wemodifythe init.sh togetourinjectedprogramtorunautomatically withtherootprivilege.ThisinitializationscriptisusedbytheunderlyingLinuxoperatingsystem.Once theLinuxpartisinitialized AndroidOSwillbootstrapitsruntimethatisbuiltontopofLinux.Wewould liketoexecuteourinjectedprogramduringthisbootstrappingprocess.Theobjectiveofthistaskisnotonly toadifferentwaytodowhatwehavedoneintheprevioustask butalsotolearnhowAndroidgets bootstrapped Beforeconductingthistask pleasereadtheguidelineinSection7.1abouttheAndroidbootingsequence Fromtheguideline wecanseethatwhentheAndroidruntimebootstraps italwaysrunaprogramcalled app process usingtherootprivilege.Thisstartsthe Zygote daemon whosemissionistolaunchappli- cations.Thismeansthat Zygote istheparentofallappprocesses.Ourgoalistomodify app process soinadditiontolaunchthe Zygote daemon italsorunssomethingofourchoice.Similartotheprevious task wewanttoputadummy dummy2 inthe /system foldertodemonstratethatwecanrunour programwiththerootprivilege Thefollowingsamplecodeisawrapperfortheoriginal app process .Wewillrenametheoriginal app process binaryto app process original andcallourwrapperprogram app process .In ourwrapper wewritesomethingtothedummyandtheninvoketheoriginal app process program # include < stdio.h > # include < stdlib.h > # include < unistd.h > externchar ** environ intmain intargc char ** argv { //Writethedummyfile FILE * f=fopen `` /system/dummy2 '' '' w '' f==NULL { printf `` PermissionDenied.\n '' exit EXIT_FAILURE } fclose f //Launchtheoriginalbinary char * cmd= '' /system/bin/app_process_original '' execve cmd argv environ //execve returnsonlyifitfails returnEXIT_FAILURE } Itshouldbenotedthatwhenlaunchingtheoriginal app process binaryusing execve weshould passalltheoriginalarguments argv array andenvironmentvariables environ toit Step1.Compilethecode Weneedtocompiletheabovecodeinour SEEDUbuntu VM notinside therecoveryOSorAndroidOS asneitherofthemhasthenativecodedevelopmentenvironmentinstalled wehaveinstalledtheNativeDevelopmentKit NDK inourSEEDUbuntuVM.NDKisasetoftoolsthat allowustocompileCandC++codeforAndroidOS.Thistypeofcode callednativecode caneitherbea SEEDLabsŒAndroidDeviceRootingLab 8 stand-alonenativeprogram orinvokedbyJavacodeinAndroidappsviaJNI JavaNativeInterface .Our wrapper app process programisastandalonenativeprogram whichneedstobecompiledusingNDK FormoredetailedinstructionsaboutNDK pleaserefertotheinstructionalmanuallinkedinthewebpage TouseNDK weneedtocreatetwo Application.mk Android.mk andplacethemin thesamefolderasyoursourcecode.Thecontentsofthesetwoaredescribedinthefollowing TheApplication.mkfile APP_ABI =x86 APP_PLATFORM =android-21 APP_STL =stlport_static APP_BUILD_SCRIPT =Android.mk TheAndroid.mkfile LOCAL_PATH = $ callmy-dir include $ CLEAR_VARS LOCAL_MODULE = < compiledbinaryname > LOCAL_SRC_FILES = < allsourcefiles > include $ BUILD_EXECUTABLE Werunthefollowingcommandsinsidethesourcefoldertocompileourcode.Ifthecompilationsuc- ceeds wecanthebinaryinthe ./libs/x86 folder exportNDK_PROJECT_PATH= ndk-buildNDK_APPLICATION_MK=./Application.mk Step2.WritetheupdatescriptandbuildOTApackage Justliketheprevioustask weneedtowrite update-binary totelltherecoveryOSwhattodo.Studentsneedtowritetheshellscriptcodeinthis task.Herearesomeguidelines Ł WeneedtocopyourcompiledbinarycodetothecorrespondinglocationinsideAndroid Ł Weneedtorenametheoriginal app process binarytosomethingelse andthenuseourcodeas app process .Theactualnameof app process canbeeither app process32 app process64 dependingonthearchitectureofthedevice.OurAndroidVMisa64-bitdevice sothenameshould app process64 StudentsshouldthenrepeatSteps2and3oftheprevioustask anddescribetheirobservationsand explanation 6Task3 Implement SimpleSU forGettingRootShell NowweknowhowtoinjectourcodeintotheAndroidsystemandgaintherootprivilege butwehave notcompletelyachievedourultimategoalyet.AnimportantreasonforuserstoroottheirAndroiddevices istoexecuteanycommandoftheirchoiceusingtherootprivilege.WhenbuildingtheOTApackage commandsarealreadydecided ifuserswanttorunothercommandsaftertheprogramsintheOTApackage isexecuted theywillnotbeabletodothat unlesstheycangetashellthatrunswiththerootprivilege.Such ashelliscalled rootshell SEEDLabsŒAndroidDeviceRootingLab 9 Wecanlaunchtherootshellusingthemethodsfromtheprevioustasks butthatisproblematic shell programsareinteractive meaningtheywillnotterminateunlessuserstypeanexitcommand thiswillstop thesystembootingprocess sotheOSwillneverbeabletocompleteitsbootingsequence.Theinterest- ingquestionishowtorunsomethingnon-interactiveduringthebootingprocessthatenablesustogetan interactiverootshelllateron IfwewereonatypicalLinuxsystem wecaneasilysolvetheaboveproblembyusingthe chmod commandtoturnontheSet-UIDbitofanyshellprogram e.g bash thatisownedbytheroot.Later whenanyuserrunsthisshellprogram theshellwillrunwiththeowner 's i.e.root privilege.Un- fortunately forsecurityreasons AndroidhasremovedtheSet-UIDmechanismfromitsunderlyingLinux OSsinceversion4.3 APILevel18 .TheofdocumentofsecurityupdatesonAndroid4.3saysthe following ﬁNosetuid/setgidprograms.AddedsupportforcapabilitiestoAndroidsystem andremovedallsetuid/setguidprograms.Thisreducesrootattacksurfaceandthelikelihoodofpotential securityvulnerabilities.ﬂ Anotherapproachistostartarootdaemonduringthebootingprocess andthenusethisdaemontohelp usersgetarootshell.ThisistheapproachusedbysomeofthepopularrootingOTApackages suchas SuperSU developedbyInthistask studentswillwritesuchadaemonanduseittounderstand howithelpsuserstogetarootshell.Themainideaofthisapproachisquitesimple.Whenuserswantto getarootshell theyrunaclientprogram whichsendsarequesttotherootdaemon.Uponreceivingthe request thedaemonstartsashellprocess andﬁgiveﬂittotheclient i.e. allowinguserstocontroltheshell process.Thetrickypartishowtolettheusercontroltheshellprocessthatiscreatedbythedaemon Foruserstocontrolthedaemon-generatedshellprocess theyneedtobeabletocontrolthestandard inputandoutputdevicesoftheshellprocess.Unfortunately whentheshellprocessiscreated itinherits itsstandardinputandoutputdevicesfromitsparentprocess whichisownedbyroot sotheyarenot controllablebytheuser'sclientprogram.Wecanawaytolettheclientprogramcontrolthesedevices orwecandoitinadifferentwaybygivingtheclientprogram'sinputandoutputdevicestotheshellprocess sotheyalsobecometheinput/outputdevicesfortheshellprocess.Thisway theuserhasacompletecontrol oftheshellprocess whatevertheusertypesintheinputdeviceoftheclientprogramwillalsobefedinto theshellprocess whatevertheshellprocessprintstoitsoutputdevicewillbeshowingtoclientprogram Writingthecodetoimplementtheaboveideaisnoteasy asweneedtohavetwoessentialpiecesof knowledge 1 howtosendthestandardinput/outputdevicesdescriptors toanotherprocess 2 onceaprocessreceivesthedescriptors howitcanusethemasitsinput/outputdevices.Weprovide somebackgroundknowledgeregardingthese 6.1Background Filedescriptors EachprocessinLinuxsystemstypicallyhasthreeassociatedI/Odevices standardinput device STDIN standardoutputdevice STDOUT andstandarderrordevice STDERR .Thesedevices arewheretheprocessgetsitsuserinputandprintsoutresultsanderrormessages.Processesaccessthese devicesthroughthestandardPOSIXapplicationprogramminginterfacethatusesdescriptors.Basically I/OdevicesaretreatedjustliketheyareThedescriptorsfor STDIN STDOUT STDERR are0 1 and2 respectively.Inthistask weneedtopassdescriptorsfromoneprocesstoanother Filedescriptorscanbepassedtoanotherprocesseitherviainheritanceorexplicitsending.Whena parentcreatesachildprocessusing fork alltheparent'sdescriptorsareautomaticallyinheritedby thechildprocess.Beyondthisstage iftheparentwantstoshareanewdescriptorwithitschildren oriftwounrelatedprocesseswanttosharethesamedescriptor theyhavetoexplicitlysendthe descriptor whichcanbeachievedusingtheUnixDomainSocket.Inourcode ourclientprogramsendsits descriptorstotherootshellprocesscreatedbythedaemon SEEDLabsŒAndroidDeviceRootingLab 10 Filedescriptorscanberedirected.Thesystemcall dup2 intdest intsrc canredirectthe src descriptortothe dest one sothedescriptorentryatindex src actuallypointstotheentryat dest .Therefore whenevertheprocessusesthe src descriptor itactuallyusestheentrystoredinthe dest entry.Forexample assumethatweopenaandgetadescriptor5.Ifwecall dup2 5,1 webasicallyletthedescriptor1pointsto5 causinganythingprintedoutby printf tobesavedto thethatwasjustopened.Thisisbecause printf bydefaultprintsouteverythingtothestandard outputdevice whichisrepresentedbythedescriptor1 Figure3 FileDescriptorTables Figure3showsthedescriptortablesoftwoprocesses.ThetableofProcess0isquitesimple.It hasthreestandardI/OFDs indices0,1,2 adescriptor index3 foranopenedandanother descriptor index4 forasocket.Table1isalittlebitmorecomplicated.Itopenedadevicenamed /dev/null andreceivedadescriptorfromTable0 andstorethedescriptoratindex4.Moreover Process1'sstandardoutputanderrorareredirectedto /dev/null whileitsstandardinputisredirectedto theone index4 receivedfromProcess0.TheconsequenceofsuchredirectionsisthatProcess1willtake exactlythesameinputasProcess0 butalloutputsareabandoned /dev/null isastandarddevicethat functionslikeablackhole nothingwrittentoitgetsout Creatingnewprocess InUnixsystems weusethe fork systemcalltocreateanewprocess.The fork callreturnsaninteger forthechildprocess thereturnvalueis0 whilefortheparentprocess returnvalueistheactualprocessid whichisnon-zero ofthenewlycreatedchildprocess.Thechildprocess inheritstheparentsdataandexecutionstatus aswellasthedescriptors.Asamplecodeisprovidedin thefollowing pid_tpid=fork pid==0 { //Thisbranchwillonlybeexecutedbythechildprocess //Childprocesscodeisplacedhere ... } else { //Thisbranchwillonlybeexecutedbytheparentprocess //Parentprocesscodeisplacedhere ... } SEEDLabsŒAndroidDeviceRootingLab 11 Figure4 Howoneprocess Client gainsthecontroloftheinput/outputdevicesofanotherprocess PassingtheFileDescriptors Figure4showshowtousethethreestandardI/Odescriptorstohelpthe clientgainthefullcontroloftherootshellcreatedbytheserver.Initially asshowninFigure4 theclient andserverarerunningindifferentprocesses whiletheclienthasanormalprivilegeandtheserverhasthe rootprivilege.EachofthemhasitsownstandardI/OFDs0,1,2.InthetheclientFDsaredenoted C IN C OUT C ERR andtheserversFDsaredenotedas S IN S OUT S ERR .InFigure4 b wedepicthowtheclientandtheserverworktogethertohelptheclientgettherootprivilege 1 TheclientconnectstotheserverusingtheUnixDomainSocket 2 Uponreceivingtherequest theserverforksachildprocessandrunsarootshell.Thechildprocess inheritsallthestandardI/OFDsfromtheparent 3 TheclientsendsitsFDs0,1 and2totheserver'schildprocessusingtheUnixDomainSocket.These FDswillbesavedinthetableindices4,5 and6 respectively 4 ThechildprocessredirectsitsFDs0,1,2totheFDsreceivedfromtheclient resultinginFDs4,5 and6beingusedtheasthestandardinput output anderrordevices.Sincethesethreedevicesare thesameasthoseintheclient essentially theclientprocessandtheserver'schildprocessnowshare thesameI/Odevices Figure4 c .Althoughtheclientprocessisstillrunningwithanormaluser privilege ithasthefullcontroloftheserver'schildprocess whichisrunningwiththerootprivilege SEEDLabsŒAndroidDeviceRootingLab 12 6.2TheTask Duetothecomplexityoftheclientandserverprogram weprovideallthesourcecodetostudentsfromour website.PleasecompilethecodeusingNDK andusethemethoddescribedintheprevioustasktobuild anOTApackage.Studentsneedtodemonstratethattheycansuccessfullygettherootshellaftertheyhave rootedtheAndroidOSusingtheirOTApackage Moreover theyneedtoshowthattheirclientprocessandtheshellprocessdosharethesamestandard input/outputdevices.InUnix-likesystems descriptorsofaprocesscanbefoundinthe /proc virtual system insidethe /proc/ < PID > /fd/ folder < PID > istheprocessid.Wecanusethe ps commandtoouttheidofaprocess Aftercompletingthetask studentsneedtolookatthesourcecode andindicatewherethefollowing actionsoccur.Filename functionname andlinenumberneedtobeprovidedintheanswer Ł Serverlaunchestheoriginal app process binary Ł ClientsendsitsFDs Ł Serverforkstoachildprocess Ł Childprocessreceivesclient'sFDs Ł ChildprocessredirectsitsstandardI/OFDs Ł Childprocesslaunchesarootshell 7Guidelines 7.1AndroidBootingSequenceand app process Figure5showsadetailedbootingprocess.Intheweassumethatthebootloaderchosestobootthe AndroidOS nottherecoveryOS PhaseI TheKernel AfterthebootloaderswitchesthecontroltoAndroidsystem Androidkernelwill beloadedandstartsinitializingthesystem.AndroidkernelisinfactaLinuxkernel whichhandlessome essentialpartsofthesystem suchasinterruptions memoryprotections schedulingetc.SomeAndroid- functionalitiesareaddedtothekernel includinglogcatloggerandwakelocks PhaseII The Init Process Afterthekernelisloaded Init iscreatedastheuser-spaceprocess Itisthestartingpointforallotherprocesses anditisrunningundertherootprivilege Init initializes thevirtualsystem detectshardware thenexecutesscript init.rc tothesystem.The script init.rc itselfmainlyfocusesonmountinginsidevirtualsystemandinitializessystem daemons.However itimportssomeother rc scriptforvariouspurposes suchassettingupenvironment variables executingarchitecturecommands andlaunching zygote .Herearetheimportedto init.rc Ł init.environ.rc Environmentvariablesaresetby init.environ.rc whichprovidessome importantpath-relatedenvironmentvariables.Thesepathsareveryimportantforlaunchingfurther processesbecausemanyofthemwilltrytoaccessthesepathsusingthecorrespondingenvironment variablenames.Inoneofthelabtasks weneedtopassenvironmentvariablestothechildprocess nowweseewhythatisneeded SEEDLabsŒAndroidDeviceRootingLab 13 Figure5 DetailedBootingProcess Ł init. $ f ro.hardware g .rc SomecommandsorcodesarearchitectureThevariable $ f ro.hardware g isinheritedfromthe Init processandpassedtothe init.rc script.Onour Android-x86VM itwillbeﬁandroid x86ﬂandthescript init.android x86.rc willbe invoked.Insidethis init.sh iscalled.This init.sh istheoneusedinInTask1 weinjecttheinvocationofourcode Ł init. $ f ro.zygote g .rc Thisstartsaveryimportantdaemoncalled Zygote .Thevariable $ f ro.zygote g isinheritedfromthe Init binary.Itcanbe zygote32 zygote64 for32-bit and64-bitarchitecture respectively itcanalsobe zygote32 64 zygote64 32 forhybrid modes mainMode secondaryMode .InourAndroid-x86VM itis init.zygote32.rc Allthese rc scriptarestoredinanimagenamed ramdisk.img onourAndroid-x86VM realdevices thesescriptareinside boot.img whichcontains ramdisk.img andthekernel.The ramdisk.img willbeextractedintothememorywhilebootingup.Makingdirectlyon animageisnotveryeasy.Thatisthemainreasonwhyweonlychangethe init.sh inour task becausethe init.sh isinsidethe /system folder notinsidethoseimage PhaseIII The Zygote Process Inthe init. $ f ro.zygote g .rc aspecialdaemonislaunched bythe Init processviathe '' servicezygote/system/bin/app process ... '' command SEEDLabsŒAndroidDeviceRootingLab 14 optionsareomitted .Thecommandstartsadaemoncalled zygote whichexecutesthe app process binary.ZygoteisthestartingpointoftheAndroidruntime.ItstartstheruntimeenvironmentofDalvikor ART whicharevirtualmachinesthatrunJavaprograms.InAndroid systemserversandmostapplications arewritteninJava Zygote isanessentialdaemon anditrunswiththerootprivilege Thatmakes app process anotherplacetoinsertourrootingcode.The app process isnota realbinaryitisasymboliclink pointingtoeither app process32 app process64 depending onthearchitectureofthesystem.Therefore wejustneedtochangethesymboliclink andletitpointto ourcode.Inourcode wewillhavetwoprocesses onerunningourrootingcode andtheotherrunningthe original app process code.ThisapproachiscommonlyusedbymanyexistingrootingOTApackages 7.2Howtounlockthebootloaderonarealdevice AswhatisshowninFigure5 whenthepowerbuttonispressed thedevicegoestoaedlocation initsROM andruninstructionsfromthere.Theseinstructionswillthengotoalocationon thediskordrivetoloadthebootloader andpassthecontroltoit.Bootloaderthenloadstheoperating system andeventuallygivesthecontroltotheloadedOS MostoftheAndroiddevicescomewithtwooperatingsystems anAndroidOSandarecoveryOS Bydefault thebootloaderwillchoosetheAndroidOStoboot however ifsomespecialkeycombination ispressedduringthebooting thebootloaderwillboottherecoverOSinstead.OnNexusdevices thisis achievedbypressingtheﬁVolumeDownﬂandﬁPowerﬂbuttonstogether Bootloaderusuallyhaveanotherfunctionalitythatisoftendisabledbydefault.Thisfunctionalityallows userstoreplace oftencalled theOSimagesonanyofthepartitions souserscaninstalladifferent recoveryOSorAndroidOS.Mostmanufacturersdonotwantuserstomakesuchkindofto theirdevices sobeforeshippingdevicestocustomers theydisablethefunctionality andhencewesaythat ﬁthebootloaderislockedﬂ.Withalockedbootloader anyattempttotheinstalledOSwillbedeniedby thebootloader.ThefollowingcommandtriestotherecoveryOSwithalockedbootloader aswecan see wegetanerrormessage # fastbootflashrecoveryCustomRecoveryOS.img sending'recovery ' 11600KB ... OKAY 0.483s writing'recovery ' ... FAILED remote notsupportedinlockeddevice finished.totaltime:0.585s Somevendorschoosetopermanentlylockthebootloader inthiscase itwillbeveryhardtothe OSesonthedevices.However manyvendorschoosenottodoso andinstead theyprovideinstructionsto unlockthebootloader souserswhoreallywanttotheirdevicescanstilldothat.Wewillshowhow tounlockthebootloader.ForthedemonstrationpurposeweareusingaNexusdevice.Tounlockit weneedtoloadbootloaderoftheNexusdevicebypassingthe '' adbrebootbootloader '' command orbyinterruptingthenormalbootprocessusingtheﬁvolumedownﬂandﬁpowerﬂbuttoncombination Figure6 showsthebootloaderscreenofaNexus5device whichindicatesthatthebootloaderislocked BootloaderofNexusdevicescanbeunlockedbyusingthe '' fastbootoemunlock '' command Beverycarefulwhileunlockingthebootloaderbecauseitwillvoidthemanufacturer'swarrantyandcom- pletelywipeoutpersonaldataonthedevice.Weadviseyoutobackupyourpersonaldatabeforeunlock- ingthebootloader.Youcanalsobackupyourinstalledappsandappdatabyusingthe '' adbbackup -apk-all-fbackup.ab '' command whichcreatesacalled backup.ab .Afterunlockingthe bootloader youcanrestorethedatabyrunning '' adbrestorebackup.ab '' .Figure6 b showsthe SEEDLabsŒAndroidDeviceRootingLab 15 Figure6 UnlockBootloader screen andFigure6 c showsthatthebootloaderisnowunlocked 7.3HowtoreplacetheexistingrecoveryOSonarealdevice Onrealdevices toremovetherestrictionsimposedbythestockrecoveryOS suchassignaturev wehavetoreplaceitwithacustomrecoveryOSthatdoesnotimposesuchrestrictions.Anumberofcustom recoveryOSesareavailableonthemarket.TWRPandClockworkModaretwoofthebestchoices.Weare goingtouseTWRPinourdescription.Tocustomrecoveryweneedtounlockthebootloaderofthe device.Weassumethatyouhavealreadyunlockedthebootloader.WecanbootthecustomRecoveryOSby usingthe '' fastbootbootCustomRecoveryOS.img '' command orwecanpermanentlyreplace thedevice'sstockrecoveryOSwithTWRP.ThefollowingcommandthecustomrecoveryOSonto therecoverypartition # fastbootflashrecoveryCustomRecoveryOS.img sending'recovery ' 11600KB ... OKAY 0.483s writing'recovery ' ... OKAY 0.948s finished.totaltime:1.435s Afterthat wecanbootintotherecoveryOSbypressingtheﬁvolumedownﬂandﬁpowerﬂbuttoncom- binationduringtheboot-upprocess.Figure7 showshowtobootintotherecoveryOS andFigure7 b showstheuserinterfaceoftheTWRPrecoveryOS.Asyoucansee ithasseveralusefulfeatures SEEDLabsŒAndroidDeviceRootingLab 16 Figure7 CustomRecoveryOS 8SubmissionandDemonstration Youneedtosubmitadetailedlabreporttodescribewhatyouhavedoneandwhatyouhaveobserved includ- ingscreenshotsandcodesnippets ifneeded .Youalsoneedtoprovideexplanationtotheobservationsthat areinterestingorsurprising.Youareencouragedtopursuefurtherinvestigation beyondwhatisrequiredby thelabdescription 