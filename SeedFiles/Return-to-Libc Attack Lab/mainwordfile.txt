SEEDLabsŒReturn-to-libcAttackLab 1 Return-to-libcAttackLab Copyright©2006-2016WenliangDu SyracuseUniversity ThedevelopmentofthisdocumentwaspartiallyfundedbytheNationalScienceFoundationunderAward No.1303306and1318814.ThisworkislicensedunderaCreativeCommonsAttribution-NonCommercial- ShareAlike4.0InternationalLicense.Ahuman-readablesummaryof andnotasubstitutefor thelicenseis thefollowing Youarefreetocopyandredistributethematerialinanymediumorformat.Youmustgive appropriatecredit.Ifyouremix transform orbuilduponthematerial youmustdistributeyourcontributions underthesamelicenseastheoriginal.Youmaynotusethematerialforcommercialpurposes 1LabOverview Thelearningobjectiveofthislabisforstudentstogaintheexperienceonaninterestingvariantof buffer-ovwattack thisattackcanbypassanexistingprotectionschemecurrentlyimplementedinmajor Linuxoperatingsystems.Acommonwaytoexploitabuffer-ovwvulnerabilityistoovwthebuffer withamaliciousshellcode andthencausethevulnerableprogramtojumptotheshellcodethatisstoredin thestack.Topreventthesetypesofattacks someoperatingsystemsallowprogramstomaketheirstacks non-executable therefore jumpingtotheshellcodewillcausetheprogramtofail Unfortunately theaboveprotectionschemeisnotfool-proof thereexistsavariantofbuffer-ovw attackcalledthe Return-to-libc attack whichdoesnotneedanexecutablestack itdoesnotevenuseshell- code.Instead itcausesthevulnerableprogramtojumptosomeexistingcode suchasthe system functioninthe libc library whichisalreadyloadedintoaprocess'smemoryspace Inthislab studentsaregivenaprogramwithabuffer-ovwvulnerability theirtaskistodevelop aReturn-to-libcattacktoexploitthevulnerabilityandtogaintherootprivilege.Inadditiontothe attacks studentswillbeguidedtowalkthroughsomeprotectionschemesthathavebeenimplementedin Ubuntutocounteragainstthebuffer-ovwattacks.Thislabcoversthefollowingtopics Ł Bufferovwvulnerabilityandattack Ł Stacklayoutinafunctioninvocation Ł Non-executablestack Ł Addressrandomization Ł The libc functions Readingsandrelatedtopics Detailedcoverageofthereturn-to-libcattackcanbefoundinChapter5of theSEEDbook ComputerSecurity AHands-onApproach byWenliangDu.Atopicrelatedtothislabis thegeneralbuffer-ovwattack whichiscoveredinaseparateSEEDlab aswellasinChapter4ofthe SEEDbook Labenvironment Thislabhasbeentestedonourpre-builtUbuntu12.04VMandUbuntu16.04VM bothofwhichcanbedownloadedfromtheSEEDwebsite 2LabTasks 2.1TurningOffCountermeasures Youcanexecutethelabtasksusingourpre-built Ubuntu virtualmachines Ubuntu andotherLinux distributionshaveimplementedseveralsecuritymechanismstomakethebuffer-ovwattackdifTo SEEDLabsŒReturn-to-libcAttackLab 2 simplifyourattacks weneedtodisablethem AddressSpaceRandomization Ubuntu andseveralotherLinux-basedsystemsusesaddressspaceran- domization ? torandomizethestartingaddressofheapandstack.Thismakesguessingtheexactaddresses difguessingaddressesisoneofthecriticalstepsofbuffer-ovwattacks.Inthislab wedisablethis featureusingthefollowingcommand $ sudosysctl-wkernel.randomize_va_space=0 TheStackGuardProtectionScheme TheGCCcompilerimplementsasecuritymechanismcalled Stack- Guard topreventbufferovws.Inthepresenceofthisprotection bufferovwattackswillnotwork Wecandisablethisprotectionduringthecompilationusingthe -fno-stack-protector option.Forexample tocompileaprogram example.c withStackGuarddisabled wecandothefollowing $ gcc-fno-stack-protectorexample.c Non-ExecutableStack Ubuntu usedtoallowexecutablestacks butthishasnowchanged thebinary imagesofprograms andsharedlibraries mustdeclarewhethertheyrequireexecutablestacksornot i.e. theyneedtomarkaintheprogramheader.Kernelordynamiclinkerusesthismarkingtodecide whethertomakethestackofthisrunningprogramexecutableornon-executable.Thismarkingisdone automaticallybytherecentversionsof gcc andbydefault stacksaresettobenon-executable.Tochange usethefollowingoptionwhencompilingprograms Forexecutablestack $ gcc-zexecstack-otesttest.c Fornon-executablestack $ gcc-znoexecstack-otesttest.c Becausetheobjectiveofthislabistoshowthatthenon-executablestackprotectiondoesnotwork shouldalwayscompileyourprogramusingthe '' -znoexecstack '' optioninthislab /bin/sh Ubuntu16.04VMonly InbothUbuntu12.04andUbuntu16.04VMs /bin/sh symboliclinkpointstothe /bin/dash shell.However dash programinthesetwoVMs haveanimportantdifference.The dash shellinUbuntu16.04hasacountermeasurethatpreventsitself frombeingexecutedina Set-UID process.Basically dash detectsthatitisexecutedina Set-UID process itimmediatelychangestheeffectiveuserIDtotheprocess'srealuserID essentiallydroppingthe privilege.The dash programinUbuntu12.04doesnothavethisbehavior Sinceourvictimprogramisa Set-UID program andourattackusesthe system functionto runacommandofourchoice.Thisfunctiondoesnotrunourcommanddirectly itactuallyinvokes /bin/sh torunourcommand.Therefore thecountermeasurein /bin/dash willimmediatelydrop Set-UID privilegebeforeexecutingourcommand makingourattackmoredifTherefore willlink /bin/sh toanothershellthatdoesnothavesuchacountermeasure.Wehaveinstalledashell programcalled zsh inourUbuntu16.04VM.Weusethefollowingcommandstolink /bin/sh zsh thereisnoneedtodotheseinUbuntu12.04 $ sudorm/bin/sh $ sudoln-s/bin/zsh/bin/sh SEEDLabsŒReturn-to-libcAttackLab 3 Itshouldbenotedthatthecountermeasureimplementedin dash canbeeasilycircumventedwitha littlebitmoreeffort.Weuse zsh justtomakethetaskrelativelyeasiertoconduct 2.2TheVulnerableProgram * retlib.c * * Thisprogramhasabufferoverflowvulnerability * * Ourtaskistoexploitthisvulnerability * # include < stdlib.h > # include < stdio.h > # include < string.h > intbof FILE * badfile { charbuffer 12 * Thefollowingstatementhasabufferoverflowproblem * fread buffer sizeof char ,40 badfile return1 } intmain intargc char ** argv { FILE * badfile badfile=fopen `` badfile '' '' r '' bof badfile printf `` ReturnedProperly\n '' fclose badfile return1 } Theaboveprogramhasabufferovwvulnerability.Itreadsaninputofsize40bytesfroma called badfile intoabufferofsize12.Sincethefunction fread doesnotcheckthebufferboundary abufferovwwilloccur.Thisprogramisaroot-owned Set-UID program soifanormalusercan exploitthisbufferovwvulnerability theusermightbeabletogetarootshell.Itshouldbenotedthat theprogramgetsitsinputfromacalled badfile whichisprovidedbyusers.Therefore wecan constructtheinawaysuchthatwhenthevulnerableprogramcopiesthecontentsintoitsbuffer rootshellcanbespawned Letuscompilethecodeandturnitintoaroot-owned Set-UID program.Donotforgettoin- cludethe -fno-stack-protector option forturningofftheStackGuardprotection andthe '' -z noexecstack '' option forturningonthenon-executablestackprotection .Itshouldalsobenotedthat changingownershipmustbedonebeforeturningonthe Set-UID bit becauseownershipchangewillcause Set-UID bittobeturnedoff $ gcc-fno-stack-protector-znoexecstack-oretlibretlib.c $ sudochownrootretlib SEEDLabsŒReturn-to-libcAttackLab 4 $ sudochmod4755retlib 2.3Task1 Findingouttheaddressesof libc functions InReturn-to-libcattacks weneedtojumptosomeexistingcodethathasalreadybeenloadedintothe memory.Wewillusethe system exit functionsinthe libc libraryinourattack soweneed toknowtheiraddresses.Therearemanywaystodothat butusingtheGNU gdb debuggerisprobablythe easiestmethod.Letuspickanarbitraryprogram a.out todebug $ gdba.out gdb bmain À gdb r Á gdb psystem Â $ 1= { < textvariable nodebuginfo > } 0xb7c56da0 < __libc_system > gdb pexit Ã $ 2= { < textvariable nodebuginfo > } 0xb7c4a9d0 < __GI_exit > Intheabove gdb commands wesetabreakpointatthe main function Line À wethenrunthe debuggedprogramusingcommand r Line Á .Theprogramwillbestoppedatthebreakpoint.Wecan nowprintouttheaddressofthe system exit functions Lines Â Ã .Fromtheoutcome wecanseethattheaddressforthe system functionis 0xb7c56da0 andtheaddressforthe exit functionis 0xb7c4a9d0 .TheactualaddressesinyourVMmightbedifferentfromthesenumbers 2.4Task2 Puttingtheshellstringinthememory Ourattackstrategyistojumptothe system functionandgetittoexecuteanarbitrarycommand.Since wewouldliketogetashellprompt wewantthe system functiontoexecutethe '' /bin/sh '' program Therefore thecommandstring '' /bin/sh '' mustbeputinthememorystandwehavetoknowits address thisaddressneedstobepassedtothe system function .Therearemanywaystoachievethese goals wechooseamethodthatuseenvironmentvariables.Studentsareencouragedtouseotherapproaches Whenweexecuteaprogramfromashellprompt theshellactuallyspawnsachildprocesstoexecute theprogram.Alltheexportedshellvariableswillbecometheenvironmentvariableofthechildprocess Thiscreatesaneasywayforustoputsomearbitrarystringinthechildprocess'smemory.Letus anewshellvariable MYSHELL andletitcontainthestring '' /bin/sh '' .Fromthefollowingcommands wecanverifythatthestringgetsintothechildprocess anditisprintedoutbythe env commandrunning insidethechildprocess $ exportMYSHELL=/bin/sh $ env|grepMYSHELL MYSHELL=/bin/sh Wewillusetheaddressofthisvariableasanargumentto system call.Thelocationofthisvariable inthememorycanbefoundouteasilyusingthefollowingprogram voidmain { char * shell=getenv `` MYSHELL '' shell printf `` % x\n '' unsignedint shell } Iftheaddressrandomizationisturnedoff youwilloutthatthesameaddressisprintedout.However whenyourunthevulnerableprogram retlib theaddressoftheenvironmentvariablemightnotbeexactly SEEDLabsŒReturn-to-libcAttackLab 5 thesameastheonethatyougetbyrunningtheaboveprogram suchanaddresscanevenchangewhenyou changethenameofyourprogram thenumberofcharactersinthenamemakesdifference .Thegood newsis theaddressoftheshellwillbequiteclosetowhatyouprintoutusingtheaboveprogram.Therefore youmightneedtotryafewtimestosucceed 2.5Task3 ExploitingtheBuffer-OvwVulnerability Wearereadytocreatethecontentof badfile .Sincethecontentinvolvessomebinarydata e.g. addressofthe libc functions wewroteaCprogramtodotheconstruction.Weprovideyouwitha skeletonofthecode withtheessentialpartsleftforyoutoout * exploit.c * # include < stdlib.h > # include < stdio.h > # include < string.h > intmain intargc char ** argv { charbuf 40 FILE * badfile badfile=fopen `` ./badfile '' '' w '' * Youneedtodecidetheaddressesand thevaluesforX Y Z.Theorderofthefollowing threestatementsdoesnotimplytheorderofX Y Z Actually weintentionallyscrambledtheorder * * long * & buf X =someaddress // '' /bin/sh '' P * long * & buf Y =someaddress //system P * long * & buf Z =someaddress //exit P fwrite buf sizeof buf ,1 badfile fclose badfile } Youneedtoouttheaddressesinlinesmarkedby P aswellastooutwheretostorethose addresses i.e. thevaluesfor X Y Z .Ifyourvaluesareincorrect yourattackmightnotwork.Inyour report youneedtodescribehowyoudecidethevaluesfor X Y Z .Eithershowusyourreasoning orif youuseatrial-and-errorapproach showyourtrials Afteryoutheaboveprogram compileandrunit thiswillgeneratethecontentsfor badfile Runthevulnerableprogram retlib .Ifyourexploitisimplementedcorrectly whenthefunction bof returns itwillreturntothe system function andexecute system `` /bin/sh '' .Ifthevulnerable programisrunningwiththerootprivilege youcangettherootshellatthispoint $ gcc-oexploitexploit.c $ ./exploit//createthebadfile $ ./retlib//launchtheattackbyrunningthevulnerableprogram # < -- -- You'vegotarootshell ! Attackvariation1 Isthe exit functionreallynecessary ? Pleasetryyourattackwithoutincluding theaddressofthisfunctionin badfile .Runyourattackagain reportandexplainyourobservations SEEDLabsŒReturn-to-libcAttackLab 6 Attackvariation2 Afteryourattackissuccessful changethenameof retlib toadifferentname makingsurethatthelengthofthenewnameisdifferent.Forexample youcanchangeitto newretlib Repeattheattack withoutchangingthecontentof badfile .Willyourattacksucceedornot ? Ifitdoes notsucceed explainwhy 2.6Task4 TurningonAddressRandomization Inthistask letusturnontheUbuntu'saddressrandomizationprotectionandseewhetherthisprotectionis effectiveagainsttheReturn-to-libcattack.First letusturnontheaddressrandomization $ sudosysctl-wkernel.randomize_va_space=2 Pleaserunthesameattackusedintheprevioustask.Canyousucceed ? Pleasedescribeyourobservation andcomeupwithyourhypothesis.Inthe exploit.c programusedinconstructing badfile weneed toprovidethreeaddressesandthevaluesfor X Y Z .Whichofthesesixvalueswillbeincorrectifthe addressrandomizationisturnedon.Pleaseprovideevidencesinyourreport Ifyouplantouse gdb toconductyourinvestigation youshouldbeawarethat gdb bydefaultdisables theaddressspacerandomizationforthedebuggedprocess regardlessofwhethertheaddressrandomiza- tionisturnedonintheunderlyingoperatingsystemornot.Insidethe gdb debugger youcanrun '' show disable-randomization '' toseewhethertherandomizationisturnedoffornot.Youcanuse '' set disable-randomizationon '' '' setdisable-randomizationoff '' tochangetheset- ting 3Guidelines Understandingthefunctioncallmechanism 3.1UnderstandingtheStackLayout ToknowhowtoconducttheReturn-to-libcattack itisessentialtounderstandhowthestackworks.Weuse asmallCprogramtounderstandtheeffectsofafunctioninvocationonthestack.Moredetailedexplanation canbefoundintheSEEDbook ComputerSecurity AHands-onApproach byWenliangDu * foobar.c * # include < stdio.h > voidfoo intx { printf `` Helloworld % d\n '' x } intmain { foo 1 return0 } Wecanuse '' gcc-Sfoobar.c '' tocompilethisprogramtotheassemblycode.Theresulting foobar.s willlooklikethefollowing ... ... 8foo 9pushl % ebp 10movl % esp % ebp SEEDLabsŒReturn-to-libcAttackLab 7 11subl $ 8 % esp 12movl8 % ebp % eax 13movl % eax,4 % esp 14movl $ .LC0 % esp string '' Helloworld % d\n '' 15callprintf 16leave 17ret ... ... 21main 22leal4 % esp % ecx 23andl $ -16 % esp 24pushl-4 % ecx 25pushl % ebp 26movl % esp % ebp 27pushl % ecx 28subl $ 4 % esp 29movl $ 1 % esp 30callfoo 31movl $ 0 % eax 32addl $ 4 % esp 33popl % ecx 34popl % ebp 35leal-4 % ecx % esp 36ret 3.2CallingandEntering foo Letusconcentrateonthestackwhilecalling foo .Wecanignorethestackbeforethat.Pleasenotethat linenumbersinsteadofinstructionaddressesareusedinthisexplanation Ł Line28-29 Thesetwostatementspushthevalue 1 i.e.theargumenttothe foo intothestack Thisoperationincrements % esp byfour.ThestackafterthesetwostatementsisdepictedinFig- ure1 Ł Line30 callfoo Thestatementpushestheaddressofthenextinstructionthatimmediately followsthe call statementintothestack i.ethereturnaddress andthenjumpstothecodeof foo .ThecurrentstackisdepictedinFigure1 b Ł Line9-10 Thelineofthefunction foo pushes % ebp intothestack tosavetheprevious framepointer.Thesecondlinelets % ebp pointtothecurrentframe.Thecurrentstackisdepictedin Figure1 c Ł Line11 subl $ 8 % esp Thestackpointeristoallocatespace 8bytes forlocal variablesandthetwoargumentspassedto printf .Sincethereisnolocalvariableinfunction foo the8bytesareforargumentsonly.SeeFigure1 3.3Leaving foo Nowthecontrolhaspassedtothefunction foo .Letusseewhathappenstothestackwhenthefunction returns SEEDLabsŒReturn-to-libcAttackLab 8 Figure1 EnteringandLeaving foo Ł Line16 leave Thisinstructionimplicitlyperformstwoinstructions itwasamacroinearlierx86 releases butwasmadeintoaninstructionlater mov % ebp % esp pop % ebp Thestatementreleasethestackspaceallocatedforthefunction thesecondstatementrecoverthe previousframepointer.ThecurrentstackisdepictedinFigure1 e Ł Line17 ret Thisinstructionsimplypopsthereturnaddressoutofthestack andthenjumptothe returnaddress.ThecurrentstackisdepictedinFigure1 f Ł Line32 addl $ 4 % esp Furtherresotrethestackbyreleasingmorememoriesallocatedfor foo .Asyoucanclearlyseethatthestackisnowinexactlythesamestateasitwasbeforeentering thefunction foo i.e. beforeline28 4Submission Youneedtosubmitadetailedlabreport withscreenshots todescribewhatyouhavedoneandwhatyou haveobserved.Youalsoneedtoprovideexplanationtotheobservationsthatareinterestingorsurprising Pleasealsolisttheimportantcodesnippetsfollowedbyexplanation.Simplyattachingcodewithoutany explanationwillnotreceivecredits 