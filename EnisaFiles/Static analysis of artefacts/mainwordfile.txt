www.enisa.europa.eu European Union Agency For Network And Information Security Advanced static analysis HANDBOOK DOCUMENT F OR TEACHERS OCTOBER 2015 Advanced artefact analysis Advanced static analysis 02 About ENISA The European Union Agency Network Information Security ENISA centre network information security expertise ENISA works groups develop advice recommendations good practice information security It assists EU member states implementing relevant EU legislation works improve expertise EU member states supporting development cross - border communities committed improving network information secu rity throughout EU More information ENISA work found www.enisa.europa.eu Authors This document created Yonas Leguesse Christos Sidiropoulos Kaarel Jõgi Lauri Palkmets n consultation ComCERT 1 Poland S - CURE 2 The Netherlands DFN - CERT Services Germany Contact For contacting authors please use cert - relations @ enisa.europa.eu For media enquir es paper please use press @ enisa.europa.eu Acknowledgements ENISA wants thank institutions persons contributed document A special goes 1 Dawid Osojca Tomasz Chlebowski 2 Don Stikvoort Michael Potter Legal notice Notice must taken publication represents views interpretations authors editors unless stated otherwise This publication construed legal action ENISA ENISA bodies unless adopte pursuant Regulation EU No 526/2013 This publication necessarily represent state - - art ENISA may update time time Third - party sources quoted appropriate ENISA responsible content exter nal sources including external websites referenced publication This publication intended information purposes It must accessible free charge Neither E NISA person acting behalf responsible use mig ht made information contained publication Copyright Notice © European Union Agency Network Information Security ENISA 201 5 Reproduction authorised provided source acknowledged Advanced artefact analysis Advanced static analysis 03 Table Contents 1 Training introduction 6 2 Introduction IDA Pro 7 Opening closing samples 7 IDA Pro interface 11 Exercise 13 Disassembly view 16 Basic navigation 20 Exer cise 24 Functions 24 Enhancing assembly code 29 Exercise 42 Exercise 43 Summary 43 3 Recognizing important functions 44 Using call graphs 44 Ex ercise 50 Using cross references 54 Exercise 63 Summary 63 4 Functions ana lysis 64 Analysis network function 64 Analysis WinMain 78 Analysis thread function 84 Exercise 94 Summary 95 5 Anti - disassembly techniques 96 Linear sweep vs. recursive disassemblers 96 Anti - disassembly techniques 98 Advanced artefact analysis Advanced static analysis 04 Analysis anti - disassembly techniques 99 5.3.1 Analysis call loc_40101A 99 5.3.2 Analysis call loc_401045 102 5.3.3 Analysis call sub_401065 105 5.3.4 Analysis call sub_4010B2 107 5.3.5 Analysis call sub_40116D 109 Exercise 112 6 Training summary 113 Appendix A Answers exercises 114 Exercise 2.3 114 Exercise 2.6 115 Exercise 2.9 115 Exercise 4.4 117 Exercise 5.4 117 Exercise 6.4 119 Advanced artefact analysis Advanced static analysis 05 Main Objective The main goal training teach participants aspects static artefact analysis During first part taught approach disassembly binary code recognize basic programming language structures navigate disassembled cod e. This part conducted non - malicious binary code safety reasons Second part exercise focuses characteristic patterns assembly code found popular artefacts The participants learn quickly recognize common patterns adds effectiveness work Eventually instructor guides class real - world samples known threats gradually increasing level complexity Targeted Audience CSIRT staff involved technical analysis incidents especially dealing sample examination malware analysis Prior knowledge assembly language operating systems internals highly recommended Total Duration 8 - 12 hours Frequency Once team member Advanced artefact analysis Advanced stati c analysis 06 1 Training introduction In training students learn fundamentals advanced static analysis During training students opportunity disassemble live malware samples help IDA Free 3 disassembler determine functionality gain additional knowledge malicious co de works During first part training students introduced IDA disassembler currently widely used disassembler They learn navigate code use different views functions well e nhance comment disassembled code Next students learn find key parts code analyse disassembled functions Finally learn basic anti - disassembly techniques After training students learned How effectively use IDA disassemble malicious code How customize IDA workspace How create call graphs use find important functions How use cross references How analyse disassembled functions How recognize anti - disassembly tec hniques Students familiar material presented first part training Introduction Advanced Artifact Analysis starting exercise contains key knowledge required whole course At point students already familiar x86 assembly language p rinciples malicious artefact analysis Students also knowledge Microsoft Windows system internals Prior completion Advanced dynamic analysis trainin g also advisable In training using real malware samples Since static analysis performed samples necessary restore clean snapshot exercise However case accidentally execute malware sample perform analyse isolated environment As matter principle execute caution dealing malware samples times ! 3 F reeware version IDA v5.0 https //www.hex - rays.com/products/ida/support/download_freeware.shtml last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 07 2 Introduction IDA Pro During first part training learn use IDA Free disassembler powerful tool allowing analyst effectively analyse disassembled code In training examine binary popular SSH client PuTTY 4 Since code malicious Opening closing samples Copy putty.exe sample Desktop start IDA Free disassembler At beginning session presented About window Just click Ok In next window asked whether disassemble new file start IDA Click Go button You also check 4 PuTTY A Free Telnet/SSH Client http //www.chiark.greenend.org.uk/~sgtatham/putty/ last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 08 You presented main IDA Free workspace window Open putty.exe file choosing File - dragging putty.exe binar onto disassembler window Now presented Load new file window In window analyst choose various options r egarding IDA open analyse selected sample Advanced artefact analysis Advanced static analysis 09 When opening window list file formats recognized IDA Here see IDA correctly recognized putty.exe Portable executable 80386 file However IDA still gives chance load putty.exe MS - DOS executable plain binary file If chosen load putty.exe Binary file IDA would load ed file contents given memory address specified Loading offset headers recognize import address table IAT check entry point address The n ext opt io n drop - list processor types Since assembly code various processors differs may choose processor type IDA Pro use disassembling binary Below various options telling IDA analyse binary In cases analysing typical Portable Executable PE binaries leave default options selected see parameters analysis IDA Free offers In exercise leave default ptions set shown screenshot press Ok button Now IDA start disassembling perform initial background analysis process It might take several seconds even minutes larger complex binaries When analysis finished see n appropriate message message log box bottom window Advanced artefact analysis Advanced static analysis 10 Now take look directory putty.exe located You notice four new files putty.id0 putty.id1 putty.nam putty.til Those database files IDA stores runtime information current analysis disassembled code comments labels etc. When finishing analysis either quitting IDA Pro selecting File - > Close IDA ask whether pack database files Pack dat abase store - recommended leave unpacked files You also choose finish analysis without saving results option Advanced artefact analysis Advanced static nalysis 11 If choose pack database single putty.idb file created instead four database files To continue analysis later open file IDA If restoring clean snapshots virtual machine remember preserve .idb files lo se results work IDA Pro interface First load putty.exe described previous step open saved session After IDA finishes analysis presented default IDA workspace consisting various windows elements At first glance IDA interface may look quite complicated become much clearer get know better Advanced artefact analysis Advanced static analysis 12 The c entral part workspace occupied Windows area 4 IDA uses multiple windows present various types information disassembled binary Among frequently used windows IDA View - A window disassembled code Hex View - A hex view disassembled binary Imports functions imported Import Address Table Functions list local functions recognized IDA disassembled code String list strings found executable To switch windows use Windows tabs 3 If accidentally close windows bring back using View - > Open sub views menu corresponding shortcut key Advanced artefact analysis Advanced static analysis 13 Right window tabs Overview navigator 2 panel This panel used present current location disassembled code/hex view within addr ess space loaded sample Switch Hex View - A window scroll observe changes current position pointed yellow arrow Note different colours used indicate different types data given address e.g dark blue means regular function 5 The last three elements IDA workspace toolbars area 1 quickly access certain IDA functions graph overview 5 quickly navigate disassembled code output window 6 present various information outputted IDA Exercise Take time switch different data views windows check type data presented Name functions imported PuTTY executable What sections present within executable ? What strings tell thi binary ? 5 Full colours legend checked Options - - > Navigation band menu Advanced artefact analysis Advanced static analysis 14 One problems default layout IDA Free rarely used functions occupy much space frequently used ones disassembly window functions window little space left We customize defaul layout use available space mor e effectively Additionally always helps perform analysis bigger screen whenever possible get rid toolbars first toolbar functions accessed menus shortcuts Right click toolbars 1 uncheck unnecessary toolbars context menu It toolbars want use You even decide remove toolbars In examp le display following toolbars Main Files Navigation - > Jumps Navigation - > Navigation Navigation - > Graph overview Disassembly - > Cross references Graphs It also worth resizing output window 6 rarely used analysis Advanced artefact analysis Advanced static analysis 15 Next rearrange windows toolbars give IDA cleaner look Since functions window disassembly window frequently used good top Moreover also good maximize IDA already When satisfied layout save using Windows - > Save desktop option Advanced artefact analysis Advanced stat ic analysis 16 Now whenever start new analysis layout gets messed quickly restore using Windows - > Load desktop option Disassembly view Central IDA Pro assembly view IDA View - A In assembly view IDA pres ents disassembled code along recognized functions There two types assembly view text view graph view To switch text graph view click assembly view IDA View - A press spacebar In text view see linear listing disassembled instructions T ext view useful want analyse parts code IDA ha proper function Notice dashed solid lines left side text view They used indicate conditional unconditional jumps respectively If click jump destination IDA highlight destination label well corresponding arrow Th e second type assembly view graph view In graph view name suggests IDA presents disassembled code form graph nodes represented blocks disassembled code lines branches unconditional jumps For eac h recognized function IDA creates separate graph graph represents single function Graph view useful quickly figure execution flow function Advanced artefact analysis Advanced static analysis 17 Different colours lines used indicate different types f code transitions Green preceding jump taken Red jump taken Blue normal branches unconditional jump transition next instruction You also hover cursor branches IDA show small hint window code snippet branch leading This useful branch leads location outside current screen Sometimes want get higher level grasp code flow function In suc h situation useful zoom graph view Ctrl + Scroll button Advanced artefact analysis Advanced static analysis 18 Another useful feature IDA highlighting capability You click almost name register operation variable comment etc IDA highlight every occurrence name For e xample highlight push/pop operations track registry changes highlight particular registry track instruction changing Advanced artefact analysis Advanced static analysis 19 By default viewing code graph view instruction addresses staying graph view choose Options - > General Line prefixes option Now viewing code graph view also see instruction addresses For convenience use rest document could always easily navigate part code pointed screenshot Advanced artefact analysis Advanced static analysis 20 At end e part code proper function graph view unavailable You recognize situation instruction addres ses text view red impossible switch graph view You see deal situation later Ba sic navigation When reverse engineering disassembled binary spend time trying figure code parts important function Thus crucial learn navigate code effectively quickly One easiest ways navigate code use functions window Just find interesting function name double click move function instantaneously For example go sub_4457D6 function Moreover th e functions list long click functions window start typing function name At bottom window observe characters typed function given name exist selected automatically Advanced artefact analysis Advanced static analysis 21 As may noticed functions functions list named differently sub_XXXXXX Examples functions _fwrite _strcat _sscanf etc With exceptions library functions statically linked binary compilation If resize functions window functions marked capital L sixth column 6 Moreover take look overview navigator bar library functions marked cyan colour Statically linked functions pr e tty much indistinguishable normal code To distinguish IDA uses special FLIRT engine 7 uses signatures functions popular well - known libraries More advanced users try extend FLIRT signatures howeve r topic covered training 6 To check meaning ther columns refer https //www.hex - rays.com/products/ida/support/idadoc/586.shtml last accessed 11.09.2015 7 IDA F.L.I.R.T Technology In - Depth https //www.hex - rays.com/products/ida/tech/flirt/in_depth.shtml last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 22 G back WinMain function look group four calls beginning routine There four types calls see frequently disassembled code Calls local routines e.g call sub_XXXXXX Calls address stored memory e.g call dword_XXXXXX Calls location pointed register local variable e.g call eax Calls WinAPI library functions e.g call ds CreateProcessA T troublesome usually calls addresses stored memory calls location pointed register This determining destination address call usually require detailed code inspecti good code understanding I n example see three calls local functions sub_44B2C5 sub_441535 sub_44AE44 one call WinAPI function InitCommonControls To quickly navigate sub_44B2C5 double click name In similar way also click data sets move location data memory For example double click aWs2_32_dll name given IDA string defined memory section .rdata address 0x473EF0 Advanced artefact analysis Advanced static analysis 23 Now go back WinMain quickly press < Esc > key twice It move back WinMain routine Respectively move forward press < Ctrl > + < Enter > back sub_44B2C5 Y ou also use Jumps toolbar When dealing large complicated functions useful use small Graph overview window navigate within code function The Graph overview window present whenever disassembly view active current mode graph view If accidentally close Graph overview window open using V iew - > Toolbars - > Navigation - > Graph overview If function graph big fit current disassembly view size current position marked small dotted rectangle within Graph overview window This rectangle change size whenever zoom function graph You move rectangle click part Graph overview move chosen part function Now try inspect function sub_44F102 using Graph overview window Advanced artefact analysis Advanced static analysis 24 Often know particular memory address belongs In situation use Jump address feature Jump - press < g > In dialog enter hexadecimal address within memory range analysed binary e.g 0x440C74 name recognized IDA like function name certain label e.g sub_40E589 loc_40E5CA Exercise Take time navigate various functions disassembled PuTTY binary Find function sub_4497AE What API calls made within function ? Go address 0x406AFB To function address belong ? Go address 0x430EAB Is nything special instructions stored address ? Functions When loading new binary sample IDA performs extensive auto analysis During process IDA tries find functions defined assembly code well determine arguments variables calling convention Each detected function whether normal function library function listed functions window The WinMain function provides g ood exam Advanced artefact analysis Advanced static analysis 25 Each function begins w ith function prototype header 1 In example IDA recognized function prototype function calling convention stdcall arguments types HINSTANCE HINSTANCE LPSTR int However Consequently obtain additional information calling convention arguments return value analysis edit function prototype clicking function name choosing Edit - > Functions - menu This provide IDA additional information function help analyse rest code Below function header list local variables 2 function arguments 3 IDA tracks variables used code tries suggest names For example variable used store result call GlobalAlloc 8 ID A might name hMem If IDA unsuccessful naming variables give ordinary names arg_0 arg_4 etc arguments var_4 var_8 etc local variables Notice offsets right variable names 5 Th e sets tell position variable stack reference stack frame function This also distinguish local variables function arguments Local variables always negative offsets function arguments positive offset arg_8 ebp+10 arg_4 ebp+C arg_0 ebp+8 ret addr ebp+4 ebp ebp var_4 ebp - 4 var_8 ebp - 8 var_C ebp - C Additionally double click variable names IDA open stack frame window current function Using stack window get better understanding variables arguments positioned stack At point also remember IDA sees group separate variables might well structure array 8 Allocates specific number bytes process heap returns handle al located memory object Advanced artefact analysis Advan ced static analysis 26 Another important thing know IDA references variables function body This differs dependin g whether function uses EBP - based stack frame ESP - based stack frame 9 In functions EBP - based stack frames var iables referenced relative EBP register WinMain sub_42FCAD e xample functions You recognize EBP - based functions typical function prologue first instruction EBP register pushed onto stack push ebp The econd type f unctions ESP - based stack frame In functions preserved var iables referenced relative ESP register Example function sub_40486C 9 All About EBP http //practicalmalwareanalysis.com/2012/04/03/all - - ebp/ last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 27 In situations require correcting code first either manually custom script sometimes enough tell IDA create function given address Example functi IDA properly recognize code address 0x430E38 Fortunately - disassembly techniques To create function click first instruction push ebp choose Edit - > Func tions - > Create function Advanced artefact analysis Advanced static analysis 28 IDA recognize part code proper function able switch graph view Unfortunately especially malware using anti - disassembly techniques In case may analysis using text view mode try correct code manually Additionally believe function wrongly recognized click function name code choose Edit - > Functions - > Edit function function end address To get information parameters refer IDA help file Moreover reaso n would like delete function click name code choose Edit - > Functions - > Delete function Advanced artefact analysis Advanced static analysis 29 Enhancing assembly code When analysing disassembled code important document findings properly This graduall make code easier understand track execution flow It also helpful decide return analysis later share results someone else Fortunately IDA offers lot means document code improve readab ility - Editing numbers format using symbolic constants - Renaming functions variables names - Adding comments - Changing graph node colour - Grouping one several nodes To show use th e features improve assembly readability go function sub_44D262 0x44D262 This function takes one unknown argument arg_0 uses variables two IDA named FileName FindFileData In function body see API calls functions GetWindowsDirect oryA FindFirstFileA FindNextFileA GetProcAddress etc Advanced artefact analysis Advanced static analysis 30 There also unknown calls address stored registers And calls functions pointed global variable Such calls make analysis difficult calls leading To start improving code readability first look graph nodes calls GetProcAddr In total three calls sub_44D262 You read n ame function resolved value pushed onto stack CryptAcquireContextA After call GetProcAddress result saved memory location pointed dword_47E0C8 You rename memory location clicking dword_47E0C8 pressing < n > key Rename CryptAcquireContextA Advanced artefact analysis A dvanced static analysis 31 After pressing Ok informed name exceeds 15 characters Ignore warning click Yes Now code look like Repeat step remaining two calls GetProcAddress sub_44D262 CryptGenRandom CryptReleaseContext Make sure rename memory locations exactly names resolved functions Next scroll location calls functions pointed memory address call dword_XXXXXX previously Notice changed ? Advanced artefact analysis Advanced static analysis 32 Now IDA knows little functions called locations let reanalyse code To go IDA Options dialog menu Options - > General Analysis tab click Reanalyze program Wait IDA finish analysis close IDA Options dialog Notice IDA added additional comme nts renamed variables ! Advanced artefact analysis Advanced static analysis 33 Now scroll location 0x44D391 call eax ere call made b ut highlight eax register take look blocks notice eax assigned pointer CryptAcquireContextA It good comment finding To add comment click call eax pres < > colon Advanced artefact analysis Advanced static analysis 34 Comment remaining arguments CryptAcquireContextA accordingly function prototype 10 make look like follow ing Now know 0F0000000h 1 constants passed CryptAcquireContextA arguments dwFlags dwP rovType You check function reference 11 dwFlags takes constant CRYPT_ prefix dwProvType takes constant PROV_ prefix You tell IDA represent values symbolic constant To use symbolic constant repr esentation right - click 0F0000000h choose In next window IDA display known standard symbolic constants whose value equals 0F0000000h Choose constant CRYPT_ prefix CRYPT_VERIFYCONTEXT 10 CryptAcquireContext function https //msdn.microsoft.com/en - us/library/windows/desktop/aa379886 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 11 CryptAcquireContext function https //msdn.microsoft.com/en - us/library/windows/desktop/aa379886 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 35 Repeat steps dwProvType time choosing PROV_RSA_FULL Now code look like Now scroll address 0x44D367 Here see group nodes making jump location loc_44D3BE Advanced artefact analysis Advanced static analysis 36 Further inspection shows loc_44D3BE location function epilogue probably jumped something earlier fails Rename location func_exit way renaming memory location Now jumps look much clearly Y ou rename almost name used IDA function names arguments variables etc way Advanced artefact analysis Advanced static analysis 37 To simplify function structure group graph nodes used resolve crypto functions addresses To go graph node th e address 0x44D2F7 select graph nodes clicking holding < Ctrl > key Select graph nodes starting 0x44D2F7 0x44D367 Now right - click selected nodes choose Group nodes In next window write short description grouped nodes used Advanced artefact analysis Advanced static analysis 38 After clicking Ok previously selected nodes replaced single node To edit node group text temporarily un - collapse group use pair new buttons node group header Now go location loc_44D2B1 0x44D2B1 Advanced artefact analysis Advanced static analysis 39 Take look call ebx instruction If select call ebx notice similar calls made two locations function In case two arguments pushed onto stack fi rst address second one seems size buffer pointed first argument good comment ! Now select ebx register notice value assigned beginning function This means arg_0 function pointer function pointed argument called three times function rename arg_0 func_ptr Since seems significant element good mark three graph nodes call takes place To mark graph node use node colouring feature Go back loc_44D2B1 click icon colour palette left upper corner Advanced artefact analysis Advanced static analysis 40 After clicking Ok node background become cyan Advanced artefact analysis Advanced static analysis 41 Repeat step two remaining graph nodes call ebx takes place Node colouring useful feature used mark graph nodes already analysed reason significant One thing IDA improve code readability change IDA presents numerical values By default numerical value presented hexadecimal Sometimes would like view decimal binary even custom defined const ant To change value format right - click choose suitable format Additionally rare situations might also helpful change name registers For example given function register frequently use one purpose e.g storing pointer constant value might good change name This change would apply current function An e xample register sub_44D262 edi The r egister first zeroed xor edi edi used rest function compare values zero push zero onto stack Advanced artefact analysis Advanced static analysis 42 To rename register click register press < N > rename Now code look like Exercise Find variable var_8 used rename Try rename remaining locations loc_44D2B1 loc_44D2DA loc_44D36B loc_44D3B4 What names would suggest ? Advanced artefact analysis Advanced static analysis 43 Group three graph nodes checking functions CryptAcquireContextA CryptGenRandom CryptReleaseContext resolved correctly 0x44D36B 0x44D374 0x44D37C Has code readability function improved ? Can guess function sub_44D262 might used ? Exercise Take time get familiar IDA Pro disassembled code Make sure know perform presented use functions covered section If something goes wrong always reload sample Summary In exercise learned use IDA nalyse disassembled code First learnt customize IDA workspace navigate code Basic function structure function types also introduced Finally saw enhance disassembled code adding comments changing names using colouring functions improve code readability Advanced artefact analysis Advanced static analysis 44 3 Recognizing important functions A problem analysing complex malware samples disassembled code often q uite overwhelming consists many functions Usually functions important S ome perform trivial tasks want focus one particular malware functionality In exercise learn find functions might important nd ones try analyse first Always begin think ing goal analysis Do want learn general malware functionality want obtain information one particular function ? Depending answer ou narrow search When starting analysis new binary one approach analyse main routine try following execution flow As long analysis might give us valuable information sample worth trying also quite tedious task especially functions looking directly called main routine Fortunately three basic techniques help us find interesting functions Using call graphs b Following cross references strings imported functions c Learning functions addresses dynamic analysis The f irst two techniques presented following exercises In last technique need apply techniques learnt second part training Advanced dynamic analysis pinpoint code interesting malware function located example check address code responsible communication wit h C & C server start analysis code IDA This technique covered exercise In exercise use sample Slave trojan 12 banking trojan first detected S21sec company 13 Before continuing please load slave.exe sample IDA wait initial auto analysis completes Because analysing live malwa sample remember take necessary precautions Using call graphs Starting analysis new binary first questions come mind execution flow code ? What local functions called functions ? Are API calls ? What data variables referenced code ? To answer questions IDA provides us graphing capability Call graphs graphical representation recognized function calls code They use external application wingraph32 present function calls form directed graph nodes represent functions data locations lines calls references data 12 Sample 400fbcaaac9b50becbe91ea891c25d71 MD5 https //malwr.com/analysis/OTRiMDk1ODFkOGVjNDhkMzljYzdiZTUzZDUyYjEwM2M/ last accessed 11.09.2015 13 New banking trojan 'Slave ' hitting Polish Banks http //securityblog.s21sec.com/2015/03/new - banker - slave - hitting - polish - banks.html last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 45 To access call graph functionality use menu View - > Graphs use Graphs toolbar There four basic call graph types Function calls Xrefs Xrefs Note creating Xrefs Xrefs possible disassembly view currently selected item function name named data location dword_XXXXXX Start clicking wWinMain function slave.exe sample choose create Xrefs call graph Note need click actual function picture function name function prototype Now see WinGraph32 window newly created call graph wWinMain function This Xrefs graph presents functions called wWinMain routine local functions library functions well API functions Advanced artefact analysis Advanced static analysis 46 Depending code complexity size screen graph might less readable For complex malware malware using many linked libraries graph might barely readable To navigate graph use left - mouse button To zoom zoom use toolbar buttons shown screen Now zoom zoom 100 % notice different colours graph nodes Black nodes represent local functions pink nodes represent API calls There might also cyan nodes white nodes representing functions recognized IDA library functions named data locations respectively S far analysing functions wWinMain called What want check functions call wWinMain ? You use Xrefs call graph Click wWinMain choose Xrefs graph Advanced artefact analysis Advanced static analysis 47 Without much surprise see wWinMain called ___tmainCRTStartup routine To get little complex example create Xrefs graph sub_404330 Advanced artefact analysis Advanced static analysis 48 Xrefs graphs might also used check functions referencing particular memory location As exa mple go wWinMain function click dword_438120 choose create Xrefs graph You see functions referencing memory location This may prove useful know memory location stored important varia ble e.g flag telling whether virtual machine detected want see functions checking variable Th e th ird type graphs user defined graphs In contrast Xrefs Xrefs graphs creating user defined gra ph specify additional parameters graph look To create graph wWinMain select wWinMain choose Advanced artefact analysis Advanced static analysis 49 In new window specify additional graph parameters You hover cursor parameter get hint parameter changes The ost frequently used group parameters Starting direction Recursion depth Using Recursion depth limit number graph nodes followed current location This might useful dealing complex code As example create graph wWinMain presenting references function limiting graph recursion depth 2 Advanced artefact analysis Advanced static analysis 50 Is newly created graph clearer easier follow ? Exercis e Take minutes experiment options user defined graphs Create graphs functions wWinMain The last graph type Function calls presents graph function calls recognized functions This usually wou ld quite complex graph use detect functions code called main routine This might caused various circumstances external functions exported Export Table functions called indirectly IDA failed recognize functions injected process Advanced artefact analysis Advanced static analysis 51 Now know create various call graphs used recognize important function calls ? A good starting point create Xrefs graph wWinMain function function recognized IDA main function Depending code complexity might decide limit recursion depth Zoom graph start looking two types functions Functions calling groups similar APIs Based API calls made often deduce purpose function example function calling registry - related APIs might installation routine func tio n calling network - related API might used communicate C & C server b Functions call many local functions This might indicate important program logic takes place inside function I may always true usually worth time inspect functions You may also note functions called many often unrelated functions Such functions usually complete trivial task analysing first might help understand rest code As example analyse call graph wWinMain function 14 First notice top group three functions 1 sub_406410 sub_406120 sub_401B90 At point already suspect important functions calle directly wWinMain calling lot APIs Unfortunately due structure graph hard tell API called function To deal problem create call graph wWinMain recursion depth equal 2 14 This graph might slightly different using IDA rsion general struct ure similar Advanced artefact analysis Advanced static analysis 52 Then take look sub_401B90 We see function iterating process list calls Process32FirstW Process32NextW etc. This might mean function looking specific process inject code using anti - analysis techniques e.g trying detect AV processes Next look sub_406410 It calls APIs us RegSetValueExW CreateDirectoryW CreateFileW MoveFileExW It likely indicates installation procedure You inspect want know malware installs system Then take look sub_406120 It enumerates registry RegEnumValueW checks module path GetModuleFileNameW It hard tell purpose likely still worth inspecting Now go back general graph wWinMain take look function sub_402050 2 Among APIs also calling CreateRemoteThread WriteProcessMemory This tells us function likely injecting code processes also notice sub_402050 first called already checked sub_401B90 iterating process list Next take look function sub_405760 3 calling many functions This might suggest important program logic taking place inside function Advanced artefact analysis Advanced static analysis 53 If look closer rest graph notice several potentially interesting functions like sub_4027E0 performing file system operations Dele teFileW WriteFile SetFileAttributesW CreateFileW sub_406CA0 threads operations The n ext thing might consider would create separate call graphs functions previously noticed sub_405760 However point seems important functions analysed first wWinMain main routine sub_401B90 iterating process list sub_406410 installation routine sub_406120 possible registry enumeration sub_402050 process injection routine sub_405760 calling many subroutines One thing might would create call graph functions Function calls graph previously described check function called directly wWinMain I f might repeat steps described function called directly wWinMain Advanced artefact analysis Advanced static analysis 54 Using cross references One useful features IDA cross references short xrefs During initial autoanalysis named object whether function string variable memory location IDA tracks locations object referenced Where object reference assembly instruction referencing objec reading value references learn addresses given function called string used ce rtain varia ble written The c graphs used previous exercise constructed IDA based cross references To use cross refe rences go place given object defined referenced click object name press < X > sele ct View - > Open subviews - > Cross references As example go wWinMain function To check global variable dword_438120 used double click go memory location data variable defined Notice right IDA already tells two cross references variable However get better view list cross references best select variable press < Ctrl+X > open Cross references dialog Advanced artefact analysis Advanced static analysis 55 By default Cross references list consi st four columns The f irst column Direction tells whether cross reference object occurred object regard memory address The econd column Type tells cross reference type r read operation w wri te operation e.g pushing onto stack T hird column Address gives exact address cross reference occurred Notice addresses presented < func_name > + < offset > first par function name cross reference occurs second part offset location within function Finally last column Text assembly operation referencing object You also immediately jump cr oss reference double clicking For example jump cross reference address sub_402540+C5 want go back simply press < Esc > At address see data address moved onto stack assigned local variable var_4 Now use cross references find important functions You first following cross references imported functions secondly following cross references strings found IDA By following cross references API functions basically analysing call graphs previous exercise However since call graphs always easy read method also makes sure ssed anything Moreover interested specific APIs easier find directly following cross references look call graph First switch imports view If window already open choosing View - > Open subviews - > Imports To make searching easier sort imported functions name clicking Name column Advanced artefact analysis Advanced static analysis 56 want find function injecting code processes To first find WriteProcessMemory function imports list double click Next click function name open Xrefs dialog Advanced artefact analysis Advanced static analysis 57 T one function calling WriteProcessMemory twice sub_402050 Note function already found call graphs analysis When looking imports list one thing stands complete lack network related fun ctions It rather uncommon malware communicate servers This suggests functions might loaded dynamically GetProcAddress function As suspected quite lot calls GetProcAddress In total 10 different functions calling GetProcAddress sub_401B30 1 call sub_401B50 1 call Advanced artefact analysis Advanced static analysis 58 sub_401E70 2 calls sub_402860 15 calls sub_403120 1 call sub_4041E0 1 call sub_404330 2 calls sub_404600 5 calls sub_405390 10 calls sub_405760 17 calls Now go cross reference sub_402860 go function take look calls GetProcAddress Six network - related functions dynamically loaded runtime addresses saved memory InternetOpenA - > dword_438104 InternetConnectA - > dword_43810C HttpOpenRequest A - > dword_438114 HttpSendRequestA - > dword_438108 InternetReadFile - > dword_438118 InternetCloseHandle - > dword_438110 Now follow cross references dword_438108 check HttpSendRequestA function called Advanced artefact analysis Advanced static analysis 59 You see one call HttpSendRequestA sub_402300 Follow cross reference land function evidently used communicate C & C server This function missed us function meaningful API calls network funct ions loaded dynamically runtime At point depending want find could continue analysis cross references functions imports list A econd way finding important functions using cross references follow c ross references strings found IDA You follow cross references strings similar manner following cross references imported functions First open strings list look strings stand check str ings referenced code First switch strings view If strings view open choose View - > Open subviews - > Strings Advanced artefact analysis Advanced static analysis 60 In strings window see interesting strings T domain name www.bizzanalytics.com Double click string follow cross references You see two cross references first one leads sub_402300 function already found communicate C & C server second one string offset written memory At point hard tell used Advanced artefact analysis Advanced static analysis 61 Now go back strings window notice strings named PR_Write PR_Read PR_Close names functions NSPR libr ary used network communication 15 This library used example Mozilla Firefox web browser This typical f modern malware performing - called MitB Main - - - browser attacks hooking network - related functions web browser injec ting malicious code content websites usually financial stealing user credentials 16 17 18 15 Netscape Portable Runtime NSPR https //developer.mozilla.org/en - US/docs/Mozilla/Projects/NSPR last accessed 11.09.2015 16 Advanced Techniques Modern Banking Trojans https //www.botconf.eu/wp - content/uploads/2013/12/02 - BankingTrojans - ThomasSiebert.pdf last accessed 11.09.2015 17 Analyzing Man - - - Browser MITB Attacks http //www.sans.org/reading - room/whitepapers/forensics/analyzin g - man - - - browser - mitb - attacks - 35687 last accessed 11.09.2015 18 Firefox FormGrabber https //redkiing.wordpress.com/2012/04/30/firefox - formgrabber - iii - cod e - injection/ last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 62 All three strings referenced two different functions sub_405390 sub_40 5760 If jump either two functions examine see references strings like network functions used Internet Explorer web browser This confirms suspicion malware likely performing MitB attack It noted complete analysis cross references strings imported function s. However point already idea use cross references find important interesting functions Using cross references strings imported functions confirmed finding previous exercise found three suspicious functions sub_402300 function likely used communication C & C server sub_405390 sub_405760 functions probably used set hooks web browser Advanced artefact analysis Advanced static analysis 63 Exercise Save results current work open new sample dexter .exe sample Dexter malware targeting POS systems 19 Using techniques presented exercise try pinpoint important functions disassembled code Find network related functions Find installation routine Find function performing RAM scraping reading memory processes Find process injection routine Are potentially interesting suspicious functions ? This exercise might conducted small groups After assigned time passes g roup present findings Are findings group similar ? Summary In exercise learnt recognize important functions disassembled code To first used call graphs track execution flow followed cross references strings impor ted functions This way able find group suspicious functions installation routine process injection routine function likely used communication C & C server All funct ions w ere found also good starting point analysis However remember approach presented exercise might always work could quite difficult apply The f irst problem samples obfuscate execution flow load API functions dynamically Y ou see examples code later exercises The econd problem might samples use many statically linked libraries recognized IDA In case might difficulties recognizing parts code part main malware code parts library functions Finally looking important functions good practice rename suspicious function find This way easier follow functions already visited ones f rename functions add comments code remember save results work 19 POS malware - look Dexter Decebal http //h30499.www3.hp.com/t5/HP - Security - Resea rch - Blog/POS - malware - - look - - Dexter - - Decebal/ba - p/6654398 last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 64 4 Functions analysis In previous exercise found group suspicious functions The n ext step analyse functions order better understand functionality used In exercise learn basic principles function analysis start analys look understand function role In general analysing function want answer three questions 1 What function arguments ? 2 Is function returning anything ? 3 What role function ? To p erfor operation arguments ? To p erform memory operations ? Execute tasks ? Full function analysis strongly depends function complexity There simple functions performing single tasks usually fairly easy analyse There also complex functions performing lot operations using many variables complex data structures analysis usually quite demanding takes long time Moreover function calling local functions would often need analyse first order understand role context function Fortunately full function analysis usually necessary In many cases quick assessment function without fully understanding details op eration enough When starting analysis function might helpful answer following questions necessarily order Are API calls function ? If yes used ? Are calls local functions ? What ? Are xrefs analysed function ? From functions function called ? Are arguments pushed onto stack function called ? Is type known e.g handle buffer address decimal value etc. ? What function calling convention ? How many arguments function using ? How used code ? Are local stack variables used ? How used code ? Are global variables used function ? How used code ? Is function ending endless loop ? Is returning value ? Are loops switch statements function ? Is one execution path ? Are strings referenced functio n ? You proceed analyse chosen functions Slave Trojan When analysing function remember always document finding presented Enhancing assembly code exercise Analysis network function You start analysis subroutine suspect communicat es C & C server First go sub_402300 0x402300 Only blocks code one loop Advanced artefact analysis Advanced static analysis 65 For convenience sub_402300 f_CnC_func If later decide inappropriate rename something else To check functions called within f_CnC_func need first deal calls global variables Advanced artefact analysis Advanced static analysis 66 Fortun ately already know variables set please refer previous exercise Using cross references go place value dword_438104 set jump G 0x402939 Rename global variables used store addresses network related functions make sure chang e order make typo Advanced artefact analysis Advanced static analysis 67 Now go back f_CnC_func reanalyse code Options - > General - > Analysis - > Reanalyse program IDA add additiona l comments 20 Now check functions called within f_CnC_func A convenient way use Function calls sub view also present f_CnC_func called While staying f_CnC_func choose View - > Open subviews - > Function calls 20 If point notice disassembly lacking comments except ones added manually comparison screenshots document ca n try repeating step Also make sure properly renamed global variables containing pointers API functions Advanced artefact analysis Advanced static analysis 68 In upper part window list locations f_CnC_func called In lower part window list calls made within f_CnC_func You double click calls moved calling instruction Short analysis list tells us three important things Firstly API calls except calls network related functions memory allocation functions C standard library Secondly calls local functions Thirdly f_CnC_func called sub_402540 function Knowing plus fact f_CnC_func rather simple short function assume f_CnC_func likely used communicate C & C server analysis received data Consequently interested What f_CnC_func arguments ? Is f_CnC_func returning anything ? Is data sent C & C server ? How ? Is data received C & C serve r ? What happening data ? analysing function arguments Advanced artefact analysis Advanced static analysis 69 IDA recognized function function bp - based stack frame There stack variables used arguments Are ? Just sure go place f_CnC_func called following address 0x40256C got function calls window You beginning sub_402540 It seems push instructions call f_CnC_func However notice ecx register assigned address var_8 variable later also initialized zero Notice also eax register tested call f_CnC_fu nc equals zero sub_402540 returns This suggests f_CnC_func returning value eax register nonzero success Now go back f_CnC_func check ecx register used anything Advanced artefact analysis Advanced static analy sis 70 Yes right Value ecx assigned edi register This means f_CnC_func either using fastcall calling convention might dealing object - oriented programming ecx used pass pointer member function thiscall calling convention If analyse functions code notice arguments functions passed ecx edx registers This means likely fastcall function ecx used pass pointer variable dat structure Notice later edi register assigned var_C Rename var_C Now go last block f_CnC_func loc_40246A Notice eax register assigned value var_14 variable This means var_14 variable used store return value Rename var_14 retval For convenience also good rename label loc_40246A something like func_exit Advanced artefact analysis Advanced static analysis 71 At point know f_CnC_func taking single argument passed ecx returning value eax register Now analyse communication C & C server taking place happens received data Go beginning function Notice initial return value retval set zero Then call InternetOpenA parameters set zero According MSDN documentation 21 function initializes use WinINet functions return hInternet handle You see handle assigned var_10 zero jump func_exit For clarity rename var_10 hInternet If InternetOpenA succeeds next step malware calls InternetConnectA initiate connection destination server 21 InternetOpen function https //m sdn.microsoft.com/en - us/library/windows/desktop/aa385096 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 72 made hardcoded hostname www.bizzanalytics.com standard HTTP port 80/tcp 50h Result call InternetConnectA connection handle saved var_18 For clarity rename variables add symbolic constants For 0x40233D right clic k select symbolic constant - > use standard symbolic constant list select For 0x402343 switch decimal clicking use shortcut key Shift+H Also rename var_18 hConnect In next step malware opening HTTP request using HttpOpenRequestA Here see HTTP request GET made similarly hardcoded info.php hardcoded key GET variable To get full key value hover mouse cursor szObjectName doub le click Advanced artefact analysis Advanced static analysis 73 You also see flags dwFlags passed HttpOpenRequestA Unfortunately IDA fails variable sum one flag symbolic constants Finally new request handle temporarily saved ebx register Next malware sending n HTTP request Nothing special happening There extra headers POST data lpOptional Notice request handle hRequest saved global variable dword_438124 Rename CnC _hRequest check xrefs Advanced artefact analysis Advanced static analysis 74 Notice references variable outside f_CnC_func Renaming variable might help us later analysis eax nonzero fail malware starts reading data received server InternetReadFile You analyse happens received data saved Now take look next three code blocks 0x4023A6 0x4023D3 0x4023DA In first block single call InternetReadFile Then loop block 2 3 additional call InternetReadFile block 3 This popular scheme downloading da ta Internet Malware first tries download first part server response block 1 data received continues calling InternetReadFile block 3 fails number received bytes zero meaning data received Advanced artefact analysis Advanced static nalysis 75 analyse block 1 detail At beginning block call malloc allocating memory block size 1 byte Notice address newly allocated memory block saved var iable pointed edi register But edi register ? Highlight search code value last set So looks like edi still contains variable pointer passed function argument address allocated memory saved variable Going back block 1 notice variable var_8 initialized zero Highlight var_8 check else code variable used You see var_8 used times block 3 First conjunction memcpy function specify number bytes copied later number received bytes added var_8 This means var_8 used store number received bytes Knowing th comment appropriately beginning block 1 In second half block 1 call InternetReadFile Advanced artefact analysis Advanced static analysis 76 Here see received data saved Buffer variable memory buffer declared stack size 4096 bytes 1000h Moreover number received bytes saved dwNumberOfBytesRead variable By taking look stack also notice already identified local variables Now go block 2 first block receive loop As see block 2 check number received bytes last call InternetReadFile nonzero If zero jump loop loc_402442 make analysis easier already comments added n pictures Advanced artefact analysis Advanced static analysis 77 The f irst thing happens block 3 allocation new memory block size equal length data received far recv_len plus length newly recei ved data plus one Then data previously allocated memory block memptr_old copied beginning new memory block After old memory block freed In next part newly received data buffer stack copi ed end newly allocated memory block previously copied data Finally variable recv_len updated new length received data InternetReadFile called Notice retval variable set 1 As already mention ed loop execute InternetReadFile fails number received bytes zero Next block loop loc_402442 last byte allocated memory zeroed Advanced artefact analysis Advanced static analysis 78 A fter thing happens closing opened handles Finally func_exit eax register assigned value retval variable function returns At point detailed function analysis done However remember detailed function analysis always necessary Sometimes enough quick assessment function It important set goal beginning analysis What learnt f_CnC_func Returns 1 data received Connection made hardcoded URL No POST data sent request C & C server There processing received data Function used solely download data server Received data saved newly allocated memory block A p ointer memory saved variable passed function argument Analysis WinMain Now perform analysis wWinMain function located address 0x406060 Taking general look function looks rather short Advanced artefact analysis Advanced static analysis 79 It also seems wWinMain using local variables r eferencing arguments Because function rather simple analyse block block For convenience first go last block function loc_40610F rename func_exit Now take look first block function Advanced artefact analysis Advanced stat ic analysis 80 A couple things take place First see call sub_402860 function line 03 If take quick look function see used dynamically load API functions Rename sub_402860 f_Initialize_APIs Then lines 04 - 07 09 program creating unnamed mutex The h andle mutex saved global variable hHandle line 12 Rename variable hUnnamedMutex Additionally line 11 global variable dword_438120 initialized zero You variable used code good give temporary name example var_main_zero If later see reference variable im mediately know first set zero wWinMain function Advanced artefact analysis Advanced static analysis 81 Finally lines 10 - 14 time function called The time function returns system time represented number seconds elapsed since January 1 1970 Then result value compa red variable dword_437 E40 line 15 lower function quits What value dword_437E40 ? If check xrefs see variable seems never initialized However virtual address 0x437E40 located uninitialized part data sect ion slave.exe according PE - COFF specification 22 memory au tomatically initialized zero - The size section object files size initialized dat disk image files For executable images must multiple FileAlignment optional header If less VirtualSize remainder section zero - filled Moreover since logical compare time result zero value - 1 returned error safely assume taking place To sum first block program loads API functions creates unnamed mutex initializes variable checks system time 22 Microsoft PE COFF Specification https //msdn.microsoft.com/en - us/windows/hardware/gg463119.aspx last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 82 The n ext co de block quite interesting If time result greater equal zero result compared value 0x551B3500 1427846400 This value Unix timestamp representation date 01 April 2015 12:00am UTC If time result greater value main function quits This means In next two code blocks malware tries create named mutex checks succeeds If CreateMutexW returns INVALID_HANDLE_VALUE 0xFFFFFFFF GetLastError returns ERROR_ALREADY_EXISTS 0xB7 function quits Creation named mutex typical malware technique prevent running two instances malware system Advanced artefact analysis Advanced static analysis 83 In th e next two code blocks program calls two functions sub_406120 sub_406410 None functions seem take arguments second function called first one returns value zero eax In one previous exercises lready found sub_406410 probably installation routine Indeed take look calls API functions CreateDirectoryW CreateFileW MoveFileExW RegSetValueExW well references strings \ Micro soft \ Windows \ CurrentVersion \ Run Rename function f_InstallRoutine At point sub_406120 However knowing function returns value zero installation suspect sub_406120 might checking malware already installed In next block program creating new thread T hread routine set sub_401B90 Rename function f_ThreadFunction Advanced artefact analysis Advanced static analysis 84 T n ext three blocks create loop All loop check system time compare previously checked date 01 April 2015 If time greater date program quits Otherwise program sleeps one minute 60,000 milliseconds repeats checking date Analysis thread function In exercise analysis thread function f_ThreadFunction - sub_401B90 However unlike previous examples quick assessment function get general knowledge functionality When first go f_ThreadFunction IDA Free might notice IDA highlighted parts code red This usually indicate IDA encountered problem disassembling binary manual code correction might needed However case enough tell IDA reanalyse code Options - > General - > Analysis - > Reanalyze program IDA fix references local variables Advanced artefact analysis Advanced static analysis 85 Starting analysis function see program first checks process ID saves local variable var_264 rename PID In next code block see calls CreateToolhelp32Snapshot Process32FirstW This means thread function iterating process list Indeed take look bigger picture function notice entire thread function big loop iterating processes Advanced artefact analysis Advanced static analysis 86 Next go block Process32Next called rename block label get_proc_next Now take look beginning loop block 1 see next process PID compared PID current process If PIDs equal program skips loop iterati tries check next process Advanced artefact analysis Advanced static analysis 87 Next take look blocks 2 3 4 see references process names three popular web firefox.exe iexplore.exe chrome.exe This means malware looking processes web browsers probably try inject code nspr4.dll nss3.dll chrome.dll wininet.dll previously mentioned web browsers Names DLLs passed second argument sub_406950 fastcall calling convention At point sub_406950 used quick look might suggest used enumerate DLLs web browser process check given library loaded calls CreateToolhelp32Snapshot Module32First Module32Next portions code look like string comparison Advanced artefact analysis Advanced static analysis 88 Next 6 malware calling GetSystemInfo 23 G etNativeSystemInfo 24 returns various system information SystemInfo structure IDA automatically recognized structure stack Then one SystemInfo fields anonymous_0 compared value 9 But anonymous_0 field S ystemInfo structure ? This field mentioned Microsoft documentation 25 To check anonymous_0 field first hover mouse SystemInfo Here see stack declared structure type _SYSTEM_INFO 23 GetSystemInfo function https //msdn.microsoft.com/en - us/library /windows/desktop/ms724381 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 24 GetNativeSystemInfo function https //msdn.microsoft.com/en - us/library/windows/deskt op/ms724340 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 25 SYSTEM_INFO structure https //msdn.microsoft.com/en - us/library/windows/desktop/ms724958 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 89 Next go Structures view View - > Open Subviews - > Structures This view presents well - known data structures recognized IDA disassembled code also possible create custom data structures Next find list _SYSTEM_INFO structure To expand structure decl aration click _SYSTEM_INFO name Here see anonymous_0 field first field _SYSTEM_INFO structure This means union containing information processor architecture wProcessorArchit ecture Advanced artefact analysis Advan ced static analysis 90 Indeed value 9 anonymous_0 field compared represents AMD64 processor architecture 26 This means malware checking running 64 - bit system The n ext block quite interesting educational point view It shows always need cautious analysis sometimes IDA might disassemble somethin g wrongly without warning This code executed malware determines running 64 - bit sy stem The c IsWow64Process suggests malware checks web browser process running WOW64 27 26 SYSTEM_INFO structure https //msdn.microsoft.com/en - us/library/windows/desktop/ms724958 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 27 Windows subsystem allowing 32 - bit applications running 64 - bit Windows system https //msdn.microsoft.com/en - us/library/wind ows/desktop/aa384249 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 91 According Microsoft documentation 28 IsWow64Process stdcal l function taking two arguments The econd argument Wow64Process pointe r BOOL variable used return information whether given process running WOW64 In code Wow64Process set address var_26C variable lea eax esp+280h+var_26C After call IsWow64Process would expect value returned var_26C checked But instead see references variable var_274 One possible causes problem might IDA wrongly traced stack pointer And since thread function using esp traced stack pointer Choose Options - > General check Stack pointer checkbox 28 IsWow64Process function https //msdn.microsoft.com/en - us/library/windows/desktop/ms684 139 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 92 N ow see disassemb ly additional column value stack pointer traced IDA Notice instruction changing stack pointer push pop etc changing value column instructions like mov xor add cmp stack pointer Stdcall functions supposed clean stack return However reason looks like IsWow64Process cleaning stack function taking two arguments To see reason hover mouse IsWow64Process Advanced artefact analysis Advanced static analysis 93 proper prototype IsWow64Process arguments function taking affects stack pointer Consequently IDA assumed call function changing stack pointer You correct either manually editing prototype IsWow64Process manually changing call instruction affect ing stack pointer To demonstrate Click call IsWow64Process choose Edit - > Functions - > Change stack pointer 0x8 function taking two DWORD sized arguments Now IDA correctly reference variables making code much clearer Notice previously referenced var_274 var_26C The correction stack pointer might necessary know function called affects stack G oing back thread function analysis take look block 7 single function sub_402050 called loop end Advanced artefact analysis Advanced static analysis 94 This function takes single argument process ID call graph function see calls APIs WriteProcessMemory CreateRemoteThread This means function used inject code browser process Finally code 8 executed Process32NextW returns FALSE zero The code sleeps 3 seconds repeats enumeration ent ire process list second loop To sum done quick analysis thread function During analy sis details instruction rather trying get general understanding function What learnt thread function endlessly iterates process list search processes popular web browsers Mozilla Firefox Google Chrome Internet Explorer inject code process sub_402050 What - bit process affects code injection You also skipped call sub_401DA0 function using mutexes prevent injection code twice process Additionally also learnt fix corrupted stack pointer view data structures recognized IDA Exercise Open dexter.exe sample previous exercise try analyse following functions sub_401E70 function used ? How return result ? sub_402620 function arguments used ? sub_4022B0 function used ? For function quick assessment order get general understanding function role No detailed analysis necessary Advanced artefact analysis A dvanced static analysis 95 Summary In exercise learnt approach function analysi disassembled code When starting analyse function always good ask standard questions arguments function using APIs called Answering question might give valuable information function purpose You also learn ed thorough function analysis always necessary In many cases quick assessment c ould enough get general understanding function Advanced artefact analysis Advanced static analysis 96 5 Anti - disassembly techniques As presented previo us exercises static analysis tools techniques teach lot things malicious code operates functions installs system communicates C & C server Of course usually contrary th e intentions malware creators would often want us unable analyse code creations Consequently creators complex malware often use various anti - disassembly techniques aim make analysis disassembled code much harde r. In exercise learn popular anti - disassembly techniques Note since techniques affect disassembled code usually also problem dynamic analysis debugger needs disassemble code well Linear sweep vs. recursive disassemblers To understand anti - disassembly techniques need first learn little disassemblers In general two types disassemblers linear sweep recursive disassemblers One problems w ith disassembling binary code code synchronization - tell instruction make task easier For example take lo k hexdump executable Highlighted bytes represent consecutive assembly instructions E8 34 04 00 00 call 0x401a20 E9 58 FD FF FF jmp 0x401349 8B FF mov edi edi But start analysis example offset changed two bytes would produce com pletely different assembly code Advanced artefact analysis Advanced static analysis 97 Red frames mark previously disassembled instructions highlighted bytes mark new instructions di sassembling changed offset 04 00 add al 0x0 00 E 9 add cl ch 58 pop eax FD std FF db 0xFF incorrect FF 8B FF 55 8B EC dec dword ebx - 0x1374aa01 The difference linear sweep recursive disassembler disassembler fol lows consecutive instructions A l inear sweep disassembler tries disassemble code code section executable The beginning new instruction always marked end instruction type That bytes injected instructions disassembler would try interpret another instruction For example In example interpreting te xt string Resulting disassembly would look follow Notice first two instructions push jmp disassembled properly rest code comp letely different Examples linear disassembl ers WinDbg disassembler include CFF Explorer. Advanced artefact analysis Advanced static analysis 98 U nlike linear disassemblers recursive disassemblers currently consider disassembled instruction If instruction changing execution flow jump call return instruction disassembler tries adequately interpret add destination address list locations disassemble For example instruction unconditional jump disassembler might try analyse code address jump leading instead analysing bytes right jump instruction However situations might cause problems One ir drawbacks part code never directly referenced neither called jumped disassembler might never try analyse Secondly recursive algorithm might also work well disassembler destination address call jump example address dynamically computed Examples rec ursive disassemblers IDA OllyDbg. Anti - disassembly techniques Anti - disassembly techniques techniques try mislead disassembler creating code desynchronization affecting program execution flow nonstandard way As sult disassembled code usually becomes incomplete contains ga rbage instructions junk code Though strictly anti - disassembly techniques category also add techniques trying directly affect disassembling process rather try make disassembled code complex less clear making static analysis difficult Examples techniques would inserting junk instructions dynamic loading API functions Below short summary co mmon anti - disassembly techniques Inserting garbage bytes This technique works inserting random bytes chosen parts code The intention make disassembler interpret bytes normal code would lead incorrect disasse mbly This technique usually used conjunction technique Return address manipulation This one several execution flow manipulation techniques It works changing return address current function This way di sassembler expecting function return address call instruction function would return completely different part code Middle instruction jump In technique one instruction e.g push mov us ed hide another instruction Always taken jumps This technique works using conditional jumps condition always met Since disassembler likely know try disassemble tes following instruction Indirect ca lls based runtime value If jump call made dynamically computed address/offset know address analysed next Additionally call instruction know callin g convention destination function called function changing stack pointer Structured Exception Handling SEH Structured Exception Handling SEH mechanism normally used handle exceptions programs It also used obscure execution flow first installing exception handler routine triggering exception part code As consequence program execution switched exception handler routine Advanced artefact analysis Advanced static analysis 99 Inserting junk code This technique wo rks inserting instructions change program result The aim technique make disassembled code less clear harde r analyse usually difficult analyst distinguish real instructions junk code Dynamic API loading Based API functions malware calling try predict functionality also recognize important parts code T make analysis harder malicious code frequently dynamically loads important API functions present default import address able In general deal anti - disassembly techniques necessary de ep unders tanding analys ed code also k kind anti - disassembly techniques encounter In cases anti - disassembly techniques handled manually usually following specific address forcing interpreted code In cases anti - disassembly techniques might extensive solution create scripts use dynamic analysis techniques Analysis anti - disassembly techniques In exercise analyse specially prepared binary fil e non - malicious using various anti - disassembly techniques First start opening antidisasm.exe IDA You see group calls various functions Each function using different anti - disassembly techniques returns value eax register The task tell value returned function using static analysis techniques 5.3.1 Analysis call loc_40101A First go function 0x40101A Advanced artefact analysis Advanced static analysis 100 IDA call EAX junk code loc_401045 beginning next function Notice beginning loc_40101A strange call call $ +5 This characteristic call call next instruction 0x401022 What pushing onto stack return address 0x401022 loaded eax pop eax That executing pop eax read virtual memory address exact instruction 0x401022 Then add 10h eax value call address newly computed eax value At point know eax value 0x401032 0x401022+0x10 Unfortunately leads us right middle junk code seems instruction address address called calling eax result tried disassemble next instruction To correct first select junk code right click choose undefined press < U > Advanced artefact analysis Advanced static analysis 101 Next click byte address 0x401032 press < C > convert code Notice also strin g Now code much clearer You also read return value loc_40101A 0x1337 Advanced artefact analysis Advanced static analysis 102 To sum function seen two anti - disassembly techniques First indirect call instruction happened inline embedded string second technique This resulted creation junk code instead valid assembly structions 5.3.2 Analysis call loc_401045 The econd function analyse function loc_401045 At first glance even though IDA recognized code normal function see typical function prologue epilo gue return instruction You also highlight eax register check value set It seems eax first set 0x11EB increased 0x1000 However catch attention jump struction jz seems lead middle instruction Notice also red coloured cross reference suggesting something wrong Advanced artefact analysis Advanced static analysis 103 Before start analysing jump leads en The last instruction sets zero flag jump xor eax eax zeroing eax register always sets zero flag This means jump always taken Since jump leads middle instruction select instruction convert dat use Undefine press < U > IDA likely undefine code already know jz destination address 0x40104B original jz instruction located 0x401050 Now select byte 0x40104B press < C > define code Do byte 0x401050 jz instruction After see code similar one Advanced artefact analysis Advanced static analysis 104 This means middle push instruction hidden another jump instruction As yo u see hidden jump leading us middle instruction 0x40105D address 0x40105E But time looks like normal assembly desynchronization To proceed go undefined instruction 0x40105D create code address 0x40105E After operations code look follow Now clearly see return value set 0x4096 Notice retn instruction garbage bytes added prevent IDA properly disassembling instructions th e eax value set Advanced artefact analysis Advanced static analysis 105 The creenshot shows execution flow routine making changes To sum routine seen anti - disassembly techniques The notable one jump middle another instruction In scenario push instruction used conceal another jump instruction You also seen usage conditional jump always taken well us e garbage bytes desynchronize disassembled code 5.3.3 A nalysis call sub_401065 The n ext call made sub_401065 This time IDA recognized code normal function What see eax register first zeroed function sub_40107D called argument 0x1000 finally add 0x1000 eax The question whether sub_40107D changes eax return value sub_40107D Advanced artefact analysis Advanced static analysis 106 It looks like thing function eax first loading arg_0 value 0x1000 adding another 0x1000 Thus function return eax value 0x2000 Does mean return value sub_401065 0x3000 0x2000+0x1000 ? As might suspected easy Take look happens sub_40107D returns First load edx stack address first argument subtract 4 bytes edx What address stored edx point ? Remember stack frame structure arg_0 ebp+8 ret addr ebp+4 ebp ebp After subtraction edx points return address stored stack Then third line add 0x2B return address value This means return address function changed sub_40107D return different place code To check function return go back sub_401065 Advanced artefact analysis Advanced static analysis 107 The riginal return address 0x401074 But know increased 0x2B This means function sub_40107D return address 0x40109F 0x401074+0x2B Switch graph view text v iew search address Not surprisingly see junk code stored location Undefine < U > code create new code < C > starting address 0x40109F You found final eax value 0xC0DE ! To sum section seen quite popular anti - disassembly technique return address replacement Malicious code trying deceive disassembler replaces return address call certain function w ould point completely different part code disassembler expects 5.3.4 Analysis call sub_4010 B2 Now analyse call subroutine sub_4010 B2 Advanced artefact analysis Advanced static analysis 108 If go function see long disassembled code many operations eax register However take closer look code might notice groups instructions anything might change fla gs relevant example Advanced artefact analysis Advanced static analys 109 This little simplified version technique blocks junk instructions effect program execution making manual analysis harder injected real code The way dealing code try look repeated pattern junk code disassembly If notice pattern might try eliminate writing script would overwrite junk code NOP instructions highlight wit h colour However writing scripts IDA part course I f analyse code little notice three instructions effect final eax value This means final eax value 0x1500 5.3.5 Analysis call sub_40116D The l ast call analyse call sub_40116D Advanced artefact analysis Advanced static analysis 110 In routine eax register seemingly set 0xEBFE value However immediately notice instruction mov fs:0 esp tells us new Structured Exception Handler SEH installed 29 Information exception handlers stored list EXCEPTION_REGISTRATION structures _EXCEPTION_REGISTRATION struc prev dd ? handler dd ? _EXCEPTION_REGISTRATION ends This structure consist two fields The f irst field prev pointer next EXCEPTION REGISTRATION structure second field handler pointer exception handler function The p ointer first EXC EPTION_REGISTRATION structure list head always stored first DWORD value Thread Information Block TIB On Win32 platform TIB address stored FS register thus executing mov fs:0 esp setting first exception handler EXCEPTION_REGISTRATION structure created stack In case sub_40116D stack would look follow SEH installation 29 To get information SEH refer https //www.microsoft.com/msj/0197/exception/exception.aspx last accessed 11.09.2015 Advanced artefact analysis Advanced static analysis 111 The next question whether exceptio n triggered function ? Yes take look ecx register First zeroed program tries write DWORD value address pointed register However ecx points unallocated address 0x00000000 cause exception STATUS_ACCESS_ VIOLATION 0xC0000005 program execution would switched installed exception handler But address exception handler routine ? In example see value 0x15232A1 pushed onto stack exception hand ler But valid address function Indeed notice xor instruction xoring exception handler address stack value 0x1122300 This means real exception handler address 0x15232A1 xor 0x1122300 = 0x4011A1 To ca lculate xor value use IDA calculator View - > Calculator Now switch graph view text view search address 0x4011A1 Advanced artefact analysis Advanced static analysis 112 Repeat steps previous exercises convert data 0x4011A1 code What see eax assigned value 0x512 Other instructions restore stack pointer jumps end sub_40116D To sum seen subroutine usage Structured Exception Handling SEH change execution flow prog ram SEH commonly used anti - disassembly anti - debugging technique Additionally address exception handler routine obscured xor operation Exercise After completing analysis anti - disassembly techniques n sample try repeat exercise using OllyDbg instead This executable accidentally executing When debugging OllyDbg try follow execution using Step F7 function instead stepping analysed functions How disa ssembled code OllyDbg differ code initially disassembled IDA ? Was analysis easier OllyDbg IDA ? Advanced artefact analysis Advanced static analysis 113 6 Training summary In training students opportunity learn various aspects advanced static analysis using IDA Free First learnt use IDA features offers Then learnt find significant parts disassembled code analyse function s. Finally students reviewed common anti - disassembly techniques deal Some advanced features IDA like scripting creating plugins F.L.I.R.T signatures covered document require adva nced training features available free version IDA Advanced artefact analysis Advanced static analysis 114 Appendix A Answers exercises Exercise 2.3 Name functions imported PuTTY executable Click View - > Open subviews - > Imports What sections present within executable ? Click View - > Open subviews - > Segments Sections .text .idata .rdata .data This also checked using tools e.g CFF Explorer What strings tell binary ? Click View - > Open subviews - > Strings There many descrip tive strings binary In general strings give away analyzing PuTTY network application using many different protocols cryptographic functions There many strin gs names network protocols e.g ssh telnet rlogin There strings pointing cryptographic functions AES Blowfish 3DES suggesting executable using form cryptography There various caption messages suggesting PuTTY fun Advanced artefact analysis Advanced static analysis 115 There many error messages also suggesting PuTTY capabilities Exercise 2.6 Find function sub_4497AE What API calls made within function ? Called API functions RegOpenKeyA RegQueryValueEx RegCloseKey LoadLibraryA GetProcAddress Go address 0x406AFB To function address belong ? Function sub_40486C Go address 0x430EAB Is anything special instructions stored address ? At thi address proper function Exercise 2.9 Find variable var_8 used rename cur_process_id variable used store ID curre nt process Advanced artefact analysis Advanced static analysis 116 Try rename remaining locations loc_44D2B1 loc_44D2DA loc_44D36B loc_44D3B4 What names would suggest ? loc_44D2B1 loc_44D2DA loc_44D36B loc_44D3B4 Group three graph nodes checking functions CryptAcquireContextA CryptGenRandom CryptReleaseContext resolved correctly 0x44D36B 0x44D374 0x44D37C Can guess function sub_44D262 might used ? Function takes one argument function pointer ebx Then gathers information file names FindNextFileA current process ID GetCurrentProcessId also generates block random data CryptGenRandom After calls data received file names process ID block random dada Then data passed always function ebx Advanced artefact analysis Advanced static analysis 117 Because non - uniform random data passed multiple times function suggests function likely used random data pool collector To confirm guess would need analyze sub_44D262 called There also two additional function calls func_exit block likely inspected first Exercise 4.4 Find network related functions sub_402710 calls functions InternetOpenA InternetConnectA HttpSendRequestA There also http // % % Find installation routine sub_402EC0 - called main calls CopyFileW RegSetValueExW DeleteFileW It also references \ \ Microsoft \ \ Windows \ \ CurrentVersion \ \ Find function perfo rming RAM scraping reading memory processes sub_403BD0 calls ReadProcessMemory CreateProcess32Snapshot Process32First Process32Next Find process injection routine sub_403550 calls CreateRemoteThread sub_403370 calls WriteProcessMemory called sub_403550 Are potentially interesting suspicious functions ? sub_401E70 references strings different operating systems names sub_4022B0 hich looks like HTTP GET request parameters sub_4045B0 - start 0x4036B0 start routine Exercise 5.4 sub_401E70 function used ? How return result ? Function us ed OS identification String containing operating system name copied memory buffer passed function argument Advanced artefact analysis Advanced static analysis 118 sub_402620 function arguments used ? Function takes three arguments renamed screenshot clarity All three arguments recognized IDA string pointers lpString2 second argument processed calls sub_4017C0 sub_401830 result copied allocated buffer lpMem You might decide analyz e calls learn th ey affect value lpString2 Short sub_402620 returns two string concatenation operations First lpString1 concatenated lpString3 Then lpMem buffer concatenated lpString3 Advanced artefact analysis Advanced static analysis 119 Based short alysis tell function takes three string pointer arguments arg1..arg3 Then performs following operation written pseudocode arg3 += arg1 + f arg2 Where f function somehow processing second string argument sub_4022B0 function used ? In function calls functions like GetUserNameA GetComputerNameA sub_401E70 already know returning name operating system There also references strings Function called sub_402710 already found function used communicate C & C server This suggests function used construct string parameters HTTP GET request containing various information infected system You detailed analysis check parameters constructed GET request Exercise 6.4 In exercise enough debug using Step F7 read return value f rom EAX register function end In exercise times hit part disassembly recognized OllyDbg assembly code To fix select group bytes starting current EIP location black sq uare right click selection context menu choose Analysis - > During next analysis treat selection - > Command This fix problem Advanced artefact analysis Advanced static analysis 120 Special attention required last function 0x40116D uses Structured Exception Handlers SEH hide code When hit instruction exception occurs 0x40118E OllyDbg would stop inform status bar access violation exception occurred Open SEH View View - > SEH Chain check extra exception handlers You see one exception handler defined current module Select press F2 put breakpoint suspicious breakpoint dialog Advanced artefact analysis Advanced static analysis 121 Then press Shift+F9 resume execution pass exception handling program You immediately land exception handling code Tell OllyDbg treat instructions normal code Analysis - > During next analysis treat selection - > Command continue instruction stepping ENISA European Union Agency Network Information Security Science Technology Park Crete ITE Vassilika Vouton 700 13 Heraklion Greece Athens Office 1 Vass Sofias & Meg Alexandrou Marousi 151 24 Athens Greece PO Box 1309 710 01 Heraklion Greece Tel +30 28 14 40 9710 info @ enisa.europa.eu www.enisa.europa.eu www.enisa.europa.eu European Union Agency For Network And Information Security Advanced dynamic analysis TOOLSET DOCUMENT FOR STUDENTS OCTOBER 2015 Advanced artefact analysis October 2015 02 About ENISA The European Union Agency Network Information Security ENISA centre network information security expertise ENISA works groups develop advice recommendations good practice information security It assists EU member states implementing relevant EU legislation works improve expertise EU member states supporting development cross - border communities committed improving network information secu rity throughout EU More information ENISA work found www.enisa.europa.eu Authors This document created Yonas Leguesse Christos Sidiropoulos Kaarel Jõgi Lauri Palkmets n consultation ComCERT 1 Poland S - CURE 2 The Netherlands DFN - CERT Services Germany Contact For contacting authors please use cert - relations @ enisa.europa.eu For media enquiries paper please use press @ enisa.europa.eu Acknowledgements goes Filip 1 2 Don Stikvoort Michael Potter Legal notice Notice must taken publication represents views interpretations authors editors unless stated otherwise This publication construed legal action ENISA th e ENISA bodies unless adopted pursuant Regulation EU No 526/2013 This publication necessarily represent state - - art ENISA may update time time Third - party sources quoted appropriate ENISA responsible content external sources including external websites referenced publication This publication intended information purposes It must accessible free charge Neither E NISA person acting behalf resp onsible use might made information contained publication Copyright Notice © European Union Agency Network Information Security ENISA 201 5 Reproduction authorised provided source acknowledged Advanced artefact analysis October 2015 03 Table Contents 1 Training introduction 5 2 Introduction OllyDbg 6 OllyDbg interface 6 Basic debugging code navigation 14 Breakpoints 20 Execution flow manipulation 26 Plugins 28 Shortcuts 29 3 Unpacking artifacts 31 Unpacking UPX packed sample 31 Unpacking UPX ESP trick 40 Unpacking Dyre sample 44 4 Anti - debugging techniques 54 Anti - debugging anti - analysis techniques 54 Dyre - basic patching OllyDbg 55 5 Process creation injection 59 Following child processes Tinba loader 59 5.1.1 First stage 59 5.1.2 Second stage 68 6 Introduction scripting 74 Decoding hidden strings Tinba 74 Adva nced artefact analysis October 2015 04 Main Objective The aim training present methods techniques dynamic artefact analysis use OllyDbg 3 debugger package Trainees following code execution unpack artefacts using efficient methods In addition tracing malicious code execution During process trainees learn counter anti - analysis techniques implemented b malware authors In second part trainees study various code injection techniques debug hollowed processes At end training presented automate debugging process The training performed using Microsoft Windows operating system Targeted Audience CSIRT staff involved technical analysis incidents especially dealing sample examination malware analysis Prior knowledge assembly language operating systems internals highly recommended Total Duration 8 - 10 hours 3 OllyDbg http //www.ollydbg.de/ last accessed 11.09.2015 Advanced artefact analysis October 2015 05 1 Training introduction In training learn practical elements advanced dynamic analysis debugging malicious code Except introductory part samples used training live malware samples Consequently analyses done dedicated isolated environments After analysis clean virtual machine snapshot restored instructed otherwise An Internet connection needed complete training Advanced artefact analysis October 2015 06 2 Introduction OllyDbg OllyDbg interface First open OllyDbg debugger Make sure run Administrator If using Windows virtual machine prepared way Building artefact handling analysis environment 4 training also access OllyDbg using context menu Now see OllyDbg interface 4 Building artefact handling analysis environment https //www.enisa.europa.eu/activities/cert/training/training - resources/technical - operational # buil ding last accessed 11.09.2015 Advanced artefact analysis October 2015 07 There two ways start debugging process Firstly attach already running process To choose File - > Attach choose process interest After attaching running process OllyDbg automatically break ntdll.DbgBreakPoint function The second way open executable file using standard File - > Open menu This way OllyDbg create new child process debugged application debuggee stop entry point executable default For example open putty.exe binary OllyDbg After OllyD bg finish initial analysis Advanced artefact analysis October 2015 08 The Central part OllyDbg CPU window Disassembly view 4 presents listing disassembled code Registers view 5 presents current state CPU registers currently selected thread Advanced artefact analysis October 2015 09 Information panel 6 used present additional information instruction selected disassembly view e.g operati result registers values Memory dump 7 presents dump chosen memory region Besides hexadecimal c choose data representation formats right - clicking memory dump panel choosing required data repre sentation context menu Take time check data representations At end restore default format Hex - > Hex/A SCII 16 bytes Finally stack panel 8 presents stack state currently selected thread Advanced artefa ct analysis October 2015 10 Besides CPU window OllyDbg offers windows used different purposes All windows accessed windows buttons toolbar View menu T frequently used windows Executable modules Memory map Threads Handles Call stack Breakpoints The Executable modules window present executable modules loaded address space debugged process Usually would module executed binary modules loaded DLL libraries You double - click modules immediately jump module di sassembly view You also right - click modules access context menu additional operations Advanced artefact analysis October 2015 11 For example right - click msvcrt choose View names presented list names defined msvcrt library imports exports Memory map window presents memory structure allocated memory regions address space debugged process For example sometimes useful open additional dump window dump giv en memory region To double - click memory region select choose Dump option context menu Advanced artefact analysis October 2015 12 Another operation might try searching memory regions particular string byte pattern Let say know som ewhere memory wrong passphrase present exact address memory region located To solve problem right - click anywhere memory map choose Search Ctrl+B context menu In new window type click Ok If string found OllyDbg open new Dump window position set string To keep searching occurrences string memory region click n Dump window make active keep pressing Ctrl+L Advanced artefact analysi October 2015 13 To continue searching string memory regions go back Memory map window make active kee p pressing Ctrl+L Threads window shows threads current process Handles window shows windows opened process handles additional information regarding handle type value name This window may useful example see API call referring mber handle Finally c stack window shows function calls made current instruction current thread One useful OllyDbg features highlighting elements changed Advanced artefact analysis October 2015 14 Open Executable modules window If red coloured elements window right - click choose Actualize Next right - click anywhere window choose Insert module context menu operation available Olly Advanced plugin In Open dialog choose c \ Windows \ System32 \ wininet.dll Now newly loaded modules marked red font Executable modules window Basic debugging c ode navigation Start loading putty.exe sample described previous ex ercise The current state debugged process read upper left corner OllyDbg window When process paused current position instruction pointer indicated black square disassembly view value EIP register Advanced artefact analysis October 2015 15 Whenever get lost double - click EIP register value instantaneously moved current position code Remember program multiple threads current position likely different thread There two modes instruction stepping Step F7 executes current instruction moves program execution next instruction If current instruction function call debugger steps call starts st epping instructions called function Step F8 behaves Step except current instruction function call If want let program run freely choose Run F9 In result PuTTY create main window present user If want pause program execution press F12 Debug - > Pause staying OllyDbg You also restart executable pressing Ctrl+F2 Debug - > Restart Other use ful debug operations Run selection F4 causes OllyDbg resume execution selected instruction Execute till return Ctrl+F9 executes program return current function Execute till user code Alt+F9 executes program u ntil user code Debugging actions also accessed th e toolbar top OllyDbg Advanced artefact analysis October 2015 16 If want quickly pre - view execution flow program find loops check jumps taken etc might decide use instruction trace instruction animation functions Restart PuTTY sample Debug - > Reset choose Debug - > Animate Ctrl+F8 Observe happens disassembly window Close PuTTY reset sample Now choose Debug - > Animate This time instead stepping animation step function call including API calls You open Call stack Alt+K window observe called functions real time Animate function usually takes time program finishes execution To stop use Pause F12 function Next restart sample choose Debug - > Set condition Advanced artefact analysis October 2015 17 S et following two conditions Now open Run trace window View - > Run trace choose Debug - > Trace This would also indicated OllyDbg status bar bottom left corner Now take look Run trace window Advanced artefact analysis October 2015 18 If would like run trace logged file right - click Run trace window choose Log file option f rom context menu executing Run trace function First restart PuTTY sa mple Whenever see call jump instruction follow without executing clicking instruction pressing < Enter > In example follow call putty.004545A0 Another way navigating code using Go expression feature Click di sassembly view press Ctrl+G Type eip moved current location code pointed EIP register process see proper error message S tart clicking registers values If register points existing address address space current program following options Follow Disassembler Follow Dump Advanced artefact analysis October 2015 19 If register contain valid address options location stack like case ESP register option Follow Stack You ame values stored stack Advanced artefact analysis October 2015 20 Breakpoints To set software breakpoint double - click second column next instruction select instruction press F2 Now press F9 run program stop execution instruction executing To remove breakpoint repeat steps setting You view list software breakpoints Breakpoints window You also use window remove temporarily disable chosen breakpoints Click disassembly view use Go expression Ctrl+G find address Sh ellExecuteA Then set breakpoint first instruction ShellExecuteA one moved If PuTTY process paused resume execution F9 Next PuTTY window click About button Visit Web Site button Advanced artefact analysis October 2015 21 Now go back OllyDbg Take look stack view see arguments passed ShellExecuteA Open call stack window View - > Call stack Clt+K check ShellExecuteA function called Advanced artefact analysis October 2015 22 G OllyDbg restart PuTTY sample Next step instruction 0x454AF9 As see dword value written memory address 0x47E140 Right - click instruction context menu choose Follow Dump - > Memory address Now Memory Dump view centred 0x47E140 address Select first 4 bytes dword right - click From context menu choose Breakpoint - > Hardware access - > Dword Advanced artefact analysis October 2015 23 To view currently set hardware breakpoints choose Debug - > Hardware breakpoints After setting hardware breakpoint 0x47E140 resume program execution F9 Scroll disas sembly view one line see nstruction accessing 0x47E140 You remove hardware breakpoint automatically removed sample reload Advanced artefact analysis October 2015 24 You set memory breakpoint similar manner hardware breakpoints selecting data Memory Dump view choosing Breakpoint - > Memory The econd way creating memory breakpo int using Memory map window Restart PuTTY sample open Memory map right - click context menu choose Set memory breakpoint access Now code tries access data .resour ce section breakpoint would hit Advanced artefact analysis October 2015 25 Next resume program F9 The b reakpoint hit someplace system code If check Call stack window see breakpoint hit call CreateDialogParamA FindResourceExA called To remove memory breakpoint go Memory map window right - click memory region memory breakpoint set select Remove memory breakpoint Advanced artefact analysis October 2015 26 Execution flow manipulation First restart PuTTY sa mple step unt il first jump instruction You force jump taken changing appropriate flag FLAGS register JE jump equality taken whenever zero flag Z set To change zero flag double - click value next made grey arrow You also change jump never made overwriting jump instruction NOP instructions To right - click jump instruction choose Binary - > Fill NOPs Advanced artefact analysis October 2015 27 In similar way modifying FLAGS register also modify registers To right - click register value choose Modify Values stack modified well This time however two options Modify Edit Advanced artefact analysis October 2015 28 Besides modifying registers data memory also possible change instructions executed To achieve select instruction w ant modify press < space > Plugins After downloading plugin unpack copy c \ tools \ Portable version \ Olly_110 \ Plugins The e xact location plugins directory checked Options - > Appearance - > Directories menu Advanced artefact analysis October 2015 29 After plugin installation restart OllyDbg If plugin working available plugins menu Note plugins created OllyDbg v1.10 compatible OllyDbg 2.xx vice versa There many useful plugins OllyDbg mostly preference use Among plugins used training aadp4olly - tries hide OllyDbg popular anti - debugger techniques Olly Advanced fixes bugs OllyDbg v1.10 introduces new functions enhancing OllyDbg capabilities It also implements various anti - anti - debugging techniques ODbgScript introduces scripting assembly - like language allowing automate certain tasks OllyDump Ex memory PE dumping plugin It allows dump PE image memory file Frequently used dumping unpacked binaries Bookmarks allows insert bookmarks code help quickly navigate later Shortcuts Shortcuts ess ential part OllyDbg Thanks shortcuts perform many operations much faster saving valuable time This section lists commonly used shortcuts OllyDbg Debugging OPERATION SHORTCUT Run F9 Pause F12 Restart debugged app Ctrl+F2 Close debugged app Alt+F2 Step F7 Step F8 Execute till return Ctrl+F9 Execute till user code Alt+F9 Advanced artefact analysis October 2015 30 Pass exception program Shift+F7/F8/F9 Animate Ctrl+F7 Animate Ctrl+F8 Trace Ctrl+F11 Trace Ctrl+F12 Windows views OPERATION SHORTCUT CPU window Alt+C Memory map Alt+M Executable modules Alt+E Call stack Alt+K Breakpoints Alt+B Other operations OPERATION SHORTCUT Follow jump/call Enter Assembly instruction Space Edit memory Ctrl+E Add comment semicolon Add label colon Insert bookmark X Alt+Shift+0..9 Go bookmark X Alt+0..9 Advanced artefact analysis October 2015 31 3 Unpacking artifacts U npacking UPX packed sample PEiD 5 used identify sample packed packer used In case PEiD reveals putty_upx.exe sample packed UPX seen following screenshot To confirm output PEiD identify packing specifically CFF Explorer 6 used 5 PeiD http //www.aldeid.com/wiki/PEiD last accessed 11.09.2015 6 CFF Explorer suite http //www.ntcore.com/exsuite.php last accessed 11.09.2015 Advanced artefact analysis October 2015 32 Now know sample wa packed UPX move forward towards manual unpac king To sample opened OllyDbg OllyDbg report sample looks like compressed packed Execution executable paused entry point putty_upx.exe 0x48CD50 located UPX1 section Advanced artefact analysis October 2015 33 In order reach beginning unpacking routine step function Shortcut key F8 five times MOV EBX DWORD PT R DS ESI instruction address 0x48CD6A Take look ESI source EDI destination registries ESI points beginning UPX1 section EDI points beginning UPX0 refer previously checked Virtual Addresses CFF Explorer To see packed code follow hex dump Ctrl+G ESI register Then follow hex dump EDI register see clean memory u npacked code stored Advanced artefact analysis October 2015 34 Then press hold seconds Step Over key F8 Now scro numerous jump instructions see three CALL instructions addresses 0x48CE8A 0x48CEA8 0x48CEB9 Set breakpoints instructions inspect functions calle Resume execution F9 Put breakpoint 0x48 CEBF outside IAT reconstruction loop press F9 times 5 - 10 Advanced artefact analysis October 2015 35 Follow EBX register hex dump Now remove breakpoints except breakpoint outside IAT reconstruction loop 0x48CEBF resume execution F9 let IAT reconstruction finish Right - click hex dump context menu choose Long Address Advanced artefact analysis October 2015 36 Next scroll assembly code characteristical JMP instruction 0x48CEFC Put breakpoint instruction resume execution F9 After reaching breakpoint JMP instruction single step F7/F8 land OEP In case recognize OEP calls functions GetVersionExA GetModuleHandleA Remember address OEP 0x 459FE0 b ecause needed later Advanced artefact analysis October 2015 37 In next step dump unpacked process image exe cutable file To achieve use OllyDumpEx plugin allows dump process image memory executable file P E format When dumping unpacked putty.exe code use default OllyDumpEx settings Save dumped process dump.exe Now would try execute dump.exe see Application Error dump.exe IAT reconstructed Advanced rtefact analysis October 2015 38 To reconstruct IAT use ImpREC 7 tool Run ImpREC Administrator scroll menu top wind ow choose putty_upx.exe process 7 ImpREC http //www.woodmann.com/collaborative/tools/index.php/ImpREC last accessed 10.10.2015 Advanced artefact analysis October 2015 39 Next IAT Infos needed RVA address OEP OEP address minus Image Base address case 0x459FE0 - 0x400000=0x59FE0 IAT AutoSearch IAT found see p propriate message box Otherwise might need try manually enter RVA Siz e IAT Next click Get Imports Advanced artefact analysis October 2015 40 Show Invalid Fix Dump select dump.exe file If everything goes right see message dump_.exe saved successfully please note underscore name file name You try run dump_.exe check runs Unpacking UPX ESP trick O pen putty_upx.exe OllyDbg Advanced artefact alysis October 2015 41 Step PUSHAD instruct ion Shortcut key F8 Notice stack view ESP register changes seen following screenshot Follow ESP register hex dump put hardware breakpoint access memory region pointed register Advanced artefact analysis October 2015 42 Nex resume execution F9 immediately land jump OEP Remove hardware breakpoint Debug - > Hardware breakpoints Delete Advanced artefact analysis October 2015 43 Now put breakpoint JMP instruction 0x48CEFC resume execution F9 reach Step JMP instruction F8 land OEP Advanced artefact analysis Oct ober 2015 44 Unpacking Dyre sample In exercise unpacking Dyre 8 malware presented Dyre banking trojan packed using complex packer UPX Since live malware sample run controlled virtual environment analysis restore clean snaps hot virtual machine It also advisable forbid network access working Dyre Open f ile called voiyhabs.exe OllyDbg You see entry point Put breakpoint ZwAllocateVirtualMemory described introduction OllyDbg Now open Call stack window View - > Call Stack Alt+K press resume execution F9 times see call HeapCreate flags set 0x40000 Remove breakpoint ZwAllocateVirtualMemory show calling location HeapCreate voiyhabs module 8 Dyre Emerging threat financial fraud landscape http //www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/dyre - emerging - threat.pdf last accessed 19.10.2015 Advanced artefact analysis October 2015 45 Put breakpoint instruction HeapCreate call resume execution F9 Write address newly created heap returned EAX register 0xDE0000 example might different Remove previously set breakpoint 0x40144D scroll yo u see call RegisterClassEx function 0x4018DE Put breakpoint function resume execution F9 Next check address window procedure registered window class Hiding code window procedure common technique used malware hinder analysis change execution flow If window procedure points existing add ress good put breakpoint address The w indow procedure address passed third field WndClassEx structure lpfnWndProc preceded two INT values This means address third DWORD value WndClassEx structu typedef struct tagWNDCLASSEX { UINT cbSize UINT style WNDPROC lpfnWndProc int cbClsExtra int cbWndExtra HINSTANCE hInstance HICON hIcon HCURSOR hCursor HBRUSH hbrBackground LPCTSTR lpszMenuName LPCTSTR lpszClassName HICON hIconSm } WNDCLASSEX *PWNDCLASSEX Address WndClassEx structure put first argument onto stack Follow dump Advanced artefact analysis October 2015 46 Now read address Window procedure hex dump remembering addresses written little - endian notation In case Window procedure address 0x02100210 Next try follow address assembly window If land existing code section put breakpoint address To go back current location follow EIP register Next scroll call EnumDisplayMonitors function Put breakpoint call resume execution F9 alter natively select location use Run selection F4 BOOL EnumDisplayMonitors _In_ HDC hdc _In_ LPCRECT lprcClip _In_ MONITORENUMPROC lpfnEnum _In_ LPARAM dwData Check address enumer ation procedure lpfnEnum stack third argument example 0xEDE688 Advanced artefact analysis October 2015 47 Put breakpoint enumeration procedure assembly window go address enumeration procedure lpfnEnum toggle breakpoint address Resume execution F9 The e xecution break inside enumeration procedure Step F8 two times follow jump Scroll put breakpoint suspicious CALL EAX function return RETN Resume execution F9 When hit breakpoint CALL EAX step F7 call You land another unpacking stub function Step F8 two times Now scroll group three calls function return Put breakpoin first call resume execution F9 After reaching breakpoint step first function call F7 You see several PUSH instructions followed call instruction Advanced artefact analysis October 2015 48 When step F8 call instruction ee call CreateThread function HANDLE WINAPI CreateThread _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes _In_ SIZE_T dwStackSize _In_ LPTHREAD_START_ROUTINE lpStartAddress _In_opt _ LPVOID lpParameter _In_ DWORD dwCreationFlags _Out_opt_ LPDWORD lpThreadId Now take look stack The hread routine passed third argument In example points 0xEE38AC Put breakpoint thread function lpStartAddress resume execution F9 Advanced artefact analysis October 2015 49 When breakpoint thread function hit step F8 call ECX Step call F7 You land OEP written code Ol lyDbg Starting OEP address select group instructions Next right - click context menu Analysis - > During next analysis treat selection - > Command Advanced artefact analysis October 2015 50 Now click ag Analysis - > Analyse code Advanced artefact analysis October 2015 51 Next dump process image reconstruct IAT table To dump process use OllyDumpEx plugin described previously Advanced artefact analysis October 2015 52 Now try reconstruct Import Address Table RVA OEP 0x3850 using ImpRec This time might see invalid imports clicking Get Imports Show Invalid Right - click context menu choose Cut thunks After invalid pointers resolved use Fix dump fix dumped executable Advanced artefact analysis October 2015 53 Advanced artefact analysis October 2015 54 4 Anti - debugging techniques Anti - debugging anti - analysis techniques O ne countermeasures anti - debugging use special plugins OllyDbg like aadp4olly 9 Olly Advanced 10 When using plugins need check anti - anti - debugging techniques used You accessing Plugins menu The creenshot presents anti - anti - debugg ing options aadp4olly plugin 9 adp4olly https //tuts4you.com/download.php ? view.3021 last accessed 11.09.2015 10 Olly Advanced https //tuts4you.com/download.php ? view.75 last accessed 11.09.2015 Advanced artefact analysis October 2015 55 Dyre - basic patching OllyDbg If virtual machine one CPU configured start Process Explorer/Process Monitor try execute unpacked Dyre sample You observe sample quits almost immediately nothing muc h seems happening The creenshot shows Process Tree view created Process Monitor tool Tools - > Process tree Advanced artefact analysis October 2015 56 Now open unpacked Dyre OllyDbg If step F8 times notice first jump instruction JB program jumping ExitProcess routine Advanced artefact analysis October 2015 57 I f value less two terminate process To patch behaviour click CMP instruction press space select Assemble context menu Replace 2 1 S elect modified commands context menu choose Copy executable - > All modifications Copy All dialog window In new window context menu choose Save file save patched executable Advanced artefact analysis October 2015 58 Now try runn ing patche executable observing behaviour Process Explorer Process Monitor process tree If everything done correctly see Dyre process creating new child process uses significantly time Advanced artefact analysis October 2015 59 5 Proce ss creation injection Following child processes Tinba loader 5.1.1 First stage First open OllyDbg load doc likwidacji _ doc_TK2015.exe format executable Now land entry point 0x401300 Advanced artefact analysis October 2015 60 Insert breakpoints following functions CreateProcessW SetThreadContext WriteProcessMemory ResumeThread Resume process execution F9 After short land CreateProcessW breakpoint As see either stack window call stack window Alt+K new process created suspended state CREATE_SUSPENDED created using original executable image Advanced artefact analysis October 2015 61 Step F8 times till g past return land back loader code You land instruction TEST EAX EAX Scroll assembly code see calls functions GetThreadContext ReadProcessMemory ZwUnmapViewOfSection VirtualAllocEx Wr iteProcessMemory SetThreadContext ResumeThread This typical process hollowing technique Now could step code F8 follow exactly process hollowing taking place Resume execution F9 The execution break WriteProcessMemory Take look arguments passed via stack WriteProcessMemory function Advanced artefact analysis October 2015 62 You see loader overrides 17920 bytes address 0x400000 previously created child process If follow dump source buffer 0x2130000 11 see typical PE headers likely unpacked code Resume execution F9 two times break SetThreadContext function Write address context structure put stack 0x420000 - pContex follow dump The e ntry point newly created process stored EAX register 12 Its value read context structure address pContext+0xB0 13 In case entry point address 0x00401000 remember littl e - endian notation Write address entry point needed later 11 This address might different Advanced artefact analysis October 2015 63 Resume execution F9 land breakpoint ResumeThread Open Process Hacker find suspended child process Right - click open Properties window In Properties window switch Memory tab find memory block entry point located 0x401000 - > memory block 0x400000 Right - click choose Read/Write Memory option 12 EAX register context currently debugged process 13 struct CONTEXT http //www.nirsoft.net/kernel_struct/vista/CONTEXT.html last accessed 11.09.2015 Advanced artefact analysis October 2015 64 In new window go entry poin address offset 0x1000 addresses relative 0x400000 Advanced artefact analysis October 2015 65 Write first two bytes offset 0x64A1 override 0xEBFE Click Write close window Now switch back OllyDbg step F8 till return ResumeThread function Now minimize OllyDbg I n Process Hacker window ou also notice child process resumed using considerable amount CPU time This result endless loop created proces s. Note process identifier PID child process decimal Advanced artefact analysis October 2015 66 Start new OllyDbg instance attach child process File - > Attach Ignore error message previously You land somewhere ntdll Advanced artefact analysis October 2015 67 In assembly window go address 0x401000 EP You see previously injected 0xEBFE bytes Put breakpoint instruction resume process F9 After land breakpoint select JMP instruction press Ctrl+E edit Replace EB FE bytes original 64 A1 Advanced artefact analysis October 2015 68 After confirmation OllyDbg automatically reanalyse code changing significantly 5.1.2 Second stage First still paused entry point second stage create snapshot virtual machine name Tinba In case anything going entire process Next put breakpoints following functions CreateProcessInternalW GetThreadContext SetThreadContext WriteProcessMemory ResumeThread Resume execution F9 Shortly land CreateProcessInternalW call Right - click assembly Analyze ! using OllyDbg plugin Next open Call stack window View - > Call stack Alt+K Continue execution F9 till land GetThreadContext breakpoint Advanced rtefact analysis October 2015 69 Note address pContext structure example 0x12FAAC follow dump Next step F8 till return GetThreadContext read EXPLORER .exe entry point pContext+0xB0 address Alternatively find explorer.exe executable disk check entry point address PE editor e.g CFF Explorer In situation EP located address 0x4AA8DF Resum e execution F9 till breakpoint WriteProcessMemory Advanced artefact analysis October 2015 70 Follow source buffer dump address case 0x411026 Notice names functions MapViewOfFile OpenFileMapping Select first two bytes source buffer E8 C2 press Ctr l+E Replace bytes EB FE Next step WriteProcessMemory function till use r code You land TEST EAX EAX instruction Advanced artefact analysis October 2015 71 Continue execution F9 ResumeThread breakpoint Now since 0xEBFE trick already applied safely step F8 ResumeThread function Minimize OllyDbg window check Process Hacker explorer.exe process resumed properly Next open new instance OllyDbg attach EXPLORER.exe pr ocess Advanced artefact alysis October 2015 72 After attaching EXPLORER.exe override EB EF bytes entry point described p revious section original bytes E8 C2 Debug - > Execute till user code Alt+K funct ion To reach payload put breakpoint OpenFileMappingA resume execution F9 After reaching OpenFileMappingA breakpoint step F8 till user code choose Debug - > Execute till user code Alt+F9 You land PUSH E BX instruction Advanced artefact analysis October 2015 73 To reach final payload step F8 return instruction RETN Now create Advanced artefact analysis October 2015 74 6 Introduction scripting Decoding hidden strings Tinba This exercise start previous exercise ended If necessary restore snapshot named Tinba created reached main Tinba payload Step F7 first call instruction Next step seventh call instruction F7 Take look first call instruction S tep call F7 You land another call instruction followed second call LoadLibraryA If scrolled disassembly window code would desynchronize Advanced artefact analysis Oct ober 2015 75 Now follow dump arg3 And step F8 call Take look memory dump To use OllyScript create script.osc file following code var base var labels checking memory base Tinba payload gmemi eip MEMORYBASE mov base $ RESULT allocating memory results alloc 1000 mov labels $ RESULT printing header information eval '' Memory base 0x { base } '' log '' -- -- -- -- -- -- -- '' log '' Searching encoded strings '' log $ RESULT '' '' log '' -- -- -- -- -- -- -- '' Advanced artefact analysis October 2015 76 search_loop searching byte pattern find base # 50874424046A ? ? # cmp $ RESULT,0 je end_loop mov base $ RESULT mov push_addr base+5 mov call_addr base+7 mov data_addr base+12 finding data length gopi push_addr,1 DATA mov len $ RESULT finding decode routine address gci call_addr DESTINATION gci $ RESULT DESTINATION mov decode_addr $ RESULT executing decode routine exec pushad push { labels } push { len } push { data_addr } call { decode_addr } popad ende gstr labels mov string $ RESULT fill labels len 0 printing result eval '' { data_addr } { len } bytes - > { string } '' log $ RESULT '' '' add base,7 jmp search_loop end_loop log '' -- -- -- -- -- -- -- '' free labels pause To use script first make sure followed API call Then open ODbgScript Script Window Log Window Advanced artefact analysis October 2015 77 Next load script.osc Script Window right - click ing choosing Load Script - > Open When script loaded press < space > resume script execution right - click script context menu choose Resume At time take look Script Log Window decoded strings printed Advanced artefact analysis October 2015 78 Now know encoded strings typical string analysis guess Tinba functionality For example strings list find trings data_before data_end data_inject data_after tell Tinba using webinjects technique known banking trojans Each printed line following message format { address } { data_length } - > { decoded_string } Where { ddress } address decoding instructions found This mean use printed messages localize part code string used Additionally could create advanced script would decode strings also rewrite Tinba code way would reference already decoded strings instead decoding runtime ENISA European Union Agency Network Information Security Science Technology Park Crete ITE Vassilika Vouton 700 13 Heraklion Greece Athens Office 1 Vass Sofias & Meg Alexandrou Marousi 151 24 Athens Greece Catalogue Number IF APPLICABLE PO Box 1309 710 01 Heraklion Greece Tel +30 28 14 40 9710 info @ enisa.europa.eu www.enisa.europa.eu ISBN xxxxxxxxx DOI xx.xxxx/xxxxx REMOVE If applicable www.enisa.europa.eu European Union Agency For Network And Information Security Advanced dynamic analysis HANDBOOK DOCUMENT F OR TEACHERS OCTOBER 2015 Advanced artefact analysis October 2015 02 About ENISA The European Union Agency Network Information Security ENISA centre network information security expertise ENISA works groups develop advice recommendations good practice information security It assists EU member states implementing relevant EU legislation works improve expertise EU member states supporting development cross - border communities committed improving network information secu rity throughout EU More information ENISA work found www.enisa.europa.eu Authors This document created Yonas Leguesse Christos Sidiropoulos Kaarel Jõgi Lauri Palkmets consultation ComCERT 1 Poland S - CURE 2 The Netherlands DFN - CERT Services Germany Contact For contacting authors please use cert - relations @ enisa.europa.eu For dia enquiries paper please use press @ enisa.europa.eu Acknowledgements Darko Perhoc 1 2 Don Stikvoort Michael Potter Legal notice Notice must taken publication represents views interpretations authors editors unless stated otherwise This publication construed legal action ENISA ENISA bodies unless adopted pursuant Regulation EU No 526/2013 This publication necessarily represent state - - art ENISA may update time time Third - party sources quoted appropriate ENISA responsible fo r content external sources including external websites referenced publication This publication intended information purposes It must accessible free charge Neither E NISA person acting behalf respon sible use might made information contained publication Copyright Notice © European Union Agency Network In formation Security ENISA 2015 Reproduction authorised provided source acknowledged Advanced artefact analysis October 2015 03 Table Co ntents 1 Training introduction 5 2 Introduction OllyDbg 6 OllyDbg interface 6 B asic debugging code navigation 15 Breakpoints 22 Execution flow manipulation 29 Plugins 32 Shortcuts 34 3 Unpacking artefacts 36 Packers protectors 36 3.1.1 Introduction packers protectors 36 3.1.2 Unpacking steps 37 3.1.3 Finding OEP 37 Unpacking UPX packed sample 38 Unpacking UPX ESP trick 48 Unpacking Dyre sample 52 4 Anti - debugging techniques 63 Anti - debugging anti - analysis techniques 63 Dyre - basic patching OllyDbg 65 5 Process creation injection 70 Process injection process hollowing 70 Following child processes Tinba banking trojan 70 5.2.1 First stage 71 5.2.2 Second stage 80 6 Introduction scripting 87 Introduction OllyDbg scripting 87 Decoding hidden strings Tinba 88 7 Summary 95 Advanced artefa ct analysis October 2015 04 Main Objective The aim training present methods techniques dynamic artefact analysis use OllyDbg 3 debugger package Trainees following code execution unpack artefact using efficient ethods In addition tracing malic ious code execution During process trainees learn counter anti - analysis techniques implemented malware authors In second part trainees study various code injection techniques debug hollowed processes At end training presented automate debugging process The training performed using Microsoft Windows operating system Targeted Audience CSIRT staff involved technical analysis incidents especially dealing sample examination malware analysis Prior knowledge assembly language operating systems internals highly recommended Total Duration 8 - 1 0 hours Frequency Once team member 3 OllyDbg http //www.ollydbg.de/ last accessed 11.09.2015 Advanced artefact analysis October 2015 05 1 Training introduction In training learn practical elements dvanced dynamic analysis debugging malicious code Using debugger analyse artefact helps understand malicious code operates gives detail behavioural analysis Moreover original sample packed unpack first help debugger f necessary proceeding static analysis This training begins introduction OllyDbg debugger v1.10 4 used throughout later exercises In second part learn packers protectors use debugger unpack binary samples I n third part learn various anti - debugging anti - analysis techniques You also present ed perform basic code patching using sample Dyre malware 5 The f ourth part teaches various code injection techniques debug hollowed processes Finally training ends short introduction debugging automati ation using OllyDbg scripting capabilities Except introductory part samples used training live malware samples Consequently anal yses done dedicated isolated environments After analysis clean virtual machine snapshot restored instructed otherwise An I nternet connection needed complete training When debugging malicious code ccidental click might lead uninterrupted code execution result might need repeat entire exercise To prevent advisable take snapshots virtual machines analysing major code parts taking breaks This way even something goes entire process w ill need restore last snapshot 4 OllyDbg http //www.ollydbg.de/ last accessed 11.09.2015 5 Dyre Emerging threat financial fraud landscape http //www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/dyre - emerging - threat.pdf last accessed 19.10.2015 Advanced artefact analysis October 2015 06 2 Introduction OllyDbg In part introduced OllyDbg 6 interface basic usage This wil l make ready complete rest exercises Advanced Dynamic Analysis training Y ou learn How use different views OllyDbg How navigate code Different methods tracing executed instructions How create differen types breakpoints How manipulate execution flow debugged program How use plugins OllyDbg You use PuTT Y executable 7 commonly used Secure Shell SSH client worry accidentally executi terminates execute without problems OllyDbg interface First open OllyD bg debugger Make sure run Administrator If using Windows virtual machine prepared way Building artefact handling analysis environment 8 training also access OllyDbg using context menu 6 OllyDbg http //www.ollydbg.de/ last accessed 11.09.2015 7 PuTTY A Free Telnet/SSH Client http //www.chiark.greenend.org.uk/~sgtatham/putty/ last accessed 11.09.2015 8 Building artefact handling analysis environment https //www.enisa.europa.eu/activities/cert/training /training - resources/technical - operational # building last accessed 11.09.2015 Advanced artefact analysis Octo ber 2015 07 Now see OllyDbg interface T two ways start debugging process First ly attach already running process To choose File - > Attach choose process interest After attaching running process OllyDbg automatically break ntdll.DbgBreakPoint function Advanced artefact analysis October 2015 08 The econd way open executable file using standard File - > Open menu This way OllyDbg create new child process debugged application debuggee stop entry point executable default For example open putty.exe binary OllyDbg After OllyDbg fin ish initial analysis Advanced artefact analysis October 2015 09 The Central part OllyDbg CPU window This window use often analysis It consist five separate subpanels disassembly view registers info rmation panel memory dump stack panel Disassemb ly view 4 presents listing disassembled code It consists four columns The l eftmost column shows instruction address second column contains hexadecimal representation instruction machine code third column contains assembly instruction finally fourth column sued present comments additional information Registers view 5 presents current state CPU registers currently selected thread Information panel 6 used present additional information instruction selected disassembly view e.g operati result registers values Memory dump 7 presents dump chosen memory region Beside hexadecimal choose data presentation formats right - clicking memory dump panel choosing required data repre sentation context menu Advanced artefact analysis October 2015 10 T ake time check data representations At end restore default format Hex - > Hex/ASCII 16 bytes Finally stack panel 8 presents sta ck state currently selected thread The f irst column shows memory address second column contains value stored given stack address Notice stack grows upward direc tion f lower memory addresses Beside CPU window OllyDbg offers windows used different purposes All w indows accessed windows buttons toolbar View menu Advanced artefact analysis October 2015 11 T frequently used windows Executable modules Memory map Threads Handles Call stack Breakpoints The Executable modules window present executable modules loaded address space debugged process Usually would module executed binary modules loaded DLL libraries You double - click modules immediately jump module disassembly view You also right - click modules access context menu additional operations For example right - click msvcrt cho ose View names presented list names defined msvcrt library imports exports Advanced artefact analysis October 2015 12 Memory map window presents memory structure allocated memory regions address space debugged process It useful track memory allocation operations done malicious code Similarly previous example right - click memory region access context menu additional operations dumping memory searching memory changing access rights freeing memory etc For example sometimes useful open additional dump window dump given memory region To double - click memory region select choose Dump option context menu Another operation might try searching memory regions particular string byte pattern Let say know somewhere memory string wrong passphrase present exact address memory regi located To solve problem right - click anywhere memory map choose Search Ctrl+B context menu In new window type click Ok Advanced artefact analysis October 2015 13 If string found OllyDbg open new Dump window position set string Here see string found virtual address 0x4676BC belongs memory region 0x45D000 - 0x479FFF putty .rdata To keep searching occurrences string memory region click Dump window make active keep pressing Ctrl+L When occurrences OllyDbg signal mess age bottom window To continue searching string memory regions go back M emory map window make active kee p pressing Ctrl+L If occurrences OllyDbg signal message bottom window Threads window shows threads current process If process one thread double - click ing thread would switch context thread Advanced artefact analysis October 2015 14 Handles window show windows opened process handles additional information regarding handle type value name This window may useful e xample see API call referring Finally c stack window shows function calls made current instruction current thread This useful checking function current instruction belong function called Note screenshot present Call stack window process execution two calls made I f open Call stack window ent ry point empty One useful OllyDbg features highlighting elements changed A g ood example highlighting newly allocated memory blocks newly loaded modules To present open Executable odules window If red coloured elements window right - click choose Actualize Advanced artefact analysis October 2015 15 Next right - click anywhere window choose Insert module context menu operation available Olly Advanced plugin In Open dialog choose c \ Windows \ System32 \ wininet.dll This way OllyDbg load additional module address space currently debugged process Loading extra modules sometimes useful advanced debugging want load DLL wit h yo ur custom code Now newly loaded modules marked red font Executable modules window Notice beside wininet module couple DLLs loaded Those DLLs required wininet The rule red - colo u ring new elements applies also Memory map various views OllyDbg In general useful tracking places code new modules loaded new memory allocated Basic debugging c ode navigation Start loading putty.exe sample described previous exercise Each debugged process one following states paused running terminated tracing animating Paused program execution paused instructions executed Ru nning program freely running debugger tracing execution Terminated debugged process terminated T r acing instruction tracing started executed instruction logged Animating instruction animation started The c urrent state debugged process read upper left corner OllyDbg window When proc ess paused current position instruction pointer indicated b lack square disassembly view value EIP register Advanced artefact analysis October 2015 16 Whenever get lost double - click EIP register value instantaneously moved current position code Remember program multiple threads current position likely different thread When debugging program spend time analysing disassembled instructions step - - step There two modes instruction stepping Step F7 executes current instruction moves program execution next instruction If current instruction function call debugger steps call starts stepping instructions called function Step F8 behaves Step except current instruction function call I f want let program run freely choose Run F9 In result PuTTY create main window present user If want pause program execution press F12 Debug - > Pause staying OllyDbg You also restart executable pressing Ctrl+F2 Debug - > Restart Other useful debug operations Run selection F4 causes OllyDbg resume execution selected instruction Execute till return Ctrl+F9 executes program return current function Execute till user code Alt+F9 executes program user code Debugging actions also accessed th e toolbar top OllyDbg Advanced artefact analysis October 2015 17 If want quickly pre - view execution flow program find loops check jumps taken etc might decide use instruction trace instruction animation functions Both functions come two forms Trace into/Trace Animate into/Animate To see instruction animation works restart PuTTY sample Debug - > Reset choose Debug - > Animate Ctrl+F8 Observe happens disassembly window You see short animation executed instructions fter moments PuTTY main window appear Close PuTTY reset sample Now choose Debug - > Animate This time instead stepping animation step function call inclu ding API calls You pen Call stack Alt+K window observe called functions real time Animate function usually takes time program finishes execution To stop use Pause F12 function Advanced artefact analysis October 2015 18 Next restart sample choose Debug - > Set condition In dialog set conditions long Run trace function running conditions set would also work animate function If set one condition run trace run ning one conditions met It important note condition met inside body called function using Trace function work For example set following two conditions This would ke instruction tracing stop either execution moves outside memory range 0x400000 - 0x500000 current command would call eax call edi Now open Run trace window View - > Run trace choose Debug - > Trace Execution hould soon stop call edi instruction This would also indicated OllyDbg status bar bottom left corner Advanced artefact analysis October 2015 19 Notice execution ped condition EIP register outside given memory range even though API calls already made code This used Trace function API calls stepped If used Trace function execution would stop first API call Now take look Run trace window It contains executed instruction information instruction address thread modified registers The l ast executed instruction bottom window If would like run trace logged file right - click Run trace window choose Log file option context menu executing Run trace function At point know basic debugging operations funct ions The n ext important thing learn navigate code First restart PuTTY sa mple Whenever see call jump instruction follow without executing clicking instruction pressing < Enter > In thi example follow call putty.004545A0 You land function b ody You jump instructions One drawbacks following calls jumps OllyDbg lack Go back follow jumps calls easy way going back previous position way IDA Pro IDA Free 9 allows You need remember code followed use Bookmarks plugin learn plugins later part exercise 9 Freeware version IDA v5.0 https //www.hex - rays.com/products/ida/support/download_freewa re.shtml last accessed 11.09.2015 Advanced artefact analysis October 2015 20 Another way navigating code using Go expression feature It used change current position disassembly view memory dump stack view depending view active Click di sassembly view press Ctrl+G Type eip moved current location code pointed EIP register In Enter expression follow dialog enter wide range expressions registers eax ebx ecx memory addresses 0x401000 arithmetic expressions 0x400000+2*0x1002 eax+0x1000 API functions names CreateFileA WriteProcessMemory Labels names used program If entered expression invalid destination address address space debu gged process see proper error message Additionally want find address certain API function module function located loaded yet loaded runtime going called also see error message Unknown identifier Another often used way code navigation OllyDbg context menus You click various values OllyDbg register values immediate values stack stored values strings context menu often options like Follow Disassembler Follow Dump Follow Stack For example start clicking registers values If register points existing address address space current program following options Follow Disassembler Follow Dump Advanced artefact analysis October 2015 21 If register doe contain valid address register points location stack like case ESP reg ister option Follow Stack You ame values stored stack Advanced artefact analysis October 2015 22 Breakpoints Breakpoints crucial part debugger They allow stop program execution chosen moment allowing user analyse specific program function There four types breakpoints OllyDbg 10 Software breakpoints INT 3 breakpoints Hardware breakpoints Memory breakpoints Guarded pages Software breakpoints work inserting INT 3 11 instruction place I nstruction breakpoint set When instruction executed interrupt raised debugger steps The entire process transparent user Setting software breakpoints actually modifies memory f debugged process Thus debugged process calculate checksum code might different expected So malicious code use one anti - debugging techniques detect debugged To set software breakpoint double - click second column next instruction select instruction press F2 When breakpoint set indicated red background instruction address Now press F9 run program stop execution instruction executing To remove breakpoint repeat steps setting You view list software breakpoints Breakpoints window 10 http //www.ollydbg.de/Help/i_Breakpoints.htm last accessed 11.09.2015 11 The INT 3 instruction defined use debuggers temporarily replace ins truction running program order set breakpoint https //en.wikipedia.org/wiki/INT_ x86_instruction last accessed 11.09.2015 Advanced artefact analysis October 2015 23 You also use window remove temp orarily disable chosen breakpoints One way using breakpoints set API functions This allows detect certain API function called malicious code used detect various operations done malware For example interested communication C & C servers good idea set breakpoints network related functions And suspect process injecting code processes might set breakpoints functions WriteProcessM emory CreateRemoteThread Now set breakpoint ShellExecuteA function First click disassembly view use Go expression Ctrl+G find address ShellExecuteA Then set breakpoint first instruction ShellExecuteA one moved If PuTTY process paused resume execution F9 Next PuTTY window click About button Visit Web Site button Advanced artefact analysis October 2015 24 Now go back OllyDbg OllyDbg break call ShellExecuteA previously set breakpoint Take look stack view see arguments passed ShellExecuteA As see clicking Visit Web Site PuTTY tries open http address http //www.chiark.greenend.org.uk/~sgtatham/putty/ default system web browser You also open call stack window View - > Call stack Clt+K check ShellExecuteA funct ion called Advanced artefact analysis October 2015 25 The econd type break points hardware breakpoints In general instead changing program instructions memory software breakpoints use special processor registers debug registers On x86 architecture four debug registers DR0 - DR3 used store linear address breakpoints Thus possible set four hardware breakpoints time Additionally contrast software breakpoints hardware breakpoints also used break memory read write operations Hardware breakpoints usually used want detect certain memory ddress written k malicious code trying detect software breakpoints To get information difference software hardware breakpoints refer Debugger flow control 12 13 articles Ken Johnson see set hardware breakpoints go OllyDbg restart PuTTY sample Next step instruction 0x 454AF9 As see dword value written memory address 0x47E140 want check place code value used Right - click instruction context menu choose Follow n Dump - > Memory address 12 Debugger flow control Hardware breakpoints vs software breakpoints http //www.nynaeve.net/ ? p=80 last accessed 11.09.2015 13 Debugger flow control More breakpoints part 2 http //www.nynaeve.net/ ? p=81 last accessed 11.09.2015 Advanced artefact analysis October 2015 26 Now Memory Dump view centred 0x47E140 address Select first 4 bytes dword right - click From context menu choose Breakpoint - > Hardware access - > Dword Now place code memory address would accessed hardware breakpoint hit program execution paused To view currently set hardware breakpoints choose Debug - > Hardware breakpoints You use window follow memory address hardware b reakpoint set delete breakpoint After setting hardware breakpoint 0x47E140 resume program execution F9 Advanced artefact analysis October 2015 27 Almost immediatel program break As message status bar shows hardware breakpoint 1 hit EIP points one instruction 0x47E140 address accessed Scroll disas sembly view one line see nstruction accessing 0x47E140 You remove hardware breakpoint automatically removed sample reload Hardware breakpoints used instead software breakpoints instruction stepping tracing To configure go Options - Debugging options - > Debug Use hardware breakpoints ste p trace code select option right however since remaining part training software breakpoi nts used ! The hird type breakpoints memory breakpoints They used detect memory read write operations Th ey set memory pages possible set byte word dword memory range This makes less accurate hardware breakpoints contrast hardware breakpoints number memory breakpoints limited Ty pical usage memory breakpoints detection read write operations large memory block example newly allocated memory You set memory breakpoint similar manner hardware breakpoints selecting data Memory Dump vi ew choosing Breakpoint - > Memory Advanced artefact analysis October 2015 28 The econd way creating memory breakpoint using Memory map window Restart PuTTY sample open Memory map window right - click context menu choose Set memory breakpoint access Now code tries access data .resource section breakpoint would hit Next resume program F9 The b reakpoint hit someplace system code If check Call stack window see breakpoint hit call CreateDialogParamA FindResourceExA called Advanced artefact analysis October 2015 29 To remove memory breakpoint go Memory map window right - click memory region memory breakpoint set se lect Remove memory breakpoint Execution flow manipulation Beside instruction stepping execution flow analysis debugging also allows change program actually executes I possible change almost aspect program execution OllyDbg allows overwrite executed instructions change registe rs values change FLAGS register well modify data stack memory address This might useful ov ercome anti - analysis technique check malicious code would behave circumstances However c ode register manipulation must done care otherwise may lead crash debugged program E xamples presented exercise intended present execution flow manipulation conducting meaningful change First restart PuTTY sample step unt il first jump instruction The r ed arrow next instruction tells jump made might different different system You force jump taken changing appropriate flag FLAGS register Advanced artefact analysis October 2015 30 JE jump equality taken whenever z ero flag Z set To change zero flag double - click value next made grey arrow You also change jump never made overwriting jump instruction NOP instructions To right - click jump instruction choose Binary - > Fill NOPs In similar way modifying FLAGS register also modify registers To right - click register value choose Modify Advanced artefact analysis October 2015 31 Values stack modified well This time however two options Modify Edit The difference Modify treats stack values numbers Edit treats stack values group bytes Advanced artefact analysis October 2015 32 Besides modifying registers data memory also possible change instructions executed To achieve select instruction w ant modify press < space > This way edit instruction operands replace instruction completely di fferent one However note new instruction code would longer code instruction editing structions code would also affected I f new instruction code would shorter remaining bytes would filled NOP instructions Plugins One important aspect OllyDbg plugins OllyDbg big plugin base contributed many authors Plugins mainly used introduce new features make debugging easier imp lement anti - anti - debugging techniques preventing OllyDbg detected Most popular plugins downloaded following websites Collaborative RCE Tool Library 14 Tuts 4 You 15 OpenRCE.org 16 14 OllyDbg Extensions http //www.woodmann.com/collaborative/tools/index.php/Category OllyDbg_Extensions last accessed 11.09.2015 15 OllyDbg 1.xx Plugins https //tuts4you.com/download.php ? list.9 last accessed 11.09.2015 16 OpenRCE Hosted Downloads OllyDbg Plugins http //www.openrce.org/downloads/browse/OllyDbg_Plugins last accessed 11.09.2015 Advanced artefact analysis October 2015 33 After downloading plugin unpack copy c \ tools \ Portable version \ Olly_110 \ Plugins The e xact location plugins directory checked Options - > Appearance - > Directories menu After plugin instal lation restart OllyDbg If plugin working available plugins menu Advanced artefact analysis October 2015 34 Note plugins created OllyDbg v1.10 compatible OllyDbg 2.xx vice versa There many useful plugins OllyDbg mostly preference use Among plugins used training adp4olly - tries hide OllyDbg popular anti - debugger techniques Olly Advanced fixes bugs OllyDbg v1.10 introduces new functions enhancing OllyDbg capabilities It also implements various anti - anti - debugging techniques ODbgScript introduces scripting assembly - like language allowing automate certain tasks OllyDumpEx memory PE dumping p lugin It allows dump PE image memory file Frequently used dumping unpacked binaries Bookmarks allows insert bookmarks code help quickly navigate later Shortcuts Shortcuts essential part OllyDbg Tha nks shortcuts perform many operations much faster saving valuable time This section lists com monly used shortcuts OllyDbg Debugging OPERATION SHORTCUT Run F9 Pause F12 Restart debugged app Ctrl+F2 Close debugged app Alt+F2 Step F7 Step F8 Execute till return Ctrl+F9 Execute till user code Alt+F9 Pass exception program Shift+F7/F8/F9 Advanced rtefact analysis October 2015 35 Animate Ctrl+F7 Animate Ctrl+F8 Trace Ctrl+F11 Trace Ctrl+F12 Windows views OPERATION SHORTCUT CPU window Alt+C Memory map Alt+M Executable modules Alt+E Call stack Alt+K Breakpoints Alt+B Other operations OPERATION SHORTCUT Follow jump/call Enter Assembly instruction Space Edit memory Ctrl+E Add comment semicolon Add label colon Insert bookmark X Alt+Shift+0..9 Go bookmark X Alt+0..9 Advanced artefact analysis October 2015 36 3 Unpacking artefact Packers protectors 3.1.1 Introduction packers protectors P acker tool used obfuscate executables usually malware rewriting code The r esulting code usually completely different original code impossible analys e prior unpacking After execution packed binary code unpacked runtime original form original code starts executing like never packed Packers serious problem IT security industry one malware code packed obfuscated many times time resulting seemingly completely different code This makes si gnature based AV en gines much less effective Moreover since packer works differently single unpacking algorithm Sometimes ou might encounter names protector crypter They often used interchangeably name packer describe type tool Using strict definitions packer tool compresses binary code making smaller protector adds binary additional protection layer anti - emulatio n anti - debugging anti - sandbox crypter encrypts original binary code U sually one tool implements functions one For convenience term packer used document The cheme presents simplified version packers work The c ode packed binary usually completely different code original binary Packed code often block highly compressed encrypted data high entropy For obvious reasons execution data impossible T packer also needs add binary unpacking stub The u npacking stub special code sole role unpack rebuild original binary memory After execution packed Advanced artefact analysis October 2015 37 binary unpacking stub starts unpacking code When unpacking finished import address table IAT rebuilt execution transferred Original Entry Point OEP When malware analysis behavioural automatic analysis necessary first unpack original code To detect sample packed packer used might use tools PEiD 17 ExeInfo PE 18 If packer used pack ample well known tools return name You sear ch automatic unpacking tool particular packer 19 Remember always use unpacking tools isolated environment 3.1.2 Unpacking steps If automatic unpacking tool sample needs unpacked manually using debugger In general single strategy algorithm unpack binary file Each packer protector slightly different n eeds handled differently There three stages unpacking binary file 1 Finding OEP 2 Dumping process image 3 Rebuilding IAT fixing EP When unpacking stub starts executing jump original entry point point Finding OEP first often difficult task trying unpack malware There techniques might help finding OEP presented next section After OEP found need dump memory unpacked image original executable Sometimes packer might utilize anti - dumping techniques 20 however part training The l ast step rebuild Import Address Table IAT fix Entry Point EP address executable This necessary packers usually modify PE headers obfuscating original code A modified IAT table often limited important entries EP points unpacking stub code How perform se steps presented later training 3.1.3 Finding OEP There techniques help recognize find OEP Unpacking stub often finish indirect jump call address stored register example j mp eax call eax I f see instruction code consider might jump OEP especially instruction one last instructions unpacking routine Unpacking stub often located PE file section rather co de section Sometimes unpacking stubs also copied newly allocated memory block outside original PE image 17 Binary Analysis Editing https //tuts4you com/download.php ? view.398 last accessed 11.09.2015 18 ExeInfo PE http //www.woodmann.com/collaborative/tools/index.php/ExeInfo_PE last accessed 11.09.2015 19 http //www.woodmann.com/collaborative/tools/index.php/Category Automated_Unpackers last accessed 11.09.2015 20 Anti - Memory Dumping Techniques http //resources.infosecinstitute.com/anti - memory - dumping - techniques/ last accessed 11.09.2015 Advanced artefact alysis October 2015 38 Therefore unpacking see jump code section consider might jump OEP address When unpacking code section usually overwritten new code You use memory breakpoints write detect unpacking loop Then unpacking finishes try using memory breakpoints access detect moment execution transfer unpacked code B efore unpacking finishes program stack reg isters often restored initial state If see behaviour unpacking routine might mean soon jump OEP Compilers usually produce similar entry point code created executable Knowing entry point code produced various compilers look like help recognize OEP packed sample Many Windows applications beginning main routine call functions GetCommandLine GetModuleHandle GetStartupInfo GetVersion GetVersionEx If see calls code might mean already reached OEP Additionally one unpacking strategies might put breakpoints functions hoping called beginning main routine Unpacking UPX packed sample UPX 21 fairly simple commonly used packer Samples ha packed UPX easily unpacked using publicly available tools exercise shown manually unpack UPX packed sample putty.exe show general concept unpacking artefact manually As initial step packed code needs detected similarly steps Artefact 22 PEiD 23 used identify sample packed packer used In sample packed In situations chec ks manual assessment may needed example checking embedded strings inspecting IAT table inspecting list sections Artefact In case PEi D reveals putty_upx.exe sample packed UPX seen following screenshot 21 UPX http //upx.sourceforge.net last accessed 11.09.2015 22 Artefact Analysis Fundamentals https //www.enisa.europa.eu/activities/cert/training/tra ining - resources/documents/artifact - analysis - fundamentals - handbook last accessed 11.09.2015 23 PeiD http //www.aldeid.com/wiki/PEiD last accessed 11.09.2015 Advanced artefact analysis October 2015 39 To confirm output PEiD identify packing specifically CFF Explorer 24 used CFF Explorer designed make PE editing easy possible Beside PE headers viewing editing CFF Explorer contains integrated hex editor simple disassembler many useful features One distinct feature UPX packed samples two sections UPX0 UPX1 within PE fi le seen screenshot section headers part Please note Virtual Addresses sections 25 referred later exercise Now know sample wa packed UPX forward towards anual unpac king To sample opened OllyDbg OllyDbg report sample looks like compressed packed 24 CFF Explorer suite http //www.ntcore.com/exsuite.php last accessed 11.09.2015 25 Actually CFF Explorer presents Relative Virtual Addresses RVA Virtual Address column sections list To get actual Virtual Addresses sections ad module base address 0x4000000 use Advanced artefact analysis October 2015 40 Execution executable paused entry point putty_upx.exe 0x48CD50 located UPX1 section In order reach beginning unpacking routine step function Shortcut key F8 five times MOV EBX DWORD PTR DS ESI instruction address 0x48CD6A At instruction code read memory pointed ESI register Take look ESI source EDI destination registries ESI points beginning UPX1 section EDI points beginning UPX0 refer previously checked Virtual Addresses CFF Explorer This suggests data read UPX1 processed finally written UPX0 To see packed code follow hex dump Ctrl+G ESI register Advanced artefact analysis Oct ober 2015 41 Then follow hex dump EDI register see clean memory u npacked code stored Then press hold seconds Step Over key F8 You observe hex dump UPX0 section pointed EDI overwritten u npacked code Now scroll numerous jump instructions see three CALL instructions addresses 0x48CE8A 0x48CEA8 0x48CEB9 Set breakpoints instructions inspect functions called Resume execution F9 At point unpacking routine rebuilding original Import Address Tab le IAT executable It done loading necessary libraries resolving addresses used functions storing memory Put breakpoint 0x48CEBF outs ide IAT reconstruction loop press F9 times 5 - 10 In stack window observe functions loaded Advanced artefact analysis October 2015 42 Take look resolved functions addresses stored After call GetProcAddress result checked non - zero OR EAX EAX written address pointed EBX register MOV DWORD PTR DS EBX EAX Follow EBX register hex dump Now remove breakpoints except breakpoint outside IAT reconstruction loop 0x48CEBF resum e execution F9 let IAT reconstruction finish A emory region pointed EBX filled addresses resolved functions It c haracteristic IAT table many addresses start 0x75 0x76 0x77 This system libr aries usually loaded address range At point might handy change hex dump view type ddress v iew list functions names hinted OllyDbg To right - click hex dump context menu choose Long Address Advanced artefact analysis October 2015 43 Next scroll assembly code characteristical JMP instruction 0x48CEFC Such uncoditional jump instructions end unpacking routine often leads OEP thus always worth inspecting keep mind way jumping OEP Put breakpoint instruction resume execution F9 Advanced artefact analysis October 2015 44 After reaching breakp int JMP instruction single step F7/F8 land OEP In case recognize OEP calls functions GetVersionExA GetModuleHandleA Remember address OEP 0x459FE0 needed later Now original unpacked putty.exe code stored memory In previous steps observed unpacking routine converting packed code original form Im port Address Table rebuilt In next step dump unpacked process image exe cutable file To achieve use OllyDumpEx plugin allows dump process image memory executable file PE format When dumping unpacked putty.exe code use default OllyDumpEx settings Save dumped process dump.exe close OllyDbg yet Advanced artefact analysis October 2015 45 Now would try execute dump.exe see Application Error dump.exe IAT reconstructed To reconstruct IAT use ImpREC 26 tool Run ImpREC Administrator th e scroll menu top wind ow choose putty_upx.exe process 26 ImpREC http //www.woodmann.com/collaborative/tools/index.php/ImpREC last accessed 10.10.2015 Advanced artefact analysis October 2015 46 Next IAT Infos needed RVA address OEP OEP address minus Image Base address case 0x459FE0 - 0x400000=0x59FE0 IAT AutoSearch IAT found see p propriate message box Otherwise might need try manually enter RVA Size IAT Advanced artefact analysis October 2015 47 Next click Get Imports Advanced artefact analysis October 2015 48 Show Invalid Fix Dump select dump.exe file If everything goes right see message dump_.exe saved successfully please note underscore name file name You try run dump_.exe check runs Unpacking UPX ESP trick The manual unpacking UPX sample p resented previous section intended educational purposes In situations interested following step unpacking routine want find OEP quickest way possible unless anti - analysis anti - debugging techniques used code preventing us reachi ng OEP In exercise use simple ESP trick allow us quickly track address original entry point UPX packed sample Many packers try preserve state stack registers start execution restore jumping OEP This way r eaching OEP application sees stack registers never packed One way achieving push content registers using PUSHAD instruction beginning unpacking stub restore j ump OEP You track putting hardware breakpoint stack memory containing saved registers waiting till memory accessed First previous exercise open putty_upx.exe OllyDbg Advanced artefact analysis October 2015 49 S tep PUSHAD instruction Shortcut key F8 Notice stack view ESP register changes seen following screenshot Follow ESP register hex dump put hardware breakpoint access memory region pointed register Advanced artefact analysis October 2015 50 Next resume execution F9 immediately land jump OEP Advanced artefact analysis October 2015 51 Remove hardware breakpoint Debug - > Hardware breakpoints Delete Advanced artefact analysis October 2015 52 Now put breakpoint JMP instruction 0x48CEFC resume execution F9 reach Step JMP instruction F8 land OEP In next step would need dump unpacked process reconstruct IAT table way described previ ous exercise Since already done previous exercise necessary In exercise seen always necessary exact ly follow unpacking routine various situations simple tricks used reach OEP In case used ESP trick track point jump original entry point While UPX fairly easy packer trick task significantly ore complex packers still use trick making unpacking task easier Unpacking Dyre sample In exercise unpacking Dyre 27 malware presented Dyre banking trojan packed using complex packer UPX Since live malware sample run controlled virtual environment analysis restore clean snaps hot virtual machine It also advisable forbid network access working Dyre Open file called voiyhabs.exe OllyDbg You see entry point Put breakpoint ZwAllocateVirtualMemory described introduction OllyDbg This allow us track memory allocation operations Packers often allocate new memory blocks put unpacked code unpacking stub 27 Dyre Emerging threat financial fraud landscape http //www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/dyre - emerging - threat.pdf last accessed 19.10.2015 Advanced artefact analysis October 2015 53 Now open Call stack window View - > Call Stack Alt+K press resume execution F9 times see call HeapCreate flags set 0x40000 HEAP_CREATE_ENABLE_EXECUTE 28 symbolic constant 0x 40000 meaning memory blocks heap allow code execution This suggests heap used store unpacking stub executable code Remove breakpoint ZwAllocateVirtualMemory show calling location HeapCreate voiyhabs module Put breakpoint instruction HeapCreate call resume execution F9 Write address newly created heap returned EAX register 0xDE0000 example migh different 28 HeapCreate function https //msdn.microsoft.com/en - us/library/windows/desktop/aa366599 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 Advanced artefact analysis October 2015 54 Remove previously set breakpoint 0x40144D scroll see call RegisterClassEx function 0x4018DE Put breakpoint function resume execution F9 Next check address window procedure registered window class Hiding code window procedure common technique used malware hinder analysis change execution flow If window procedure points existing add ress good put breakpoint address The w indow procedure address passed third field WndClassEx structure lpfnWndProc preceded two INT values This means address third DWORD value WndClassEx structu typedef struct tagWNDCLASSEX { UINT cbSize UINT style WNDPROC lpfnWndProc int cbClsExtra int cbWndExtra HINSTANCE hInstance HICON hIcon HCURSOR hCursor HBRUSH hbrBackground LPCTSTR lpszMenuName LPCTSTR lpszClassName HICON hIconSm } WNDCLASSEX *PWNDCLASSEX Address WndClassEx structure put first argument onto stack Follow dump Advanced artefact analysis October 2015 55 Now read address Window procedure hex dump remembering addresses written little - endian notation In case Window procedure address 0x02100210 Next try follow address assembly window If land existing code sec tion put breakpoint address To go back current location follow EIP register Next scroll call EnumDisplayMonitors function Put breakpoint call resume execution F9 alternatively select location use Run selection F4 BOOL EnumDisplayMonitors _In_ HDC hdc _In_ LPCRECT lprcClip _In_ MONITORENUMPROC lpfnEnum _In_ LPARAM dwData Check address enumeration procedure lpfnEnum stack third argument example 0xEDE688 Notice address points memory range previously created heap This suggests unpacking stub likely locat ed Advanced artefact analysis October 2015 56 Put breakpoint enumeration procedure assembly window go address enumeration procedure lpfnEnum toggle breakpoint address Resume execution F9 The e xecution break inside enumeration procedure Step F8 two times follow jump Scroll put breakpoint suspicious CALL EAX function return RETN As mentioned introduction single calls register function turn might indicate calls OEP important part code It jump OEP likely taking place call Resume execution F9 When hit breakpoint CALL EAX step F7 call You land another unpacking stub function Step F8 two times Now scroll group three calls function return At point already know jump OEP likely taking place one calls Put breakpoint first call resume execution F9 Advanced artefact analysis October 2015 57 After reaching breakpoint step first function call F7 You see several PUSH instructions followed call instruction When step F8 call instruction see call CreateThread function HANDLE W INAPI CreateThread _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes _In_ SIZE_T dwStackSize _In_ LPTHREAD_START_ROUTINE lpStartAddress _In_opt_ LPVOID lpParameter _In_ DWORD dwCreationFlags _Out_opt_ LPDWORD lpThreadId Now take look stack The hread routine passed third argument In example points 0xEE38AC Put breakpoint thread function lpStartAddress resume execution F9 Advanced artefact analysis October 2015 58 When breakpoint thread function hit step F8 call ECX As see ECX points memory .text section original executable voiyhabs.00403850 This good indicator yo u jumping OEP Step call F7 You land OEP written code Ol lyDbg analysed properly At p oint could proceed dump process reconstruct IAT sure OE P need tell OllyDbg interpret following fragment code disassemble properly Starting OEP address select group instructions Next right - click context menu Analysis - > During next analysis treat selection - > Command Advanced artefact analysis October 2015 59 Analysis - > Analyse code Advanced artefact analysis October 2015 60 Now clearly see likely OEP - typical function prologue EBP based stack frame followed later call GetModuleHandleA Moreover jumped code allocated memory block initial executable section another indicator original entry point Next dump process image recons truct IAT table To dump process use OllyDumpEx plugin described previously Advanced artefact analysis October 2015 61 Now try reconstruct Import Address Table RVA OEP 0x3850 using ImpRec This time might see invalid imports clicking Get Imports Show Invalid Right - click context menu choose Cut thunks After invalid pointers resolved use Fix dump fix dumped executable Advanced artefact analysis October 2015 62 In exercise unpacked executable real malware sample protected complex packer You achieved first tracking memory allocation operations following unpacking stub newly allocated heap It worth noting quickest method As goes packed executable many ways unpacking code reaching OEP Advanced rtefact analysis October 2015 63 4 Anti - debugging techniques Anti - debugging anti - analysis techniques malware analysts able analyse code As consequence use various anti - analysis techniques ke analysis hard possible You distinguish four groups anti - analysis techniques Anti - debug ging detect process debugged Anti - emulation anti - VM detect process running virtual machine emulated environment Anti - sandbox detects process executed well - known sandbox environment dedicated malware analysis Anti - disassembly makes disassemblers incorrectly disassemble code When debugging often would need cope anti - debugging anti - VM techniques W henever malicious code detects debugged running virtual machine might terminate run completely non - malicious code instead mislead analyst There plenty anti - debugging techniques 29 30 Most assigned one following categories API related techniques techniques use fact calls certain API functions would return different result depending whether application debugged Examples functions IsDebuggerPresent OutputDe bugString Checking flags certain flags set process debugged Examples flags NtGlobalFlag IsDebugged flag PEB Searching breakpoints poss ible process search breakpoints current address space This applies software hardware memory breakpoints Searching processes open windows popular debuggers analysis tools e.g Wireshark Regshot Process Explorer Time based checks malicious code check much time elapsed two different parts code If time delay big assumed application debugged Self - debugging clever anti - debugging techn ique malware starts debugging processes making analyst unable attach debugger This technique used Zero - Access trojan 31 29 - Debugging Reference http //pferrie.host22.com/pape rs/antidebug.pdf last accessed 11.09.2015 30 Anti - debugging Techniques Cheat Sheet http //antukh.com/blog/2015/01/19/malware - techniques - cheat - sheet/ last accessed 11.09.2015 31 ZeroAccess uses Self - Debugging https //blog.malwarebytes.org/intelligence/2013/07/zeroaccess - anti - debug - uses - debugger/ last accessed 11.09.2015 Advanced artefact analysis October 2015 64 Except trying detect debugger malicious code frequently also trying detect virtualization environment using subset following techniques 32 Detecting processes related virtualization software This e common techniques A alicious code iterates process list search processes like VBo xService.exe VBoxTray exe Searching VM arte facts registry filesystem strings referencing vbox vmware qemu Checking amount resources available system For example malicious code might check size hard disk assuming modern computers hard disk size least 80GB VMs frequently smaller disks Detecting hardware present system e.g VBOX HARDDISK Certain assembly instructions also behave differently virtua l ized system bare - metal O ne countermeasures anti - debugging use special plugins OllyDbg like aadp4olly 33 Olly Advanced 34 When using plugins need check anti - anti - debugging techniques used You accessing Plugins menu In general good idea use one plugin specific anti - debugging technique otherwise might lead unexpected behaviour I f certain es try different one The creenshot presents anti - anti - debugg ing options aadp4olly plugin 32 On Cutting Edge Thwarting Virtual Machine Detection http //handlers.sans.org/tliston/ThwartingVMDetection_Liston_Skoudis.pdf last accessed 11.09.2015 33 aadp4olly https //tuts4you.com/download.php ? view.3021 last accessed 11.09.2015 34 Olly Advanced https //tuts4you.com/download.php ? view.75 last acces sed 11.09.2015 Advanced artefact analysis October 2015 65 However even using plugins need still cautio us anti - VM techniques sophisticated anti - debugging techniques One way check malicious code using anti - VM anti - debu gging technique try run freely debugger using behavioural analysis techniques check malware behaves expected In typical scenario malware would create one child processes install somewhere system f inally generate network traffic communicate C & C server behaviour might mean malware detected debugger VM malware analysing behave way Dyre - basic patc hing OllyDbg A r ecent version Dyre trojan uses interesting anti - sandbox mechanism It checks number processor cores visible system 35 determines number cores less two stops execution Since modern systems run multi - execution poorly configured sandbox running virtual machines one CPU attached In exercise use previously unpacked Dyre sample patch allow code execution also one previous exercise something went wrong use unpacked_dyre.exe sample provided If virtual machine one CPU configured start Proces Explorer/Process Monitor try execute unpacked Dyre sample You observe sample quits almost immediately nothing much 35 Dyre http //www.seculert.com/blog/2015/04/new - dyre - version - evades - sandboxes.html last accessed 11.09.2015 Advanced artefact alysis October 2015 66 seems happening The creenshot shows Process Tree view created Process Monitor tool T ools - > Process tree Now open unpacked Dyre OllyDbg If step F8 times notice first jump instruction JB program jumping ExitProcess routine Advanced artefact analysis October 2015 67 If take closer look code befo jump notice Dyre checking number CPU cores pointed Process Environment Block PEB 36 The Process Environment Block special system structure containing various information running process It stored user space memory pointed FS segment I f value less two terminate process To patch behaviour click CMP instruction press space select Assemble context menu Replace 2 1 S elect modified commands context menu choose Copy executable - > All modifications Copy All dialog window 36 PEB - Process - Environment - Block http //www.aldeid.com/wiki/PEB - Process - Environment - Block last accessed 11.09.2015 Advanced artefact analysis October 2015 68 In new window context menu choose Save file save patched executable Now try running pat che executable observing behaviour Process Explorer Process Monitor process tree Advanced artefact analysis Oct ober 2015 69 If everything done correctly see Dyre process creating new child process uses significantly time This means successfully patched Dyre executable likely ant - analysis check preventing running anymore Advanced artefact analysis October 2015 70 5 Process creation injection Process injection process hollowing Modern malware frequently using form code injection processes Which ever technique used goal almost always disguise malicious code make analysis difficult Process replacement also known process hollowing 37 technique th e process image memory replaced new image containing malicious code U sually new process created suspended state using legitimate binary e.g explorer.exe notepad.exe Then memory overwritten malicious code new entry point set process resumed This way user see well - known processes malicious process found point initial malicious file legitimate binary create d. A ypical process hollowing scheme executed follow 1 Creation new process suspended state CreateProce ss CreateProcessInternal 2 Unmap p ing memory NtUnmapViewOfSection 3 Allocating memory new process VirtualAllocEx 4 Writing malicious code newly allocated memory WriteProcessMemory 5 Setting new entry point address main thread hollowed process GetThreadContext SetThreadContext 6 Resuming main thread hollow ed process ResumeThread Process injection - techniq ue malicious code injected already running process separate thread This way original process still work malicious code running time separate thr ead Most often malware injects code explorer.exe process always running Windows systems hardly ever terminated user There couple methods 38 inject code processes One frequently used methods using WriteProcessMemory CreateRemotheThread functions 1 Malicious code iterates process list find process injected CreateToolhelp32Snapshot Process32First Process32Next 2 Opening destination process handle OpenProcess 3 Allocating memory selected process address space VirtualAllocEx 4 Writing malicious code newly allocated memory WriteProcessMemory 5 Creating remote thread chosen process CreateRemoteThread Following child processes Tinba banking trojan In exercise follow child hollowed processes created Tinba loader till reach main Tinba payload The sample analys ed doc likwidacji _ doc_TK2015.exe g malware campaign 2015 37 Process Hollowing http //www.autosectoo ls.com/process - hollowing.pdf last accessed 11.09.2015 38 Three Ways Inject Your Code Another Process http //www.codeproject.com/Articles/4610/Three - Ways - - Inject - Your - Code - - Another - Proces last accessed 11.09.2015 Advanced artefact analysis October 2015 71 From results behavioural analysis known Tinba loader creating two child processes shortly execution The f irst one copy original loader executable second one EXPLORER.exe process Please note contrast malware existing explorer.exe instance creating new instance said p rocess 5.2.1 First stage In first stage Tinba loader follows typical process hollowing scheme That first creates new process executable suspended Then unmaps memory sections creates new sections unpacked code Following sets new entry point address resumes process First open OllyDbg load doc likwidacji _ doc_TK2015.exe format executable Now land entry point 0x401300 Advanced artefact analysis October 2015 72 Insert breakpoints following functions CreateProcessW SetThreadContext WriteProcessMemory ResumeThread Resume process execution F9 After short land CreateProcessW breakpoint As see eith er stack window call stack window Alt+K new process created suspended state CREATE_SUSPENDED created using original executable image Advanced artefact analysis October 2015 73 Step F8 times till go past return land back loader code You land instruction TEST EAX EAX Scroll assembly code see calls functions GetThreadContext ReadProcessMemory ZwUnmapViewOfSection VirtualAllocEx WriteProcessMemory SetThreadContext ResumeThread This typical process hollowing technique Now could step code F8 follow exactly process hollowing taking place Sometimes thi would necessary especially malware uses anti - debugging techniques nonstan dard approach es In case enough follow previously set breakpoints SetThreadContext WriteProcessMemory ResumeThread Resume execution F9 The execution break WriteProcessMemory Take look arguments passed via stack WriteProcessMemory function Advanced artefact analysis October 2015 74 You see loader overrides 17920 bytes address 0x400000 previously created child process If follow dump source buffer 0x2130000 39 see typical PE headers likely unpacked code At point could decide dump new PE image disk later analysis skip step start debugging chi ld process Resume execution F9 two times break SetThreadContext function This function used malware set new entry point address initial thread suspended process resumed Write address context structure put stack 0x420000 - pContex follow dump 39 This address might different Advanced artefact analysis October 2015 75 The e ntry point newly created process stored EAX register 40 Its value read context structure address pContext+0xB0 41 In case entry point address 0x00401000 remember little - endian notation Write address entry point needed later Resume execution F9 land breakpoint ResumeThread If steppe function child process would resumed would miss chance follow code You atta c h To cope proble use simple trick You override first two bytes entry point child process 0xEBFE This opcode translates JMP instruction This way resuming process initial thread stuck endless loop giving us chance attach OllyDbg child process To override child process memory use Process Hacker 42 tool Open Process Hacker find suspended child process Right - c lick open Properties window 40 ich value EAX register context currently debugged process 41 struct CONTEXT http //www.nirsoft.net/kernel_struct/vista/CONTEXT.html last accessed 11.09.2015 42 Process Hacker http //processhacker.sourceforge.net/ last accessed 11.09.2015 Advanced artefact analysis October 2015 76 In Properties window switch Memory tab find memory block entry point located 0x401000 - > memory block 0x400000 Right - click choose Read/Write Memory option In new window go entry point address offset 0x1000 addresses relative 0x400000 Advanced artefact analysis October 2015 77 Write first two bytes offset 0x64A1 override 0xEBFE Click Write close window Now switch back OllyDbg step F8 till return ResumeThread function Advanced artefact analysis October 2015 78 Now minimize OllyDbg I n Process Hacker window ou also notice child process resumed using considerable amount CPU time This result en dless loop created process Note process identifier PID child process decimal Start new OllyDbg instance attach child process File - > Attach Note OllyDbg presents process PIDs hexadecimal format If unsure entries child process try attaching Since parent process already debugged possible attach one process real child process Advanced artefact analysis October 2015 79 Ignore error message previously You land somewhere ntdll In assembly window go address 0x401000 EP You see previously injected 0xEBFE bytes Put breakpoint instruction resume process F9 Advanced artefact analysis October 2015 80 After land breakpoint select JMP instruction press Ctrl+E edit Replace EB FE bytes original 64 A1 After confirmation OllyDbg automatically reanalyse code changing significantly Now e ntry point second stage 5.2.2 Second stage Second stage loader creates new instance EXPLORER.exe process injects malicious code But instead entirely overriding EXPLORER.exe code also uses f ile apping mechanism share portion code new process First still paused entry point second stage create snapshot virtual machine name Tinba In case anything going ed repeat entire process Next put breakpoints following functions CreateProcessInternalW GetThreadContext SetThreadContext WriteProcessMemory ResumeThread Advanced artefact analysis October 2015 81 Resume execution F9 Shortly land CreateProcessInternalW call Right - click assembly Analyze ! using OllyDbg plugin Next open Call stack window View - > Call stack Alt+K As see CreateProcessInternalW indirectly called result call CreateP rocessA As new process created suspended state time explorer.exe used source image new process Such usage well - know n system process typical malware deception mechanism Continue execution F9 till land GetThreadContext breakpoint In case malware uses function check address entry point EXPLORER.exe process Advanced artefact analysis October 2015 82 Note address pContext structure example 0x12FAAC nd follow dump Next step F8 till return GetThreadContext read EXPLORER.exe entry point pContext+0xB0 address Alternatively find explorer.exe executable disk check entry point address som e PE editor e.g CFF Explorer In situation EP located address 0x4AA8DF Resume execution F9 till breakpoint WriteProcessMemory Notice time small portion code 256 bytes written chi ld process memory also subsequent calls WritePr ocessMemory c also important code overridden exact address previously checked entry point 0x4AA8DF This suggests ed time Follow source buffer dump address case 0x411026 Notice names functions MapViewOfFile OpenFileMapping This suggests rest code transferred using file apping mechanism Knowing buffer written exact address entry point time 0xEBFE trick memory written child process Please e step done stepping WriteProcessMemory function Advanced artefact analysis October 2015 83 Select first two bytes source buffer E8 C2 press Ctr l+E Replace bytes EB FE Next step WriteProcessMemory function till use r code You land TEST EAX EAX instruction As suspected loader calls CreateFileMappingA MapViewOfFile function used share code child process EXPLORER.exe Now might step func tions check arguments Continue execution F9 ResumeThread breakpoint Now since 0xEBFE trick already applied safely step F8 ResumeThread function Minimize OllyDbg window check Process Hacker explor er.exe process resumed properly Advanced artefact analysis October 2015 84 Next open new instance OllyDbg attach EXPLORER .exe process After attaching EXPLORER.exe override EB EF bytes entry point described p revious section original bytes E8 C2 Debug - > Execute till user code Alt+K function Advanced artefact analysis October 2015 85 Now entry point code injected EXPLORER.exe reach payload put breakpoint OpenFileMappingA resume execution F9 After reaching OpenFileMappingA breakpoint step F8 till user code choose Debug - > Execute till user code Alt+F9 You land PUSH EBX instruction As see th e malware first opens file apping object OpenFileMappingA maps file apping object address space MapViewOfFile allocates memory block VirtualAlloc finally copies mapped data locally allocated memory block REP MOVS instruction To reach final payload step F8 return instruction RETN one return see group four call instru ctions Advanced artefact analysis October 2015 86 Now create Advanced artefact analysis October 2015 87 6 Introduction scripting Introduction OllyDbg scripting When debugging malicious code sometimes encounter problem repetitive /or tedious tasks This might case unpacking pieces code obfuscated packer performing multiple repetitive actions malicious code One solutions problem automate certain tasks scripting In O llyDbg using ODbgScript plugin 43 A etailed reference scripting language provided ODbgScript package README.txt file 44 In general language similar assembly language additional comma nds Every operation OllyDbg except functions provided plugins also using script The l ist presents operations ODbgScript Check modify registers Manipulate program memory stack Dump memory blocks Add breakpoints code Control program execution instruction stepping Execute assemb ly instructions context debugged program Perform arithmetic operations Acquire information instructions modules S earch program memory specific instructions patterns OllyDbg scripts often used unpacking binary samples There online repositories 45 46 find script dedicated various packers The c ode presents example script first prints result XOR ing EAX EDX without affecting values register prints first ten Fibonacci numbers 47 loop printing result EAX^EDX var result mov result eax xor result edx log res ult fibonacci 10 var n k mov 3 mov n 1 43 ODBGScript http //sourceforge.net/projects/odbgscript/ last accessed 11.09.2015 44 ODBGScript http //sourceforge.net/projects/odbgscript/files/English % 20Version/README.txt/view last accessed 11.09.2015 45 OllyDbg Oll yScripts http //www.openrce.org/downloads/browse/OllyDbg_OllyScripts last accessed 11.09.2015 46 OllyScript - Scripts http //tuts4you.com/download.php ? list.53 last accessed 11.09.2015 47 Fibonacci number https //en.wikipedia.org/wiki/Fibonacci_number last accessed 11.09.2015 Advanced artefact analysis October 2015 88 mov k 1 log '' 1 1 '' log '' 2 1 '' fibonacci_loop xchg n k add k n eval '' { } { k } '' log $ RESULT '' '' add 1 cmp 10. jbe fibonacci_loop This script mostly self - explanatory Variables declared using var keyword used store numbers strings $ RESULT special variable used stor e result previously executed command All numbers used script default treated hexadecimal numbers To use decimal number must add dot suffix number example 10 == A 11 == B How execute ODbgScripts OllyDbg presented next exercise also lear n use scripting automatically decode hidden strings previously analyzed Tinba sample Decoding hidden strings Tinba This exercise start previous exercise ended If necessary restore snapshot named Tinba created reached main Tinba payload Step F7 first call instruction actually call would never return everything important taking place inside call Next step seventh call instruction F7 Advanced artefact analysis October 2015 89 Take look first call instruction You notice two interesting things Firstly call jumping middle instruction disassembled instruction 0x7717B7 Secondly instructions much sense What see anti - disassembly technique used Tinba variant To see works step call F7 You land another call instruction followed second call LoadLibraryA If scrolled disassembly window code would desynchronize What happened call stepped used push onto stack address pointing data right call instruction return address This call would actually nev er return address pushed onto stack would used first argument next call ed function The f unction called next instruction takes three arguments arg1 - arg3 This functions used decrypt arg2 number bytes stored address pointed arg1 save decrypted data address pointed arg3 This Advanced artefact analysis October 2015 90 Now follow dump arg3 And step F8 call Take look memory dump A emory address pointed arg3 overwritten decrypted text string Now string used argument LoadLibraryA call What mean Tinba stores encoded strings - normal assembly instructions To decode string uses call instruction push address encrypted data onto stack calls decoding routine This technique used several places Tinba code lways uses scheme OFFSET INSTRUCTION CODE INSTRUCTION COMMENT 0x 0 50 PUSH EAX pushing dst address decoded data 0x 1 87 44 24 04 XCHG DWORD PTR ESP+4 EAX 0x5 6A ? PUSH < n > pushing data length 0x7 E8 ? 00 00 00 CALL 0xB+n pushing src address 5 onto stack 0xB < variable length encoded data > - 0xB+n E8 ? ? ? ? CALL < decode_func > calling decode function Question marks struction code column represent single byte variable value I f would like find encoded strings decode use OllyScript automat e task The algorithm would follow 1 Allocate memory decoded data < dst > 2 50 87 44 24 04 64 ? 3 If pattern found - > STOP 4 Get encrypted data length < n > push instruction operand 5 Get encrypted data address < src > 6 Get decoding routine address 7 Call decoding routine context debugged process decode < src > < n > < dst > 8 Output decoded string < dst > Advanced artefact analysis October 2015 91 9 Jump step 2 T use OllyScript create script osc file following code var base var labels checking memory base Tinba payload gmemi eip MEMORYBASE mov base $ RESULT allocating memory results alloc 1000 mov labels $ RESULT printing header information eval '' Memory base 0x { base } '' log '' -- -- -- -- -- -- -- '' log '' Searching encoded strings '' log $ RESULT '' '' log '' -- -- -- -- -- -- -- '' search_loop searching byte pattern find base # 50874424046A ? ? # cmp $ RESULT,0 je end_loop mov base $ RESULT mov push_addr base+5 mov call_addr base+7 mov data_addr base+12 finding data length gopi push_addr,1 DATA mov len $ RESULT finding decode routine address gci call_addr DESTINATION gci $ RESULT DESTINATION mov decode_addr $ RESULT executing decode routine exec pushad push { labels } push { len } push { data_addr } call { decode_addr } popad ende gstr labels mov string $ RESULT fill labels len 0 Advanced artefact analysis October 2015 92 printing result eval '' { data_addr } { len } bytes - > { string } '' log $ RESULT '' '' add base,7 jmp search_loop end_loop log '' -- -- -- -- -- -- -- '' free labels pause Commands used script lloc { size } allocates { size } bytes memory returns address $ RESULT eval { expression } evaluates string expression variables returns string $ RESULT exec ende executes assembly instructions exec ende context debugged process fill { addr } { len } { value } fills { len } bytes address { addr } specified { value } find { addr } { pattern } searches memory { pattern } starting address { addr } free { addr } frees allocated memory address { addr } gci { addr } DESTINATION gets destination address jump/call/return instruction gmemi { addr } MEMORYBASE gets base address memory block { addr } belongs gopi { addr } { n } DATA gets value { n } th operand instruction address { addr } gstr { addr } reads null terminated string memory specified address { addr } je jmp standard jump instructions log { str } outputs provided string { str } Script Log Window mov { dest } { src } standard ov instruction To get detailed information command refer ODbgScript reference README.txt file To use script first make sure EIP register points Tinba API call Then open ODbgScript Script Window Log Window Advanced artefact analysis October 2015 93 Next load script.osc Script Window right - click ing choosing Load Script - > Open When script loaded press < space > resume script execution right - click script context menu choose Resume At time take look Script Log Window decoded strings printed Now know encoded strings typical string analysis guess Tinba functionality For example strings list find strings data_before data_end data_inject data_after tell Tinba using webinjects technique known banking trojans Advanced rtefact analysis October 2015 94 Each printed line following message format { address } { data_length } - > { decoded_string } Where { address } address decoding instructions found This mean use printed messages localize part code string used Additionally could create advanced script would decode strings also rewrite Tinba code way would reference already decoded strings instead decoding runtime Advanced artefact analysis October 2015 95 7 Summary In tra ining learnt principles malicious code debugging D ebugging usually requires lot patience thinking outside box Various anti - debugging anti - analysis techniques make process much harder b ut time debugging often quickest easiest way finding given sample really works When debugging usually multiple ways achieving goal unpack b inary sample check functions operates The real skill n achieve goals quickest possible way without spending much time analysis This learnt regularly analysing malware samples learn different code patterns get better understanding system internals ENISA European Union Agency Network Information Security Science Technology Park Crete ITE Vassilika Vouton 700 13 Heraklion Greece Athens Office 1 Vass Sofias & Meg Alexandrou Marousi 151 24 Athens Greece PO Box 1309 710 01 Heraklion Greece Tel +30 28 14 40 9710 info @ enisa.europa.eu www.enisa.europa.eu 