www.enisa.europa.eu European Union Agency For Network And Information Security Introduction advanced arte fact analysis TOOLSET DOCUMENT FOR STUDENTS OCTOBER 2015 Advanced Artefact Analysis Introduction advan ced arte fact analysis 02 About ENISA The European Union Agency Network Information Security ENISA centre network information security e ENISA works groups develop advice recommendations good practice information security It assists EU member states implementing relevant EU legislat ion works improve expertise EU member states supporting development cross - border communities committed improving network information security throughout EU More information ENISA work found www.enisa.europa.eu Authors This document created Yonas Leguesse Christos Sidiropoulos Kaarel Jõgi Lauri Palkmets consultation ComCERT 1 Poland S - CURE 2 The Netherlands DFN - CERT Services Germany Contact For contacting authors please use cert - relations @ enisa.europa.eu For media enquiries paper please use press @ enisa.europa.eu Acknowledgements goes Filip 1 Dawid Osojca Tomasz Chlebowski 2 Don Stikvoort Michael Potter Legal notice Notice must taken publication represents views interpretations authors editors unless stated otherwise This publication construed legal action ENISA ENISA bodies unless adopted pursuant Regulation EU No 526/2013 This publication necessarily represent state - - art ENISA may update time time Third - party sources quoted appropriate ENISA responsible f content external sources including external websites referenced publication This publication intended information purposes It must accessible free charge Neither E NISA person acting behalf respo nsible use might made information contained publication Copyright Notice © European Union Agency Network Information Security ENISA 201 5 Reproduction authorised provided source acknowledged Advanced Artefact Analysis Introduction advan ced arte fact analysis 03 Table C ontents 1 Introduction x86 Assembly 5 Introduction assembly language 5 Instructions opcodes operands 5 Registers 7 Memory organisation 9 Basic instructions 12 1.5.1 Data transfer instructions 12 1.5.2 Arithmetic operations 13 1.5.3 Logical operations 14 1.5 4 Control flow instructions 15 1.5.5 Jump instructions 15 Function calls stack frame calling conventions 16 2 Environment preparation 19 Advanced Artefact Analysis Introduction advan ced arte fact analysis 04 Main Objective This training presents introduction advanced artefact analysis first part three - day course At beginning introduction course made setting common terminology describing different analysis methods Second b iggest part training introduction assembly language focusing Intel x86 family processors along description binary code execution processor internals system calls The material presented part consider ed introduction whole course However would beneficial trainees prior knowledge x86 assembly language could focus analysis process rather learning assembly instructions The later part th e training introduces number tools commonly used advanced artefact analysis Two IDA Pro Free edition 3 static OllyDbg 4 dynamic analyses used extensively rest course Target Audience C SI RT staff incident handlers involved technical analysis incidents especially dealing artefact examination analysis Prior knowledge assembly language operating systems internals highly recommended Total Duration 3 - 4 hours 3 F reeware version IDA v5.0 https //www.hex - rays.com/products/ida/support/download_freeware.shtml last accessed 11.09.2015 4 OllyDbg http //www.ollydbg.de/ last accessed 11.09.2015 Advanced Artefact Analysis Introduction advan ced arte fact analysis 05 1 Introduction x86 Assembly Introduction assembly language Assembly language low - level programming language whose instructions almost directly translated machine code series bytes understood computer processor CPU Nowadays mostly used specific tasks like programming microcontrollers writing programs requiring high optimisation context speed size Assembly language also widely used field reverse engineering code executable files translated assembly language get human readable form It important know different processor families use different instruction sets differ means available instruct ions registers addressing modes aspects Thus assembly language differs The widespread instruction set field malicious software undoubtedly x86 instructions set This introduction provides quick reference x86 assembly language If would like learn plenty resources freely available online Intel® 64 I A - 5 - complete reference IA - 32 - bit x86 architecture It consists three volumes Volume 1 describes detail architecture programming environment Volume 2 contains complete instruction reference Volume flags sets variants take look Volume 2 detailed descriptio n. X86 Assembly guide Wikibooks 6 detailed book covering various aspects x86 assembly language common instructions different syntaxes advanced concepts X86 Assembly Guide University Virginia 7 short guide describing basics 32 - bit x86 assembly language reference commonly used instructions PC Assembly Language 8 course 32 - bit x86 assembly language references use assembly programs written C. Instructions opcodes operands When write program higher level programming lang uage like C C++ compile compiler translates code machine code Machine code set instructions executed directly CPU 5 Intel® 64 IA - 32 Architectures Software Developer Manuals http //www.intel.com/content/www/us/en/processors/architectures - software - developer - manuals.html last accessed 11.09.2015 6 x86 Assembly https //en.wikibooks.org/wiki/X86_Assembly last access ed 11.09.2015 7 x86 Assembly Guide http //www.cs.virginia.edu/~evans/cs216/guides/x86.html last accessed 11.09.2015 8 PC Assembly Language http //www.drpaulcarter.com/pcasm/ last accessed 11.09.2015 Advanced Artefact Analysis Introduction advan ced arte fact analysis 06 From perspective malicious artefacts analysis reverse engineering machine code hard read human The problem unambiguous easy way translating machine code back higher level programming language Moreover machine code also stripped valuable information comments v ariables functions names This assembly language comes handy Because assembly language almost exact Red square hex dump used mark first instructions machine code The instruction codes viewed view disassembled code As see example x86 architecture utilises variable length instructions In simplified version instruction consists opcode optionally one operands operation usually specifying values memory locations registers operation In example 2 - byte opcode 83 EC tells processor subtract value 8 operand ESP register The number type operands depend specific instruction Usually instruction comes forms allowing use different types operands Advanced Artefact Analysis Introduction advan ced arte fact analysis 07 Possible operand types Immediate value value encoded instruction like sub esp 8 Register operand one registers Memory operand memory specified offset encoded instruction In reality instruction structure little complicated If interested learning please refer 9 Instruction Format Registers A register small amount storage available processor Registers specific given instruction set architecture differ among processor families E contemporary processor least several registers available used different purposes The x86 architecture provides 16 basic registers used general programming 8 general purpose registers EAX EBX ECX EDX ESI EDI EBP ESP 6 segment registers CS DS SS ES FS GS One flags register EFLAGS One instruction pointer register EIP In addition registers also several special purpose registers like debug registers control registers registers associated CPU extensions MMX SSE FPU etc. General purpose registers used name suggests general registers different types operations arithmetic calculatio ns address calculations hold memory pointers Additionally one also special role EAX accumulator register used different arithmetic operations EBX data pointer ECX counter register used loops EDX I/O pointer ESI source data pointer string operations EDI destination data pointer used string operations EBP base pointer used create stack frame function calls ESP stack pointer points top stack General purpose registers 32 - bit size however possible access 16 - 8 - bit registers using following pattern 9 Intel® 64 IA - 32 Architectures Software Developer Manuals Vol 2 http //www.intel.com/content/dam/www/public/us/en/documents/manuals/64 - ia - 32 - architectures - software - developer - instruction - set - reference - manual - 325383.pdf last accessed 11.09.2015 Advanced Artefact Analysis Introduction advan ced arte fact analysis 08 This means order access lower 16 bits EAX register refer AX register You also access lower higher 8 bits AX register referring adequately AL AH The scheme applies EBX ECX EDX registers It also applies ESI EDI EBP ESP except ca nn access 8 bit registers The next group registers six segmen registers CS DS SS ES FS GS In early days x86 processors used hold 16 - bit segment selectors use memory segmentation Since modern operating systems use paging flat memory model segment registers rarely used anymore special purposes 10 Example special usage FS register Win32 systems points Thread Information Block structure 11 The last two registers flag register EFLAGS instruction pointer EIP EFLAGS register used store flags values holding information results previous operations system information The following basic flags available CF Carry Flag PF Parity Flag AF Auxiliary Carry Flag ZF Zero Flag SF Sign Flag TF Trap Flag IF Interrupt Enable Flag DF Direction Flag OF Overflow Flag IOPL I/O Privilege Level NT Nested Task RF Resume Flag VM Virtual - 8086 Mode AC Alignment Check VIF Virtual Interrupt Flag VIP Virtual Interrupt Pending ID ID Flag Flags bold called status flags They store information results arithmetic operations primar ily us ed conditional branch instructions For example Z ero flag ZF informs result 10 What happened segment registers ? http //www.lshift.net/blog/2010/03/31/what - - happened - - - segment - registers/ last accessed 11.09.2015 11 Under Hood https //www.microsoft.com/msj/archive/S2CE.aspx last accessed 11.09.2015 Advanced Artefact Analysis Introduction advan ced arte fact analysis 09 operation zero O verflow flag OF indicates overflow integer number resulting value either big small negative numbers To get detailed information flag role refer l 12 Different assembly instructions set clear different flags For example ADD instruction set OF SF ZF AF CF PF flags To get information flags set specific instruction refer x86 assembly instructions referenc e 13 Finally instruction pointer register EIP used hold address next instruction executed This register however directly accessed software neither read write purposes Memory organisation The Microso ft Windows system well contemporary operating systems uses flat memory model programs see memory contiguous linear address space Moreover thanks virtual memory concept process running Microsoft Windo ws gets access virtual address space 14 One outcomes process isolation Two different processes different data blocks loaded address virtual address space none would able directly access memory second process without help operating system On Microsoft Windows system memory 32 - bit processes addressed 32 - bit addresses starting 0 0xFFFFFFFF 4GB Though address space availabl e user - mode processes 15 User - mode processes access freely memory 0 0x7FFFFFFF 2GB 16 The second half addresses 0x80000000 0xFFFFFFFF reserved operating system 12 Intel® 64 IA - 32 Architectures Software Developer Manuals http //www.intel.com/content/www/us/en/processors/architectures - software - developer - manuals.html last accessed 11.09.2015 13 Intel® 64 IA - 32 Architectures So ftware Developer Manuals Vol 2 http //www.intel.com/content/dam/www/public/us/en/doc uments/manuals/64 - ia - 32 - architectures - software - developer - instruction - set - reference - manual - 325383.pdf last accessed 11.09.2015 14 Virtual address spaces ht tps //msdn.microsoft.com/en - us/library/windows/hardware/hh439648 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 15 User mode kernel mode https //msdn.micr osoft.com/en - us/library/windows/hardware/ff554836 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 16 address 2GiB memory using special /LARGEADDRESSAWARE linker option https //msdn.microsoft.com/en - us/library/vstudio/wz223b1z % 28v=vs.100 % 29.aspx last accessed 11.09.2015 Advanced Artefact Analysis Introduction advan ced arte fact analysis 10 When new PE executable started Windows system new process created system loader maps stack also created The Thread Environment Block TEB Process Environment Block PEB system structures providing separate TEBs one application thread Advanced Artefact Analysis Introduction advan ced arte fact analysis 11 This simplified version process address space normally would also contain memory blocks e.g block environment variables 17 multiple heaps You view detailed memory map process using VMMap tool Sysinternals 18 Two important memory structures stack heap The process heap memory region dynamically allocated variables e.g using malloc put The stack hand used storing local variables tracing function calls current thread The stack last first LIFO data structure separate stack thread lower memory address es This means whenever new value pushed onto stack ESP register decremented 17 Changing Environment Variables https //msdn.microsoft.com/en - us/library/windows/desktop/ms682009 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 18 VMMap https //technet.microsoft.com/en - us/library/dd535533.aspx last accessed 11.09.2015 Advanced Artefact Analysis Introduction advan ced arte fact analysis 12 Except storing local variables stack also used passing function arguments tracing function calls This described later se ction Basic instructions There plenty different instructions x86 instruction set Additionally instruction usually comes forms allowing use different operand types registers immediate values memory addresses This section list common x86 Assembly instructions brief description one The following notation assumed operands < reg > - one general - purpose registers < mem > - memory location < imm > - immediate value < rel > - address relative current instruction If bit suffix added operand type means operand bit size allowed operation example < reg32 > - double - word general - purpose registers EAX EBX ECX EDX < reg16 > - nly word general - purpose registers AX BX CX DX 1.5.1 Data transfer instructions Instruction Description Affected flags mov < reg > < reg > mov < reg > < mem > mov < reg > < imm > mov < mem > < imm > mov < mem > < reg > Copies data second operand first operand None movsb Moves byte address ESI address EDI increases/decreases ESI EDI according DF flag None movsw Moves word address ESI address EDI None Advanced Artefact Analysis Introduction advan ced arte fact analysis 13 increases/decreases ESI EDI according DF flag xchg < reg > < reg > xchg < reg > < mem > xchg < mem > < reg > Exchanges contents first operand second operand None stosb Stores byte AL address EDI increases/decreases EDI according DF flag None stosw Stores word AX address EDI increases/decrea ses EDI according DF flag None lodsb Loads byte address ESI AL increases/decreases ESI according DF flag None lodsw Loads word address ESI AX increases/decreases ESI according DF flag None push < reg32/reg16 > push < mem32/mem16 > push < imm > Decrements stack pointer stores source operand top stack None pushfd Decrements stack pointer 4 stores entire EFLAGS register top stack None pushad Pushes general purpose registers onto stack following order EAX ECX EDX EBX ESP original EBP ESI EDI None pop < reg32/reg16 > pop < mem32/mem16 > Pops value top stack store destination operand Then increment stack pointer adequately None popfd Pops top stack EFLAGS register restores flags values All flags popad Pops EDI ESI EBP EBX EDX ECX EAX registers Value ESP register stack ignored None lea < reg > < mem > Computes effective address second operand memory offset stores first operand None 1.5.2 Arithmetic operations Instruction Description Affected flags add < reg > < imm > add < reg > < mem > add < reg > < reg > add < mem > < imm > add < mem > < reg > Adds second operand first operand stores result first operand OF SF ZF AF CF PF sub < reg > < imm > sub < reg > < mem > sub < reg > < reg > sub < mem > < imm > sub < mem > < reg > Subtracts second operand first operand OF SF ZF AF CF PF div < reg > div < mem > Unsigned divide Divides value stored EDX EAX source operand stores quotient EAX remainder EDX CF OF SF ZF AF PF idiv < reg > idiv < mem > Signed divide Divides value stored EDX EAX source operand stores quotient CF OF SF ZF AF PF Advanced Artefact Analysis Introduction advan ced arte fact analysis 14 EAX remainder ED X. mul < reg > mul < mem > Unsigned multiply Multiples value EAX destination operand Result stores EDX EAX OF CF imul < reg > imul < mem > Signed multiply Multiples value EAX destination ope rand Result stores EDX EAX There also two three operand version signed multiply Refer instruction reference information OF CF inc < reg > inc < mem > Adds 1 destination operand OF SF ZF AF PF dec < reg > dec < mem > Subtracts 1 destination op erand OF SF ZF AF PF neg < reg > neg < mem > CF OF SF ZF AF PF sal < reg > < imm8 > sal < reg > CL sal < reg > 1 sal < mem > < imm8 > sal < mem > CL sal < mem > 1 Arithmetic shift left first operand < imm8 > /CL/1 CF OF SP ZP PP sar < reg > < imm8 > sar < reg > CL sar < reg > 1 sar < mem > < imm8 > sar < mem > CL sar < mem > 1 Arithmetic shift right first operand < imm8 > /CL/1 CF OF SP ZP PP cmp < reg > < reg > cmp < reg > < mem > cmp < reg > < imm > cmp < mem > < reg > cmp < mem > < imm > Compares first operand second operand subtracting second operand first setting appropriate flags Operands values changed CF OF SF ZF AF PF 1.5.3 Logical operations Instruction Description Affected flags < reg > < reg > < reg > < mem > < reg > < imm > < mem > < reg > < mem > < imm > Bitwise AND operation first destination operand second source operand Result stored first operand OF CF cleared SF ZF PF set appropriately < reg > < reg > < reg > < mem > < reg > < imm > < mem > < reg > < mem > < imm > Bitwise inclusive OR operation first destination operand second source operand Result stored first operand OF CF cleared SF ZF PF set appropriately < reg > < mem > Bitwise NOT operation None Advanced Artefact Analysis Introduction advan ced arte fact analysis 15 shl < reg > < imm8 > shl < reg > CL shl < reg > 1 shl < mem > < imm8 > shl < mem > CL shl < mem > 1 Logical shift left first operand < imm8 > /CL/1 OF SP ZP PP shr < reg > < imm8 > shr < reg > CL shr < reg > 1 shr < mem > < imm8 > shr < mem > CL shr < mem > 1 Logical shift right first operand < imm8 > /CL/1 OF SP ZP PP xor < reg > < reg > xor < reg > < mem > xor < reg > < imm > xor < mem > < reg > xor < mem > < imm > Bitwise exclusive OR XOR operation first destination operand second source operand Result stored first operand OF CF cleared SF ZF PF set appropriately test < reg > < reg > test < reg > < imm > test < mem > < reg > test < mem > < imm > Logical compare operation performing bitwise AND operation first second operand setting appropriate flags OF CF cleared SF ZF PF set appropriately 1.5.4 Control flow instructions Instruction Description Affected flags call < rel > call < reg > call < mem > Procedure call Saves return address stack branches called procedure None ret ret < imm16 > Return return address popped stack Optionally releases < imm16 > bytes stack None leave Releases stack frame Copies frame pointer EBP stack pointer register ESP pops old frame pointer stack None int < imm8 > Generates interrupt specified immediate value operand calls interrupt handler EFLAGS register pushed onto stack Certain flags might affected depending interrupt nop No operation Does nothing Machine code 0x90 useful debugging None loop < imm8 > Performs loop operation Jumps short ECX=0 decrementing ECX iteration None 1.5.5 Jump instructions Instruction Description Affected flags jmp < rel > Always jumps address specified None Advanced Artefact Analysis Introduction advan ced arte fact analysis 16 jmp < reg > jmp < mem > operand je/jz < rel > Jumps equal/zero ZF=1 None ja < rel > Jumps CF=0 ZF=0 None jb < rel > Jumps CF=1 None jae < rel > Jumps equal CF=0 None jbe < rel > Jumps equal CF=1 ZF=1 None jne/jnz < rel > Jumps equal/zero ZF=0 None jna < rel > Jumps CF=1 ZF=1 None jnb < rel > Jumps CF=0 None Function calls stack frame calling conventions A function part code called multiple times different locations specific task perform The function concept also present assembl language X86 assembly supports function calls introducing special instructions e.g call ret leave registers like EBP used hold address current stack frame described detail later Functions called using call instruct ion When function called address instruction following call return address pushed onto stack This address later used ret instruction return back code function called Consider ex ample In example instruction call func_1 executed address 0x40100C pushed onto stack When function returns execution resume address A typical function call looks like 1 Passing parameters function 2 Calling function 3 Reserving stack memory local variables 4 Function operations 5 Restoring stack 6 Function return optionally cleaning function arguments To ease referencing parameters local variables restoring stack functions frequently use EBP based stack frames The tack frame created beginning function pushing previous EBP value onto stack saving current stack pointer ESP value EBP register Creation stack frame typica lly looks like following This often called function prologue After stack look like assuming also two arguments passed function stack Advanced Artefact Analysis Introduction advan ced arte fact analysis 17 If function using EBP based stack frame restoration original stack fun ction end also relatively easy takes two steps first EBP copied ESP restoring ESP value function beginning old EBP popped top stack This often referred function epilogue Restora tion stack necessary ret instruction reached top stack contain return address In example parameters passed function stack This n always need case The exac way function called arguments passed defined called calling conventions There popular calling conventions use depending compiler code In general calling convention defines How parameters ar e passed function The order function parameters passed left right right left How function returning value Which registers preserved called function Such registers still used function bu function returns value restored What done parameters passed function via stack ? Should cleaned called function callee clean - caller ? Advanced Artefact Analysis Introduction advan ced arte fact analysis 18 Below find short description popular calling conventions cdecl __cdecl This default calling convention C C++ programs 19 Arguments passed stack right left Function result returned EAX register All registers except EAX ECX EDX preserved callee Caller cleans arguments stack stdcall __stdcall Standard calling convention Windows Win32 API functions 20 Arguments passed stack right left Function result returned EAX register All registers exce pt EAX ECX EDX preserved callee Callee cleans arguments stack returning fastcall __fastcall This less commonly used calling convention 21 The first two arguments left right passed ECX EDX registers arguments right left passed stack The function result returned EAX register All registers except EAX ECX EDX preserved callee Callee cleans arguments stack returning arguments thiscall __thiscall This calling convention used C++ non - static member functions 22 Its implementation slightly differs among compilers GCC Microsoft Visual C++ Similarly calling conventions arguments pa ssed ECX register The f unction result returned EAX 19 __cdecl https //msdn.microsoft.com/en - us/library/zkwh89ks.aspx last accessed 11.09.2015 20 __stdcall https //msdn.microsoft.com/en - us/library/zxk0tw93.aspx last accessed 11.09.2015 21 __fastcall https //msdn.microsoft.com/en - us/library/6xa169sk.aspx last accessed 11.09.2015 22 __thiscall https //msdn.microsoft.com/en - us/library/ek8tkfbw.aspx last accessed 11.09.2015 Advanced Artefact Analysis Introduction advan ced arte fact analysis 19 2 Enviro nment preparation All analyses malicious files performed dedicated isolated environments Most often would group properly configured virtual machines The role environment prevent malicious code accessing private data infecting hosts local network An example environment described Building artefact handling analysis environment exercise ENISA Artefact Analysis training 23 In training using single virtual machine Microsoft Windows operating system Microsoft Windows 7 32 - bit without network connectivity To learn create virtual machine install necessary tools refer Building artefact handling analysi environment training description Winbox VM network connection end process Samples used training pr ovided separate archive Password archive infected commonly used password archives containing malicious code Please note purpose archiving password make user aware maliciousness co de avoid running accidentally It intended confidentiality measure Unpacking archive reveal following samples Do execute samples creating snapshot clean virtual machine ! Before p roceed second part training make sure 23 Training Courses https //www.enisa.europa.eu/activities/cert/training/courses last accessed 11.09.2015 Advanced Artefact Analysis Introduction advan ced arte fact analysis 20 There access Virtual Machine Internet access local network You installed necessary tools copied malware samples You start following programs OllyDbg Process Hacker IDA Pro Free Note OllyDbg Process Hacker always run administrator You created clean snapshot system executing sample Finally training b e dealing live malware samples always remember take proper security precautions Analyse malicious files dedicated controlled environment isolated local network private files sensitive data If using virtualisation technology make sure using newest stable version software Also install Guest Additions virtual machine malicious code running virtual machine might start se nding spam attacking hosts Internet Restore snapshot clean system analysis involving execution malicious code unless ay made changes operating system may prevent next sample executing correctly Remember dynamic analysis malicious code debugger really executing malicious code slower ! A debugger lets p rocessor execute machine commands results affect environment way would run without debugger Safety operation depends solely selecting cautiously parts code may run icious files onto personal computer If really necessary move malicious files password protected archive first This protect accidentally executing sample When store malicious files make sure everyone acce ss files know A good idea put malicious files directory clear suggestive name Follow instructions trainer ENISA European Union Agency Network Information Security Science Technology Park Crete ITE Vassilika Vouton 700 13 Heraklion Greece Athens Office 1 Vass Sofias & Meg Alexandrou Marousi 151 24 Athens Greece PO Box 1309 710 01 Heraklion Greece Tel +30 28 14 40 9710 info @ enisa.europa.eu www.enisa.europa.eu www.enisa.europa.eu European Union Agency For Network And Information Security Introduction advanced arte fact analysis HANDBOOK DOCUMENT F OR TEACHERS OCTOBER 2015 Advanced Artefact Analysis Introduction advanced artefact analysis 02 About ENISA The European Union Agency Network Information Security ENISA centre network information security e ENISA works groups develop advice recommendations good practice information security It assists EU member states implementing relevant EU legislat ion works improve expertise EU member states supporting development cross - border communities committed improving network information security throughout EU More information ENISA work found www.enisa.europa.eu Authors This document created Yonas Leguesse Christos Sidiropoulos Kaarel Jõgi Lauri Palkmets consultation ComCERT 1 Poland S - CURE 2 The Netherlands DFN - CERT Services Germany Contact For contacting authors please use cert - relations @ enisa.europa.eu For media enquiries paper please use press @ enisa.europa.eu Acknowledgements goes Filip 1 Dawid Osojca Tomasz Chlebowski 2 Don Stikvoort Michael Potter Legal notice Notice must taken publication represents views interpretations authors editors unless stated otherwise This publication construed legal action ENISA th e ENISA bodies unless adopted pursuant Regulation EU No 526/2013 This publication necessarily represent state - - art ENISA may update time time Third - party sources quoted appropriate ENISA responsible content external sources including external websites referenced publication This publication intended information purposes It must accessible free charge Neither E NISA person acting behalf resp onsible use might made information contained publication Copyright Notice © European Union Agency Network Information Security ENISA 201 5 Reproduction authorised provided source acknowledged Advanced Artefact Analysis Introduction advanced artefact analysis 03 Table Contents 1 Training introduction 5 Training overview 5 Cour se structure 5 Samples 6 Recommended reading materials 6 2 Advanced artefact analysis 8 Advanced dynamic analysis 8 Advanced static analysis 9 Analysis goal stop 10 3 Introduction x86 Assembly 11 Introduction assembly language 11 Instructions opcodes operands 11 Registers 13 Memory organisation 15 Basic instructions 18 3.5.1 Data transfer instructions 18 3.5.2 Arithmetic operations 19 3.5.3 Logical operations 20 3.5.4 Control flow instructions 21 3.5.5 Jump instructions 22 Function calls stack frame calling conventions 22 4 Tools overview 25 OllyDbg 25 Immunity Debugger 26 WinDbg 28 WinAppDbg PyDbg 28 IDA Pro 29 Radare2 30 5 Environment preparation 31 6 Training summary 33 Advanced Artefact Analysis Introduction advanced artefact analysis 04 Main Objective This raining presents introduction advanced art e fact analysis first part three - day course At beginning introduction course made setting common terminology describing different analysi methods S econd biggest part th e training introduct ion assembly language focusing Intel x86 family processors along wi th description binary code execution processor internals system calls The material presented part considered introduction whole course However would beneficial trainees prior knowledge x86 assembly language could focus analysi process rather learning assembly instructions The later part training introduces number tools commonly used advanced art e fact analysis Two IDA Pro Free edition 3 static OllyDbg 4 dynamic analyses u sed extensively rest course Target Audience C SI RT staff incident handlers involved technical analysis incidents especially dealing art e fact examination analysis Prior knowledge assembly language operating systems internals highly recommended Total Duration 3 - 4 hours Frequency Once per team member 3 F reeware version IDA v5.0 https //www.hex - rays.com/products/ida/support/download_freeware.shtml last accessed 11.09.2015 4 OllyDbg http //www.ollydbg.de/ last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 05 1 Training introduction Over years malware become tool many c riminal use spy steal information money gain persistent access remote information systems A continuous race malware creators countermeasures developers make automated defences regularly fail CSI RTs important role provide expertise understand cause assess potential damage evelop protection methods To counter threat uses state - - - art techniques order evade detection mechanisms requires skills knowledge often non - conventional thinking This training created deepen analyst knowledge develop skills art e fact analysis domain Training overview This course designed extend existing ENISA Artefact Analysis training 5 advanced exercises During training participants learn analyse artefact potentially malicious code code level Participants taught types manual artefact analysis static using disassembler - dynamic using debugger This training intended security experts working CSIRT eams willing deepen knowledge artefact analysis This training given using 32 - bit Microsoft Windows platform It would beneficial trainees previous knowledge x86 assembly language Microsoft Windows sy stem architecture including Win32 API keep focused analyses rather assembly instructions A list recommended readin g provided paragraph 1.4 It also strongly encouraged follow basic ENISA Artefact Analysis training gives broad perspective artefact analysis Techniques tools presented training help set goals advanced analysis start ing knowledge analysed samples Course structure The tra ining split three separate parts The first part Introduction Advanced Artefact Analysis This part purely theoretical role give introduction advanced dynamic static analysis well introduce fundamentals x86 assembly language In part also learn free tools commonly used reverse engineering analysis malicious code Finally opportunity prepare test envir onment using analyses practical part training The knowledge get first part essential completing second third part training After completing first part traini ng proceed second part Advanced Dynamic Analysis In part introduced OllyDbg debugger 6 one commonly used debuggers malicious code analysis After learn practical elements advanced dynamic analysis including unpacki ng packed samples followed creation child processes code injection 5 Training Courses https //www.enisa.europa.eu/activities/cert/training/courses last accessed 11.09.2015 6 http //www.ollydbg.de/ last accessed 11.09.2015 Advanced Arte fact Analysis Introduction advanced artefact analysis 06 schemes well overcoming basic anti - debugging techniques Finally lear n basics debugging automation using OllyScript engine The last part Advanced Static Analysis In part learn perform static analysis disassembled code using IDA Pro 7 tool First taught effe ctively use IDA Pro tool features offer Then use IDA initial assessment malicious code find important functions After finding important functions try analyse code The hird part f training end presentation various anti - analysis techniques presentation use IDA overcome S amples During training using various samples All samples 32bit Portable Executable PE files dedicated Microsoft Windows platform To learn file format refer ENISA Artefact Analysis training 8 While handling samples always executed caution isolated controlled environment Whether sample used exercise malicious explicitly mentioned beginning exercise A samples obtained KernelMode.info 9 forum many thanks useful community To minimis e accidental execution risk amples underscore suffix added .exe file extension samples You n need remove suffix training tools used training properly open files without issues It strongly suggest ed remind students principles building safe secure analysis environment designed artefact training scenario 10 Recommended reading materials Advanced artefact analysis c omplex subject requiring constant learning practi c e If would like better prepare training extend knowledge completing multiple online resources published books use The l st cont ains recommended reading covering topics assembly language reverse engineering Win32 API dynamic analysis static analysis ENISA Artefact Analysis training 11 previous edition training covering building artefact handling analysis environment artefact acquisition well basic static behavioural dynamic g prior attending Advanced Artefact Analysis training theForger 's Win32 API Programming Tutorial 12 basic introduction programming using Win32 API explains important Windows API concepts windows messages etc. 7 The freeware version IDA v5.0 https //www.hex - rays.com /products/ida/support/download_freeware.shtml last accessed 11.09.2015 8 Training Courses https //www.enisa.europa.eu/activities/cert/training/courses last accessed 11.09.2015 9 KernelMode.info http //www.kernelmode.info/forum/ last accessed 11.09.2015 10 Building artefact handling analysis environment https //www.enisa.europa.eu/activities/cert/training/training - resources/technical - operational # building last accessed 11.09.2015 11 Training Courses https //www.enisa.europa.eu/activities/cert/training/courses last accessed 11.09.2015 12 theForger 's Win32 API Programming Tutorial http //www.winprog.org/tutorial/ last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 07 The Tenouk 's Win32 - Windows 32 bits system OS programming tutorial 13 group tutorials covering various Windows architecture Win32 API topics along reference common API functions Free IDA Pro Binary Auditing Training Material University Lectures 14 excellent set practical exercises dedicated reverse engineering learning binary aud iting OpenSecurityTraining.info 15 free online training materials covering various security topics including introduction x86 assembly malware dynamic analysis reverse engine ering malware Tuts 4 You Tutorials Papers Dissertations Essays Guides 16 source dozens papers tutorials materials related reverse engineering dynamic static anal ysis unpacking samples many M Sikorski A Honig `` Practical Malware Analysis '' excellent book introducing advanced malware analysis It starts beginning introduction x86 assembly language gradually moves advanced topics covering malicious code debugging analysis disassembled code malware behaviour anti - reverse - engineering techniques C Eagle The IDA Pro Book introduction IDA Pro disassembler It serves program reference also great source information reverse engineering many practical examples explaining various concepts B. Dang A. Gazet E. Bachaalany S. Josse Practical Reverse E ngineering reverse engineering introduction beginners advanced readers The b ook explains x86 architecture Windows kernel debugging automation various code obfuscation techniques J. Seitz Grey Hat Python book focusing debuggers dy namic analysis autom ation using Python language It starts explaining debuggers work moves topics building debugger writing debugging nd reverse engineering autom ation scripts Python M. Russinovich D.Solo Windows Internals 6 th Edition - depth reference Microsoft Windows internals explaining detail Windows architecture operation various system processes Recommended people interested advanced dynamic analysis including debugging kernel level 13 The Tenouk 's Win32 - Windows 32 bits system OS programming tutorial http //www.tenouk.com/cnwin32tutorials.html last accessed 11.09.2015 14 Free IDA Pro Binary Auditing Training Mat erial University Lectures http //www.binary - auditing.com/ last accessed 11.09.2015 15 OPEN SECURITY TRAINING http //www.opensecuritytrain ing.info/Training.html last accessed 11.09.2015 16 Tuts 4 You https //tuts4you.com/download.php ? list.19 last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 08 2 Advanced artefact analysis Advanced dynamic analysis Dynamic analysis type analysis suspicious file intentionally executed dedicated controlled environment order observe haviour Then based observed results analyst seeks assess whether sample malicious changes made operating system possible determine malware family There two types dynamic analysis Behavioural analysis Debugging malicious code During behavioural analysis analyst executes sample controlled environm ent observes changes made operating system Changes filesystem registry execution resulte creation new processes Network traffic also valuable source information This type analysis covered ENISA Artefact Analysis training 1 The econd type analysis referred later advanced dynamic analysis execute suspicious code control debugger This activity commonly named sample debugging shares tools techniques process hunting bugs code Such approach gives analyst opportunity track th e code execution instruction instruction providing much detailed information behavioural analysis would give Moreover unlike behavioural analysis debugging also allows change runtime malicious code executes example allows check would happen malicious code receive different command C & C server This analysis however without drawbacks It requires analyst deep knowledge reverse eng ineering good understanding operating system works It requires also definition executing least parts potentially malicious code This may unpredictable consequences unintended infections leaving tracks ther systems including C & C servers allowed connect On top debugging malicious code depending complexity might often take significant amount time Advanced dynamic analysis especially useful following scenarios Unpacking malware samples Packing process original malicious code heavily obfuscated order avoid detection anti - virus engines This makes static analysis code nearly impossible Using debugger possib le unpack sample letting execute code memory restored original form Following process injection Modern malware often tries hide presence system Two popu lar methods achieving 1 injecting malicious code processes 2 starting new process legitimate applications overwriting Advanced Artefact Analysis Introduction advanced artefact analysis 09 memory malicious code process hollowing 17 If process injection process hollowing techniques used use debugger analyse malicious code injected Analysing complex algorithms In contrast static analysis disassembled code debugging allows view runtime state mem ory registers This useful analysis complex algor ithms often easier understand follow execution step step checking time registers variables changing Analysing data decrypted runtime To hinder analysis lot valuable information like addresses C & C servers base configuration often initially encrypted binary file decrypted runtime To obtain data decrypted form usually easier use debugger static analysis techniques Analysi ng communication C & C server Quite often interesting part malicious code analysis learning communicates C & C server data sends remote server data receives Since modern malware en crypts traffic However u sing debugger let malicious application execute try execute code controlling network communication Then many cases able read origina l data memory encryption decryption Advanced static analysis Static analysis method analysis analyst tries learn suspicious file without executing In basic static analysis PE file analyst stu dy PE headers embedded strings attached resources He may also signature scanning look information file via online resources If sample n packed analysis performed unpacked sample analyst learn functionality executable sometimes recognis e malware family Basic static analysis described detail ENISA Artefact Analysis training More thorough words advanced static analysis involves disassembling executable file performing analysis disassembled code Similarly advanced dynamic analysis requires good reverse engineering skills prior knowledge operating system internals Depending goal might also quite time consuming When analysing disassembled code usually n know parts code would executed would state memory registers Y ou learn slow analysis process On hand static analysis n limited one execution flow would dyn amic analysis This makes static analysis useful learning functions would executed spec ific condition A g ood example function executed receiving specific command C & C server Additiona lly thanks fact static analysis n require executing sample much safer You also limited analysis executable files created architecture operation system running For example problem conducting analysis ARM binaries Linux ELF 17 Process hollowing http //www.autosectools.com/process - hollowing.pdf last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 10 executable files Windows The requirement tools using support particular format Analysis goal stop Both advanced dy namic static analysis malicious file c time consuming To minimis e risk spending much time one task always clear goal analysis mind Examples goals Checking sample really malicious file Finding infection indicators changes made environment result execution malicious file used detect infected workstations Analysis malware capabilities functionality Analysis ne twork traffic protocol used communicate C & C Decrypting base configuration malicious file find addresses C & C servers Preparing malicious file signature Recognis ing malware family Full analysis malicious code Depending profile work good practice might also predetermined time limit spend analysis Sometimes find complex samples reaching time limit probably plenty things st ill unknown things would like check At moment would need decide spending time worth effort may better finish analysis move next sample Finally always remember golden rule problem solving reach impasse point take break something else - think problem At beginning learning malware analysis often find spend much time thinking solve problem In field malware analysis reverse engineering things done various ways Advanced Artefact Analysis Introduction advanced artefact analysis 11 3 Introduction x86 Assembly Introduction assembly language Assembly language low - level programming language whose instructions almost directly translated machine code series bytes understood computer processor CPU Nowadays mostly used specific tasks like programming microcontrollers writing programs requiring high ptimis ation context speed size Assembly language also widely used field reverse engineering code executable files translated assembly language get human readable form It important know th different processor families use different instruction sets differ means available instructions registers addressing modes aspects Thus assembly language differs The widespread instruction set field malicious software undoubtedly x86 instructions set This introduction provides quick reference x86 assembly language If would like l earn plenty resources freely available online Intel® 64 IA - 18 - complete ref erence IA - 32 architecture - bit x86 architecture It consists three volumes Volume 1 describes detail architecture programming environment Volume 2 contains complete instruction reference Volume 3 includes system sets vari ants take look Volume 2 detailed description X 86 Assembly guide Wikibooks 19 detailed book covering various aspects x86 assembly language common instructions different syntaxes advanced concepts X86 Assembly Guide University Virginia 20 short guide describing basics 32 - bit x86 assembly language reference commonly used instructions PC Assembly Language 21 course 32 - bit x86 assembly language references use assembly programs written C. Instructions opcodes operands When write program higher level programming language like C C++ compile compiler transl ates code machine code Machine code set instruc tions executed directly CPU 18 Intel® 64 IA - 32 Architectures Software Developer Manuals http //www.intel.com/content/www/us/en/processors/architectures - software - developer - manuals.html last accessed 11.09.2015 19 x86 Assembly https //en.wikibooks.org/wiki/X86_Assembly last accessed 11.09.2015 20 x86 Assembly Guide http //www.cs.virginia.edu/~evans/cs216/guides/x86.html last accessed 11.09.2015 21 PC Assembly Language http //www.drpaulcarter.com/pcasm/ last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 12 From perspective malicious artefact analysis reverse engineering machine code hard read human The problem unambiguous easy way translating machine code back higher level programming language Moreover machine code also stripped valuable information comments variables functions names This assembly language comes handy Because assembly language almost exact representation machine cod e back assembly instructions Red squares hex dump used mark first fe w instructions machine code The instruction codes viewed view disassembled code As see example x86 architecture utilis es variable length instructions In simplified version instruction consist opcode ptionally one operands Opcode specifies operation performed operation usually specifying values memory locations registers operation In examp le 2 - byte opcode 83 EC tells processor subtract value 8 operand ESP register The n um ber type operands depend specific instruction Usually instruction comes forms allowing use different types operands Advanced Artefact Analysis Introduction advanced artefact analysis 13 Possible operand types Immediate value value encoded instruction like sub esp 8 Register operand one registers Memory operand memory specified offset encoded instruction In reality instruction structure little complicated If interested learning please refer Chapter 2 Volume 2 22 Instruction Format Registers A r egister small amount storage available processo r. Registers specific given instruction set architecture differ among processor families E contemporary processor least several registers available used different purposes The x 86 architecture provides 16 basic registers used general programming 8 general purpose registers EAX EBX ECX EDX ESI EDI EBP ESP 6 segment registers CS DS SS ES FS GS One flags register EFLAGS One instruction pointer register EIP In addition registers also several special purpose registers like debug registers control registers registers associated CPU extensions MMX SSE FPU etc General purpose registers used name suggests general registers different type operations arithmetic calculations address calculations hold memory pointers Additionally one also special role EAX accumulator register used different arithmetic operations EBX data pointer ECX counter register used loops EDX I/O pointer ESI source data pointer string operations EDI destination data pointer used string operations EBP base pointer used create stack frame function calls ESP stack pointer points top stack General purpose registers 32 - bit size however possible access 16 - 8 - bit registers using following pat tern 22 Intel® 64 IA - 32 Architectures Software Developer Manuals Vol 2 http //www.intel.com/content/dam/www/public/us/en/documents/manuals/64 - ia - 32 - architectures - software - developer - instruction - set - reference - manual - 325383.pdf last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 14 This means order access lower 16 bits EAX register refer AX register You also access lower higher 8 bits AX register referring adequately AL AH The scheme applies EBX ECX EDX registers It also applies ESI EDI EBP ESP except ca n access 8 bi registers The n ext group registers six segment registers CS DS SS ES FS GS In early days x86 processors used hold 16 - bit segment selectors use memory segmentation Since modern operating systems use pagin g flat memory model segment registers rarely used anymore special purposes 23 Example special usage FS register Win32 systems points Thread Information Block structure 24 The l ast two registers flag regis ter EFLAGS instruction pointer EIP EFLAGS register used store flags values holding information results previous operations system information The f ollowing basic flags available CF Carry Flag PF Parity Flag AF Auxiliary Carry Flag ZF Zero Flag SF Sign Flag TF Trap Flag IF Interrupt Enable Flag DF Direction Flag OF Overflow Flag IOPL I/O Privilege Level NT Nested Task RF Resume Flag VM Virtual - 8086 Mode AC Alignment Check VIF Virtual Interrupt Flag VIP Virtual Interrupt Pending ID ID Flag Flags bold called status flags They store information results arithmetic operations primar ily us ed conditional branch instructions For example Z ero flag ZF informs result operation zero O verflow flag OF indicates overflow integer number resulting value 23 What happened segment registers ? http //www.lshift.net/blog/2010/03/31/what - - happened - - - segment - registers/ last accessed 11.09.2015 24 Under Hoo https //www.microsoft.com/msj/archive/S2CE.aspx last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 15 either big small negative numbers To get detailed information flag role refer Volume 25 Different assembly instructions set clear different flags For example ADD instruction set OF SF ZF AF CF PF flags To get information flags set specific instruction r efer x86 ssembly instructions reference 26 Finally instruction pointer register EIP used hold address next instruction executed This register however directly accessed software neither read write purposes Memory organisation The Microsoft Windows system well contemporary operating systems uses flat memory model programs see memory conti guous linear address space Moreover thanks virtual memory concept process running Microsoft Windows gets access virtual address space 27 One outcomes process isolation Two different processes different data blocks loaded address v irtual address space none would able directly access memory second process without help operating system On Microsoft Windows system memory 32 - bit processes addressed 32 - bit addresses starting 0 0xFFFFFFFF 4GB Though address space available user - mode processes 28 User - mode processes access freely memory 0 0x7FFFFFFF 2GB 29 The econd half addresses 0x80000000 0xFFFFFFFF reserved operating system 25 Intel® 64 IA - 32 Architectures Software Developer Manuals http //www.intel.com/content/www/us/en/processors/architectures - software - developer - manuals.html last accessed 11.09.2015 26 Intel® 64 IA - 32 Architectures Software Developer Manuals Vol 2 http //www.intel.com/content/dam/www/public/us/en/documents/manuals/64 - ia - 32 - architectur es - software - developer - instruction - set - reference - manual - 325383.pdf last accessed 11.09.2015 27 Virtual address spaces https //msdn.microsoft.com/en - us/libr ary/windows/hardware/hh439648 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 28 User mode kernel mode https //msdn.microsoft.com/en - us/library/windows/har dware/ff554836 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 29 address 2GiB memory using special /LARGEADDRESSAWARE linker option https //msdn.microsoft.com/en - us/library/vstudio/wz223b1z % 28v=vs.100 % 29.aspx last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 16 When new PE executable started Windows system new process created system loader maps PE file h eap stack also created The Thread Environment Block TEB Process Environment Block PEB system structures providing information process For process one PEB struct ure separate TEBs one application thread Advanced Artefact Analysis Introduction advanced artefact analysis 17 This simplified version process address space normally would also contain memory blocks e.g block environment variables 30 multiple heaps You view detailed memory map process using VMMap tool Sysinternals 31 Two important memory structures stack heap The p rocess heap memory region dynamically allocated variables e.g using malloc put The tack hand used storing local variables tracing function calls current thread The tack l ast first LIFO data structure separate stack thread The op stack always pointed stack grows toward lower memory addresses This means whenever new value pushed onto stack ESP register decremented 30 Changing Environment Variables https //msdn.microsoft.com/en - us/library/windows/desktop/ms682009 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 31 VMMap https //technet.microsoft.com/en - us/library/dd535533.aspx last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 18 Except storing local variables stack also used passing f unction arguments tracing function calls This described later section Basic instructions There plenty different instructions x86 instruction set Additionally instruction usually comes forms allowing use different operand types registers immediate values memory addresses This section list common x86 Assembly instructions brief description one The following notation assumed operands < reg > - one general - p urpose registers < mem > - memory location < imm > - immediate value < rel > - address relative current instruction If bit suffix added operand type means operand bit size allowed operation example < reg 32 > - double - word general - purpose registers EAX EBX ECX EDX < reg16 > - word general - purpose registers AX BX CX DX 3.5.1 Data transfer instructions Instruction Description Affected flags mov < reg > < reg > mov < reg > < mem > mov < reg > < imm > mov < mem > < imm > mov < mem > < reg > Copies data second operand first operand None Advanced Artefact Analysis Introduction advanced artefact analysis 19 movsb Moves byte address ESI address EDI increases/decreases ESI EDI according DF flag None movsw Moves word address ESI address EDI increases/decreases ESI EDI according DF flag None xchg < reg > < reg > xchg < reg > < mem > xchg < mem > < reg > Exchanges contents first operand second operand None stosb Stores byte AL address EDI increases/decreases EDI according DF flag None stosw Stores word AX address EDI increases/decreases EDI according DF flag None lodsb Loads byte address ESI AL increases/decreases ESI according DF flag None lodsw Loads word address ESI AX increases/decreases ESI according DF flag None push < reg32/reg16 > push < mem32/mem16 > push < imm > Decrements stack pointer stores source operand top stack None pushfd Decrements stack pointer 4 stores entire EFLAGS register top stack None pushad Pushes general purpose registers onto stack following order EAX ECX EDX EBX ESP original EBP ESI EDI None pop < reg32/reg16 > pop < mem32/mem16 > Pops value top stack store destination operand Then increment stack pointer adequately None popfd Pops top stack EFLAGS register restores flags values All flags popad Pops EDI ESI EBP EBX EDX ECX EAX registers Value ESP regist er stack ignored None lea < reg > < mem > Computes effective address second operand memory offset stores first operand None 3.5.2 Arithmetic operations Instruction Description Affected flags add < reg > < imm > add < reg > < mem > add < reg > < reg > add < mem > < imm > add < mem > < reg > Adds second operand first operand stores result first operand OF SF ZF AF CF PF sub < reg > < imm > sub < reg > < mem > sub < reg > < reg > sub < mem > < imm > sub < mem > < reg > Subtracts second operand first operand OF SF ZF AF CF PF div < reg > div < mem > Unsigned divide Divides value stored EDX EAX source operand stores quotient EAX remainder EDX CF OF SF ZF AF PF Adva nced Artefact Analysis Introduction advanced artefact analysis 20 idiv < reg > idiv < mem > Sig ned divide Divides value stored EDX EAX source operand stores quotient EAX remainder EDX CF OF SF ZF AF PF mul < reg > mul < mem > Unsigned multiply Multiples value EAX destination operand Result store EDX EAX OF CF imul < reg > imul < mem > Signed multiply Multiples value EAX destination operand Result store EDX EAX There also two three operand version signed multiply Refer instruction reference information OF CF inc < reg > inc < mem > Adds 1 destination operand OF SF ZF AF PF dec < reg > dec < mem > Subtracts 1 destination operand OF SF ZF AF PF neg < reg > neg < mem > CF OF SF ZF AF PF sal < reg > < imm8 > sal < reg > CL sal < reg > 1 sal < mem > < imm8 > sal < mem > CL sal < mem > 1 Arithmetic shift left first operand < imm8 > /CL/1 CF OF SP ZP PP sar < reg > < imm8 > sar < reg > CL sar < reg > 1 sar < mem > < imm8 > sar < mem > CL sar < mem > 1 Arithmetic shift right first operand < imm8 > /CL/1 CF OF SP ZP PP cmp < reg > < reg > cmp < reg > < mem > cmp < reg > < imm > cmp < mem > < reg > cmp < mem > < imm > Compares first operand second operand subtracting second operand first setting appropriate f lags Operands values changed CF OF SF ZF AF PF 3.5.3 Logical operations Instruction Description Affected flags < reg > < reg > < reg > < mem > < reg > < imm > < mem > < reg > < mem > < imm > Bitwise AND operation first destination operand second source operand Result stored first operand OF CF cleared SF ZF PF set appropriately < reg > < reg > < reg > < mem > < reg > < imm > < mem > < reg > < mem > < imm > Bitwise inclusive OR operation first de stination operand second source operand Result stored first operand OF CF cleared SF ZF PF set appropriately < reg > < mem > Bitwise NOT operation None Advanced Artefact Analysis Introduction advanced artefact analysis 21 shl < reg > < imm8 > shl < reg > CL shl < reg > 1 shl < mem > < imm8 > shl < mem > CL shl < mem > 1 Logical shift left first operand < imm8 > /CL/1 OF SP ZP PP shr < reg > < imm8 > shr < reg > CL shr < reg > 1 shr < mem > < imm8 > shr < mem > CL shr < mem > 1 Logical shift right first operand < imm8 > /CL/1 OF SP ZP PP xor < reg > < reg > xor < reg > < mem > xor < reg > < imm > xor < mem > < reg > xor < mem > < imm > Bitwise exclusive OR XOR operation first destination operand second source operand Result stored first operand OF CF cleared SF ZF PF set appropriately test < reg > < reg > test < reg > < imm > test < mem > < reg > test < mem > < imm > Logical compare operation performing bitwise AND operation first second operand setting appropriate flags OF CF cleared SF ZF PF set appropriately 3.5.4 Control flow instructions Instruction Description Affected flags call < rel > call < reg > call < mem > Procedure call Saves return address stack branches called procedure None ret ret < imm16 > Return return address popped stack Optionally releases < imm16 > bytes stack None leave Releases stack frame Copies frame pointer EBP stack pointer register ESP pops old frame pointer stack None int < imm8 > Generates interrupt specified immediate value operand calls interrupt handler EFLAGS register pushed onto stack Certain flags might affected depending interrupt nop No operation Does nothing Machine code 0x90 useful debu gging None loop < imm8 > Performs loop operation Jumps short ECX=0 decrementing ECX iteration None Advanced Artefact Analysis Introduction advanced artefact analysis 22 3.5.5 Jump instructions Instruction Description Affected flags jmp < rel > jmp < reg > jmp < mem > Always jumps address specified operand None je/jz < rel > Jumps equal/zero ZF=1 None ja < rel > Jumps CF=0 ZF=0 None jb < rel > Jumps CF=1 None jae < rel > Jumps equal CF=0 None jbe < rel > Jumps equal CF=1 ZF=1 None jne/jnz < rel > Jumps equal/zero ZF=0 None jna < rel > Jumps CF=1 ZF=1 None jnb < rel > Jumps CF=0 None Function calls stack frame calling conventions A f unction part code called multiple times different locations specific task perform The f unction concept also present assembly language X86 sembly supports function calls introducing spec ial instructions e.g call ret leave registers like EBP used hold address current stack frame described detail later Functions called using call instruction When function called address instruction follow ing call return address pushed onto stack This address later used ret instruction return back code function called Consider example In example instruction call func_1 executed address 0x40100C pushed onto stack When function returns execution resume address A ypical function call looks like 1 Passing parameters function 2 Calling function 3 Reserving stack memor local variables 4 Function operations 5 Restoring stack 6 Function return optionally cleaning function arguments To ease referencing parameters loca l variables restoring stack functions frequently use EBP based stack frames The tack frame created beginning function pushing previous EBP value onto stack saving current stack pointer ESP value EBP register Creation tack frame typically looks like following Advanced Artefact Analysis Introduction advanced artefact analysis 23 This often call ed function prologue After stack look like assuming also two arguments passed function stack relatively changes function body If function using EBP based stack frame restoration original stack function end also relatively easy takes wo steps first EBP copied ESP restoring ESP value function beginning old EBP popped top stack This often referred function epilogue R estoration stack necessary ret instruction reached top stack contain return address In example parameters passed function stack This n always need case The exact way function called arguments passed defined called calling conventions There popular calling conventions use depending compiler code In general calling convention defines How parameters passed function The order function parameters passed left right right left How function returning value Which registers preserved called function Such registers still used function function returns value sh ould restored Advanced Artefact Analysis Introduction advanced artefact analysis 24 What done parameters passed function via stack ? Should cleaned called function callee clean - caller ? Below find short description popular calling conventions cdecl __cdecl This efault calling convention C C++ programs 32 A rguments pa ssed stack right left F unction result returned EAX register A registers except EAX ECX EDX preserved callee C aller cleans arguments stack stdcall __stdcall Standard calling convention Windows Win32 API functions 33 A rguments passed stack right left F unction result returned EAX register A registers except EAX ECX EDX preserved cal lee C allee cleans arguments stack returning fastcall __fastcall This l ess commonly used calling convention 34 The f irst two arguments left right passed ECX EDX registers arguments right left passe stack The f unction result returned EAX register A registers except EAX ECX EDX preserved callee C allee cleans arguments stack returning arguments thiscall __thiscall This c alling convention used C++ non - static member functions 35 Its implementation slightly differs among compilers GCC Microsoft Visual C++ Similarly calling conventions arguments passed stack right left Additionally ECX register The f unction result returned EAX 32 __cdecl https //msdn.microsoft.com/en - us/library/zkwh89ks.aspx last accessed 11.09.2015 33 __stdcall https //msdn.microsoft.com/en - us/library/zxk0tw93.aspx last accessed 11.09.2015 34 __fastcall https //msdn.microsoft.com/en - us/library/6xa169sk.aspx last accessed 11.09.2015 35 __thiscall https //msdn.microsoft.com/en - us/library/ek8tkfbw.aspx last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 25 4 Tools overview In trainin g using Ol lyDbg 36 primary debugger second part Advanced Dynamic Analysis IDA Pro Free 37 disassembler third part Advanced Static Analysis Even hough popular powerful choice This section pr esents popular freely available debuggers disassemblers Portable Executable files OllyDbg Very popular powerful graphical debugger created Oleh Yuschuk 32 - bit Portable Executable PE files time writing work 64bit version started A big advantage OllyDbg community years created dozens plugins scripts tutorials freely available online anyone interested OllyDbg small lightweight intuitive interface Some features Multiple debugging modes step step trace animate execute till return etc Software hardware memory breakpoints Conditional breakpoints Properly recognizing Windows API funct ions Dynamic annotations code API function called arguments names Various search modes referenced strings searching whole memory Customizability plugins mechanism Multiple configuration options debugging appear ance Tracing stack frames Support easy patching code editing assembly Can create new process attach existing process Can set - - time debugger OllyDbg downloaded http //www.ollydbg.de/ 36 OllyDbg http //www.ollydbg.de/ last ccessed 11.09.2015 37 F reeware version IDA v5.0 https //www.hex - rays.com/products/ida/support/download_freeware.shtml last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 26 Immunity Debugger A p opular graphical debugger based OllyDbg code makes similar tool It gained In comparison OllyDbg advantage integration Python allowing automate certain tasks using Python scripts It also capability making function graphs similar graphs IDA disassembler The Immunity Debugger wnloaded http //immunityinc.com/products/debugger/index.html Advanced Artefact Analysis Introduction advanced artefact analysis 27 Advanced Artefact Analysis Introduction advanced artefact analysis 28 WinDbg WinDbg 38 powerful debugger distributed f ree Microsoft In contrast OllyDbg Immunity Debugg er WinDbg text mode debugger without nice visual presentation disassembled code Most things WinDbg done executing commands command line This makes dif ficult beginner learn What makes WinDbg powerf ul integration symbol files provided Microsoft let see additional information various system structures Unlike OllyDbg Immunity Debugger WinDbg also allows debug 64 - bit executables kernel - level debugging nalysis crash dump files WinDbg scripting language thanks PyKd 39 WinAppDbg PyDbg WinAppDbg 40 older PyDbg part PaiMei 41 project debuggers classical sense intended instruction tracing code analysis Instead Python modules allowing create fully scriptable debugger You use cre ate debugging scripts automati ng certain debugging tasks There many use cases scripts They usually come handy know malicious code following particular scheme For example repeatedly observing campaigns malware 38 Debugging Tools Wi ndows WinDbg KD CDB NTSD https //msdn.microsoft.com/library/windows/hardware/ff551063 % 28v=vs.85 % 29.aspx last accessed 11.09.2015 39 Python extension WinDbg https //pykd.codeplex.com/ last accessed 11.09.2015 40 WinAppDbg http //winappdbg.sourceforge.net/ last accessed 11.09.2015 41 PaiMei http //pedramamini.com/PaiMei/docs/ last accessed 11.09.2015 Adva nced Artefact Analysis Introduction advanced artefact analysis 29 connecting diff erent botnet infrastructures might create script automatically finding C & C addresses dumping configuration files Another use case would create unpacking scripts repeatedly observed samples packed packer Finally also create application fuzzers used vulnerability research various system monitoring tools could example used high interaction honeypot IDA Pro Many malware researchers reverse engineers nowadays use IDA Pro Though co mmercial non - free product also provide freeware version IDA Freeware 42 IDA Free ware older version IDA Pro limited certain functions intended non - commercial use Despite limitations IDA Freeware still ry powerful disassembler allows perform advanced analyses malicious code IDA interactive disassembler supporting many executable file types processor architectures One valuable feature graph view offers visualis ation function structure This helps understand function execution flow sometimes guess purpose IDA also provides many different types data views helping better understand analysed binary file s. IDA customis able also possible create custom scripts scripting language IDC newer versions use Python scripts Additionally thanks FLIRT engine IDA disassembles executable code also tries detect code statically linked libraries usually necessary analyse 42 F reeware version IDA v5.0 https //www.hex - rays.com/products/ida/support/ download_freeware.shtml last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 30 Radare2 Radare2 43 dynamically developing open source project providing complete reverse - engineering framework One elements disassembler supporting multiple types executable files processor architectures Besides disassembling executable files R adare2 allows debugging samples either local debugger remote debuggers Radare2 also provides foren sic capabilitie aids exploit development Radare2 available multiple platforms Linux Windows OS X also part REMnux 44 Linux distribution By origin command line CLI utility web interface PyGTK GUI also ava ilable seen following picture acquired http //cloud.radare.org/m/ 43 R adare2 https //github.com/radare/radare2 last accessed 11.09.2015 44 REMnux https //remnux.org/ last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 31 5 Environment preparation All analyses malicious files performed dedicated isolated environment Most often would group properly configured virtual machines The role environment prevent malicious code accessing private data infecting hosts local network An e xample environment desc ribed Building artefact handling analysis environment exercise ENISA Artefact Analysis training 45 In training using single virtual machine Microsoft Windows operating system Microsoft Windows 7 32 - bit without n etwork connectivity To learn create virtual machine install necessary tools refer Building artefact handling analysis environment training description Winbox VM Note since network connection necessary make sure network connection end process Samples used training provided separate archive Password archive infected commonly used password archives containing malicious code Please note purpose archiving password make user aware malicious ness code avoid running accidentally It intended conf identiality measure Unpack ing archive reveal following samples Do n execute samples creating snapshot clean virtual machine ! Before proceed second part training make sure 45 Training Courses https //www.enisa.europa.eu/activities/cert/training/courses last accessed 11.09.2015 Advanced Artefact Analysis Introduction advanced artefact analysis 32 There access Virtual Machine Internet access local network You installed necessary tools copied malware samples You start following programs OllyDbg Process Hacker IDA Pro Free Note OllyDbg Process Hacker always run administrator You created clean snapshot system executing sample Finally training dealing live malware samples hould always remember take proper security precautions Analyse malicious files dedicated controlled environment isolated local network private files sensitive data If using virtualis ation technology make sure using newest stable version software Also n install Guest Additions virtual machine disable Internet connection virtual machine Othe rwise malicious code running virtual machine might start sending spam attacking hosts Internet Restore snapshot specified otherwise exercise This necessary previously run malicious code may made changes operating system may prevent next ample executing correctly Remember dynamic analysis malicious code debugger really exec uting malicious code slower ! A debugger lets processor execute machine commands results affect environment way would run without debugger Safety operation depends solely selecting cautiously parts code may run really necessary move malicious files password protected archive first This protect accidentally executing sa mple When store malicious files make sure everyone access files know A good idea put malicious files directory clear suggestive name Follow instructions trainer Advanced Artefact Analysis Introduction advanced artefact analysis 33 6 Training summary In training introduced advanced dynamic static analysis concept You learnt difference differ basic analysis presented ENISA Artefact Analysis training Follow ing given introduction x86 assembly language n essential skill comes advanced analysis malicious code This part explained fundamental concepts x86 assembly language like instructions opcodes operands registers memory organisation functions Most common assembly instructions also presented Additionally presented commonly used freely available debuggers disassemblers Finally part training ended short summary describing prepare environment exercises security precautions undertaken analysis malicious code ENISA European Union Agency Network Information Security Science Technology Park Crete ITE Vassilika Vouton 700 13 Heraklion Greece Athens Office 1 Vass Sofias & Meg Alexandrou Marousi 151 24 Athens Greece PO Box 1309 710 01 Heraklion Greece Tel +30 28 14 40 9710 info @ enisa.europa.eu www.enisa.europa.eu 